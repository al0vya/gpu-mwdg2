add_subdirectory(classes)
add_subdirectory(input)
add_subdirectory(mra)
add_subdirectory(neighbours)
add_subdirectory(operators)
add_subdirectory(output)
add_subdirectory(utilities)
add_subdirectory(unittests)
add_subdirectory(zorder)

target_sources(
	    gpu-mwdg2
		PRIVATE
		main.cu
		run_simulation.cu
	)
#include "run_simulation.cuh"

int main
(
	int    argc,
	char** argv
)
{
	#if _RUN_UNIT_TESTS
	if (argc == 1)
	{
		run_unit_tests();
	}
	#endif
	
	if (argc < 2)
	{
		printf("\nNo parameter file specified in command line. Exiting.\n");
		return 0;
	}

	run_simulation(argc, argv);

	return 0;
}
#include "run_simulation.cuh"

void run_simulation
(
	int    argc,
	char** argv
)
{
	const clock_t start = clock();

	const char* input_filename = argv[argc - 1];
	
	const int test_case = read_test_case(input_filename);
	
	// Structures for setting up simulation
	SolverParams     solver_params(input_filename);
	SimulationParams sim_params(test_case, input_filename, solver_params.L);
	PlottingParams   plot_params(input_filename);
	Depths1D         bcs(test_case);
	SaveInterval     saveint(input_filename, "saveint");
	SaveInterval     massint(input_filename, "massint");

	read_command_line_params
	(
		argc,
		argv,
		sim_params,
		solver_params,
		plot_params
	);

	int mesh_dim      = 1 << solver_params.L;
	int interface_dim = mesh_dim + 1;

	real dx_finest = (test_case != 0) ? (sim_params.xmax - sim_params.xmin) / mesh_dim : read_cell_size(input_filename);
	real dy_finest = (test_case != 0) ? (sim_params.ymax - sim_params.ymin) / mesh_dim : read_cell_size(input_filename);
	real dt        = C(0.001);

	int num_finest_elems      = mesh_dim * mesh_dim;
	int num_blocks_finest     = get_num_blocks(num_finest_elems, THREADS_PER_BLOCK);
	int num_threads_traversal = num_finest_elems / 4;
	int num_blocks_traversal  = get_num_blocks(num_threads_traversal, THREADS_PER_BLOCK);
	int num_all_elems         = get_lvl_idx(solver_params.L + 1);
	int num_details           = get_lvl_idx(solver_params.L);
	int num_blocks_details    = get_num_blocks(num_details, THREADS_PER_BLOCK);
	int num_blocks_sol        = 0;
	int num_blocks_all        = get_num_blocks(num_all_elems, THREADS_PER_BLOCK);
	
	HierarchyIndex finest_lvl_idx = get_lvl_idx(solver_params.L);
	
	// Structures
	Maxes maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	
	StagePoints  stage_points (input_filename, sim_params, dx_finest);
	Boundaries   boundaries   (input_filename, sim_params, dx_finest, test_case);
	PointSources point_sources(input_filename, sim_params, dx_finest, test_case, dt);
	
	clock_t end             = clock();
	clock_t mra_start       = clock();
	clock_t mra_end         = clock();
	clock_t solver_start    = clock();
	clock_t solver_end      = clock();
	real    run_time        = C(0.0);
	real    current_time    = C(0.0);
	real    time_mra        = C(0.0);
	real    time_solver     = C(0.0);
	bool    first_timestep  = true;
	bool    for_nghbrs      = false;
	bool    rkdg2           = false;
	float   avg_cuda_time   = 0.0f;
	int     timestep        = 1;
	real    compression     = C(0.0);

	NodalValues       d_nodal_vals      (interface_dim);
	AssembledSolution d_assem_sol       (num_finest_elems, solver_params.solver_type);
	AssembledSolution d_buf_assem_sol   (num_finest_elems, solver_params.solver_type);
	AssembledSolution d_plot_assem_sol  (num_finest_elems, solver_params.solver_type);
	Neighbours        d_neighbours      (num_finest_elems, solver_params.solver_type);
	Neighbours        d_buf_neighbours  (num_finest_elems, solver_params.solver_type);
	ScaleCoefficients d_scale_coeffs    (solver_params);
	Details           d_details         (solver_params);
	CompactionFlags   d_compaction_flags(num_finest_elems);
	FinestGrid        p_finest_grid     (num_finest_elems);
	
	// Bytesizes
	size_t bytes_morton  = num_finest_elems * sizeof(MortonCode);
	size_t bytes_details = num_details      * sizeof(real);
	size_t bytes_soln    = num_finest_elems * sizeof(real);

	// Arrays
	MortonCode* d_morton_codes        = (MortonCode*)malloc_device(bytes_morton);
	MortonCode* d_sorted_morton_codes = (MortonCode*)malloc_device(bytes_morton);
	MortonCode* d_indices             = (MortonCode*)malloc_device(bytes_morton);
	MortonCode* d_rev_z_order         = (MortonCode*)malloc_device(bytes_morton);
	MortonCode* d_rev_row_major       = (MortonCode*)malloc_device(bytes_morton);
	real*       d_eta_temp            = (real*)malloc_device(bytes_soln);
	real*       d_norm_details        = (real*)malloc_device(bytes_details);
	bool*       d_sig_details         = (bool*)malloc_device(num_details);
	real*       d_dt_CFL              = (real*)malloc_device(bytes_soln);
	
	bool* d_preflagged_details = preflag_details
	(
		boundaries, 
		point_sources, 
		stage_points, 
		sim_params, 
		solver_params, 
		num_details, 
		solver_params.L, 
		test_case
	);

	if (test_case != 0)
	{
		get_nodal_values
		(
			d_nodal_vals,
			dx_finest,
			dy_finest,
			bcs,
			sim_params,
			interface_dim,
			test_case
		);
	}

	get_modal_values
	(
		d_nodal_vals,
		d_buf_assem_sol,
		solver_params,
		sim_params,
		mesh_dim,
		interface_dim,
		test_case,
		input_filename
	);

	generate_all_morton_codes<<<num_blocks_finest, THREADS_PER_BLOCK>>>
	(
		d_morton_codes,
		d_indices,
		mesh_dim
	);

	get_sorting_indices
	(
		d_morton_codes,
		d_sorted_morton_codes,
		d_buf_assem_sol,
		d_assem_sol,
		d_indices,
		d_rev_z_order,
		d_rev_row_major,
		solver_params
	);

	sort_finest_scale_coeffs_z_order<<<num_blocks_finest, THREADS_PER_BLOCK>>>
	(
		d_buf_assem_sol,
		d_assem_sol,
		d_rev_z_order,
		solver_params
	);

	copy_finest_coefficients<<<num_blocks_finest, THREADS_PER_BLOCK>>>
	(
		d_assem_sol,
		d_scale_coeffs,
		solver_params,
		finest_lvl_idx
	);

	if (point_sources.num_srcs > 0)
	{
		insert_point_srcs<<<get_num_blocks(point_sources.num_srcs, THREADS_PER_BLOCK), THREADS_PER_BLOCK>>>
		(
			d_assem_sol, 
			point_sources, 
			dt, 
			dx_finest
		);
	}

	init_sig_details<<<num_blocks_details, THREADS_PER_BLOCK>>> //d_sig_details[idx] = true;
	(
		d_sig_details, 
		num_details
	);

	maxes = get_max_scale_coeffs(d_assem_sol, d_eta_temp);

	#if _RUN_UNIT_TESTS
	generate_data_unit_test_preflag_topo
	(
		plot_params.dirroot,
		"input",
		d_scale_coeffs,
		d_details,
		d_preflagged_details,
		solver_params
	);
	#endif

	preflag_topo
	(
		d_scale_coeffs, 
		d_details,  
		d_preflagged_details, 
		maxes,
		solver_params
	);

	#if _RUN_UNIT_TESTS
	generate_data_unit_test_preflag_topo
	(
		plot_params.dirroot,
		"output",
		d_scale_coeffs,
		d_details,
		d_preflagged_details,
		solver_params
	);
	#endif

	// main solver loop
	while (current_time < sim_params.time)
	{
		current_time += dt;

		if ( (current_time - sim_params.time) > C(0.0) )
		{
			current_time -= dt;
			dt = sim_params.time - current_time;
			current_time += dt;
		}
		
		mra_start = clock();

		zero_details<<<num_blocks_details, THREADS_PER_BLOCK>>>
		(
			d_details,
			d_norm_details,
			num_details,
			solver_params
		);

		maxes = get_max_scale_coeffs(d_assem_sol, d_eta_temp);

		if (!first_timestep)
		{						
			reinsert_assem_sol<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_assem_sol,
				d_assem_sol.act_idcs,
				d_scale_coeffs,
				solver_params
			);
		}

		point_sources.update_all_srcs(current_time);

		if (point_sources.num_srcs > 0)
		{
			reinsert_point_srcs<<<get_num_blocks(point_sources.num_srcs, THREADS_PER_BLOCK), THREADS_PER_BLOCK>>>
			(
				d_scale_coeffs, 
				point_sources, 
				dt, 
				dx_finest, 
				solver_params.L
			);
		}

		if (solver_params.epsilon > C(0.0) || first_timestep)
		{
		    for_nghbrs = false;
		    
			#if _RUN_UNIT_TESTS
			generate_data_unit_test_encode_flow
			(
				plot_params.dirroot,
				"input",
				d_scale_coeffs,
				d_details,
				d_norm_details,
				d_sig_details,
				d_preflagged_details,
				solver_params,
				timestep
			);
			#endif

		    encode_flow
		    (
		    	d_scale_coeffs,
		    	d_details,
		    	d_norm_details,
		    	d_sig_details,
		    	d_preflagged_details,
		    	maxes,
		    	solver_params,
		    	for_nghbrs
		    );
		    
			#if _RUN_UNIT_TESTS
			generate_data_unit_test_encode_flow
			(
				plot_params.dirroot,
				"output",
				d_scale_coeffs,
				d_details,
				d_norm_details,
				d_sig_details,
				d_preflagged_details,
				solver_params,
				timestep
			);
			#endif

		    get_reg_tree
		    (
		    	d_sig_details,
		    	solver_params
		    );
		    
			#if _RUN_UNIT_TESTS
			generate_data_unit_test_decoding
			(
				plot_params.dirroot,
				"input",
				d_sig_details,
				d_norm_details,
				d_details,
				d_scale_coeffs,
				solver_params,
				timestep
			);
			#endif

		    decoding // contains extra sig
		    (
		    	d_sig_details,
		    	d_norm_details,
		    	d_details,
		    	d_scale_coeffs,
		    	solver_params
		    );

			#if _RUN_UNIT_TESTS
			generate_data_unit_test_decoding
			(
				plot_params.dirroot,
				"output",
				d_sig_details,
				d_norm_details,
				d_details,
				d_scale_coeffs,
				solver_params,
				timestep
			);
			#endif
		    
		    traverse_tree_of_sig_details<<<num_blocks_traversal, THREADS_PER_BLOCK>>>
		    (
		    	d_sig_details,
		    	d_scale_coeffs,
		    	d_buf_assem_sol,
		    	num_threads_traversal,
		    	solver_params
		    );
		    
		    rev_z_order_act_idcs<<<num_blocks_finest, THREADS_PER_BLOCK>>>
		    (
				d_rev_row_major,
		    	d_buf_assem_sol,
		    	d_assem_sol,
		    	num_finest_elems
		    );
		    
		    find_neighbours<<<num_blocks_finest, THREADS_PER_BLOCK>>>
		    (
		    	d_assem_sol,
		    	d_neighbours,
		    	sim_params,
		    	mesh_dim
		    );
		    
		    get_compaction_flags<<<num_blocks_finest, THREADS_PER_BLOCK>>>
		    (
		    	d_buf_assem_sol,
		    	d_compaction_flags,
		    	num_finest_elems
		    );
		    
		    sort_neighbours_z_order<<<num_blocks_finest, THREADS_PER_BLOCK>>>
		    (
		    	d_neighbours,
		    	d_buf_neighbours,
		    	d_rev_z_order,
		    	num_finest_elems,
		    	solver_params
		    );
		    
		    compaction
		    (
		    	d_buf_assem_sol,
		    	d_assem_sol,
		    	d_buf_neighbours,
		    	d_neighbours,
		    	d_compaction_flags,
		    	num_finest_elems,
		    	solver_params
		    );
		}

		num_blocks_sol = get_num_blocks(d_assem_sol.length, THREADS_PER_BLOCK);

		load_soln_and_nghbr_coeffs<<<num_blocks_sol, THREADS_PER_BLOCK>>>
		(
			d_neighbours,
			d_scale_coeffs,
			d_assem_sol,
			solver_params
		);

		boundaries.update_all_inlets(input_filename, current_time);

		add_ghost_cells<<<num_blocks_sol, THREADS_PER_BLOCK>>>
		(
			d_assem_sol,
			d_neighbours,
			solver_params,
			sim_params,
			boundaries,
			current_time,
			dt,
			dx_finest,
			test_case
		);

		mra_end = clock();

		time_mra += (real)(mra_end - mra_start) / CLOCKS_PER_SEC;

		solver_start = clock();

		if ( sim_params.manning > C(0.0) )
		{
			friction_implicit<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_assem_sol,
				d_neighbours,
				solver_params, 
				sim_params, 
				dt
			);
		}

		if (solver_params.solver_type == HWFV1)
		{
			fv1_update<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_neighbours,
				d_assem_sol,
				solver_params,
				sim_params,
				dx_finest,
				dy_finest,
				dt,
				d_dt_CFL
			);
		}
		else if (solver_params.solver_type == MWDG2)
		{
			copy_to_buf_assem_sol
			(
				d_assem_sol, 
				d_buf_assem_sol
			);

			if (solver_params.limitslopes)
			{
				limit_slopes<<<num_blocks_sol, THREADS_PER_BLOCK>>>
				(
					d_assem_sol,
					d_neighbours,
					sim_params,
					solver_params,
					dx_finest,
					dy_finest,
					maxes.h
				);
			}

			rkdg2 = false;

			dg2_update<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_neighbours, 
				d_assem_sol, 
				d_buf_assem_sol, 
				solver_params, 
				sim_params, 
				dx_finest, 
				dy_finest, 
				dt, 
				test_case,
				d_dt_CFL,
				rkdg2
			);

			reinsert_assem_sol<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_buf_assem_sol,
				d_assem_sol.act_idcs,
				d_scale_coeffs,
				solver_params
			);

			if ( solver_params.epsilon > C(0.0) )
			{
				for_nghbrs = true;

				encode_flow
				(
					d_scale_coeffs,
					d_details,
					d_norm_details,
					d_sig_details,
					d_preflagged_details,
					maxes,
					solver_params,
					for_nghbrs
				);
			}
			
			load_soln_and_nghbr_coeffs<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_neighbours,
				d_scale_coeffs,
				d_buf_assem_sol,
				solver_params
			);

			add_ghost_cells<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_buf_assem_sol,
				d_neighbours,
				solver_params,
				sim_params,
				boundaries,
				current_time,
				dt,
				dx_finest,
				test_case
			);

			rkdg2 = true;
			
			if (solver_params.limitslopes)
			{
				maxes.h = get_max_from_array
				(
					d_buf_assem_sol.h0, 
					d_buf_assem_sol.length
				);
				
				limit_slopes<<<num_blocks_sol, THREADS_PER_BLOCK>>>
				(
					d_buf_assem_sol,
					d_neighbours,
					sim_params,
					solver_params,
					dx_finest,
					dy_finest,
					maxes.h
				);
			}

			dg2_update<<<num_blocks_sol, THREADS_PER_BLOCK>>>
			(
				d_neighbours, 
				d_buf_assem_sol, 
				d_assem_sol, 
				solver_params, 
				sim_params, 
				dx_finest, 
				dy_finest, 
				dt, 
				test_case, 
				d_dt_CFL,
				rkdg2
			);

		}

		dt = get_dt_CFL(d_dt_CFL, d_assem_sol.length);

		solver_end = clock();

		time_solver += (real)(solver_end - solver_start) / CLOCKS_PER_SEC;

		if ( saveint.save(current_time) )
		{
			if (plot_params.vtk)
			{
				write_soln_vtk
				(
					plot_params,
					d_assem_sol,
					d_dt_CFL,
					dx_finest,
					dy_finest,
					sim_params,
					solver_params,
					saveint
				);
			}
			
			if (plot_params.raster_out)
			{
				write_all_raster_maps
				(
					plot_params,
					d_assem_sol,
					dx_finest,
					dy_finest,
					sim_params,
					solver_params,
					saveint,
					first_timestep
				);
			}

			if (plot_params.c_prop)
			{
				write_c_prop_data
				(
					plot_params,
					start,
					solver_params,
					sim_params,
					d_assem_sol,
					current_time,
					time_mra,
					time_solver,
					dt,
					d_assem_sol.length,
					first_timestep
				);
			}
		}

		if ( massint.save(current_time) )
		{
			if (plot_params.cumulative)
			{
			    write_cumulative_data
			    (
			        start,
			        current_time,
			        time_mra,
			        time_solver,
					dt,
					d_assem_sol.length,
					sim_params,
			        plot_params,
			        first_timestep
			    );
			}
			
			project_assem_sol
			(
				mesh_dim,
				d_sig_details,
				d_scale_coeffs,
				d_buf_assem_sol,
				solver_params,
				d_rev_z_order,
				d_indices,
				d_assem_sol,
				d_plot_assem_sol
			);
			
			write_stage_point_data
			(
				mesh_dim,
				solver_params,
				plot_params,
				d_plot_assem_sol,
				p_finest_grid,
				stage_points,
				current_time,
				dx_finest,
				dy_finest,
				first_timestep
			);
		}

		if (timestep % 10000 == 1)
		{
			compression = C(100.0) - C(100.0) * d_assem_sol.length / (sim_params.xsz * sim_params.ysz);

			printf
			(
				"Elements: %d, compression: %f%%, time step: %f, timestep: %d, sim time: %f\n",
				d_assem_sol.length, compression, dt, timestep, current_time
			);
		}

		timestep++;
		
 		first_timestep = false;

		#if _RUN_UNIT_TESTS
		if (timestep > 2)
		{
			break;
		}
		#endif
	}

	end = clock();
	
	compression = C(100.0) - C(100.0) * d_assem_sol.length / (sim_params.xsz * sim_params.ysz);

	printf
	(
		"Elements: %d, compression: %f%%, time step: %f, timestep: %d, sim time: %f\n",
		d_assem_sol.length, compression, dt, timestep, current_time
	);
	
	run_time = (real)(end - start) / CLOCKS_PER_SEC;
	
	printf("Loop time: %f s\n", run_time);

	CHECK_CUDA_ERROR( free_device(d_morton_codes) );
	CHECK_CUDA_ERROR( free_device(d_sorted_morton_codes) );
	CHECK_CUDA_ERROR( free_device(d_indices) );
	CHECK_CUDA_ERROR( free_device(d_rev_z_order) );
	CHECK_CUDA_ERROR( free_device(d_rev_row_major) );
	CHECK_CUDA_ERROR( free_device(d_eta_temp) );
	CHECK_CUDA_ERROR( free_device(d_sig_details) );
	CHECK_CUDA_ERROR( free_device(d_preflagged_details) );
	CHECK_CUDA_ERROR( free_device(d_norm_details) );
	CHECK_CUDA_ERROR( free_device(d_dt_CFL) );
}

#pragma once

// Kernels
#include "zorder/generate_all_morton_codes.cuh"
#include "zorder/copy_finest_coefficients.cuh"
#include "mra/insert_point_srcs.cuh"
#include "mra/reinsert_point_srcs.cuh"
#include "mra/init_sig_details.cuh"
#include "mra/zero_details.cuh"
#include "mra/traverse_tree_of_sig_details.cuh"
#include "neighbours/find_neighbours.cuh"
#include "neighbours/get_compaction_flags.cuh"
#include "neighbours/load_soln_and_nghbr_coeffs.cuh"
#include "neighbours/add_ghost_cells.cuh"
#include "operators/friction_implicit.cuh"
#include "operators/limit_slopes.cuh"
#include "operators/fv1_update.cuh"
#include "operators/dg2_update.cuh"

// Kernel wrappers
#include "mra/get_nodal_values.cuh"
#include "mra/get_modal_values.cuh"
#include "zorder/sort_finest_scale_coeffs_z_order.cuh"
#include "mra/get_max_scale_coeffs.cuh"
#include "mra/preflag_topo.cuh"
#include "mra/encode_flow.cuh"
#include "mra/get_reg_tree.cuh"
#include "mra/decoding.cuh"
#include "zorder/rev_z_order_act_idcs.cuh"
#include "zorder/rev_z_order_reals.cuh"
#include "zorder/sort_neighbours_z_order.cuh"
#include "neighbours/compaction.cuh"
#include "operators/get_dt_CFL.cuh"

// Input/output
#include "input/read_cell_size.h"
#include "input/read_command_line_params.h"
#include "input/read_test_case.h"
#include "output/write_all_raster_maps.cuh"
#include "output/write_c_prop_data.cuh"
#include "output/write_mesh_info.h"
#include "output/write_stage_point_data.cuh"
#include "output/write_soln_vtk.cuh"
#include "output/write_hierarchy_array_bool.cuh"

// Helper functions
#include "utilities/get_lvl_idx.cuh"
#include "mra/preflag_details.cuh"
#include "output/project_assem_sol.cuh"
#include "operators/copy_to_buf_assem_sol.cuh"

// Sorting
#include "zorder/get_sorting_indices.cuh"

// Unit tests
#include "unittests/generate_data_unit_tests.cuh"
#include "unittests/run_unit_tests.cuh"

void run_simulation
(
	int    argc,
	char** argv
);
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../types/real.h"
#include "../types/HierarchyIndex.h"
#include "../types/SolverTypes.h"

typedef struct AssembledSolution
{
	real* h0;
	real* qx0;
	real* qy0;
	real* z0;

	real* h1x;
	real* qx1x;
	real* qy1x;
	real* z1x;
	
	real* h1y;
	real* qx1y;
	real* qy1y;
	real* z1y;
	
	HierarchyIndex* act_idcs;

	int* levels;
	int  length;
	bool is_copy_cuda = false;

	AssembledSolution(const int& num_finest_elems, const int& solver_type)
	{
		size_t bytes_real = num_finest_elems * sizeof(real);
		size_t bytes_int  = num_finest_elems * sizeof(HierarchyIndex);

		h0  = (real*)malloc_device(bytes_real);
		qx0 = (real*)malloc_device(bytes_real);
		qy0 = (real*)malloc_device(bytes_real);
		z0  = (real*)malloc_device(bytes_real);

		h1x  = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;
		qx1x = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;
		qy1x = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;
		z1x  = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;

		h1y  = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;
		qx1y = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;
		qy1y = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;
		z1y  = (solver_type == MWDG2) ? (real*)malloc_device(bytes_real) : nullptr;

		act_idcs = (HierarchyIndex*)malloc_device(bytes_int);
		levels   = (int*)malloc_device(bytes_int);
		length   = num_finest_elems;
	}

	AssembledSolution(const AssembledSolution& original) { *this = original; is_copy_cuda = true; }

	~AssembledSolution()
	{
		if (!is_copy_cuda)
		{
			CHECK_CUDA_ERROR( free_device(h0) );
			CHECK_CUDA_ERROR( free_device(qx0) );
			CHECK_CUDA_ERROR( free_device(qy0) );
			CHECK_CUDA_ERROR( free_device(z0) );

			CHECK_CUDA_ERROR( free_device(h1x) );
			CHECK_CUDA_ERROR( free_device(qx1x) );
			CHECK_CUDA_ERROR( free_device(qy1x) );
			CHECK_CUDA_ERROR( free_device(z1x) );

			CHECK_CUDA_ERROR( free_device(h1y) );
			CHECK_CUDA_ERROR( free_device(qx1y) );
			CHECK_CUDA_ERROR( free_device(qy1y) );
			CHECK_CUDA_ERROR( free_device(z1y) );

			CHECK_CUDA_ERROR( free_device(act_idcs) );
			CHECK_CUDA_ERROR( free_device(levels) );
		}
	}

} AssembledSolution;
#pragma once

#include "Boundary.h"

typedef struct Boundaries
{
	Boundary north;
	Boundary east;
	Boundary south;
	Boundary west;

	Boundaries
	(
		const char*                 input_filename,
		const SimulationParams& sim_params,
		const real&                 cell_size,
		const int&                  test_case
	)
	:
		north(input_filename, sim_params, cell_size, test_case, NORTH),
		east (input_filename, sim_params, cell_size, test_case, EAST),
		south(input_filename, sim_params, cell_size, test_case, SOUTH),
		west (input_filename, sim_params, cell_size, test_case, WEST)
	{
		if (test_case != 0) fprintf(stdout, "Running built-in test case, using open boundary conditions.\n");
	}

	void update_all_inlets
	(
		const char* input_filename,
		const real& current_time
	)
	{
		north.update_inlet(current_time);
		east.update_inlet (current_time);
		south.update_inlet(current_time);
		west.update_inlet (current_time);
	}

} Boundaries;
#pragma once

#include "cuda_runtime.h"

#include <cstdio>
#include <cstdlib>
#include <cstring>

#include "../types/Directions.h"
#include "../types/Coordinate.h"
#include "../types/MortonCode.h"
#include "../types/InletTypes.h"
#include "../classes/SimulationParams.h"

#include "../zorder/generate_morton_code.cuh"

typedef struct Boundary
{
	Coordinate  start          = 0;
	Coordinate  end            = 0;
	MortonCode* codes          = nullptr;
	int         bdytype        = CLOSED;
	real        inlet          = C(0.0);
	char        timeseries[32] = {'\0'};
	int         timeseries_len = 0;
	real*       time_data      = nullptr;
	real*       inlet_data     = nullptr;
	int         row            = 0;
	int         direction;
	bool        is_copy_cuda        = false;

	Boundary
	(
		const char*                 input_filename,
		const SimulationParams& sim_params,
		const real&                 cell_size,
		const int                   test_case,
		const int                   direction
	)
	:
		direction(direction)
	{
		const int num_cells = read_num_cells
		(
			input_filename,
			sim_params,
			cell_size,
			test_case
		);
		
		codes = (num_cells > 0) ? new MortonCode[num_cells] : nullptr;

		read_bdy_conds
		(
			input_filename,
			sim_params,
			cell_size,
			test_case
		);
		
		read_time_series(input_filename);
	}

	Boundary(const Boundary& original) { *this = original; is_copy_cuda = true; }

	~Boundary()
	{
		if (!is_copy_cuda)
		{
			if (codes      != nullptr) delete[] codes;
			if (time_data  != nullptr) delete[] time_data;
			if (inlet_data != nullptr) delete[] inlet_data;
		}
	}

	__device__ __forceinline__
	bool bound(const Coordinate& coordinate) const { return (coordinate >= start && coordinate <= end); }

	__host__ __forceinline__
	int num_cells() const { return end - start + 1; }

	__device__ __forceinline__
	real q_src(const real& dt, const real& dx) { return inlet * dt / dx; }

	int read_num_cells
	(
		const char*                 input_filename,
		const SimulationParams& sim_params,
		const real&                 cell_size,
		const int&                  test_case
	)
	{
		if (test_case != 0) return 0;
		
		char bcifilename[32] = {'\0'};
		char buf[64]         = {'\0'};
		char str[255]        = {'\0'};
	
		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for reading boundary cells, file: %s, line: %d", __FILE__, __LINE__);
			exit(-1);
		}

		while ( strncmp(buf, "bcifile", 7) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No boundary condition file found to count cells, proceeding with default (closed) boundary conditions.\n");
				fclose(fp);

				return 0;
			}

			sscanf(str, "%s %s", buf, bcifilename);
		}
	
		fclose(fp);
		
		real upper = C(0.0);
		real lower = C(0.0);

		char bcidir  = '\0';
		char filedir = '\0';

		char bdytype_buf[8] = {'\0'};

		real origin = C(0.0);

		switch (direction)
		{
		case NORTH:
			origin = sim_params.xmin;
			bcidir = 'N';
			break;
		case EAST:
			origin = sim_params.ymin;
			bcidir = 'E';
			break;
		case SOUTH:
			origin = sim_params.xmin;
			bcidir = 'S';
			break;
		case WEST:
			origin = sim_params.ymin;
			bcidir = 'W';
			break;
		default:
			break;
		}
	
		fp = fopen(bcifilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening boundary condition file, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		while (filedir != bcidir)
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No enforced boundary cells counted for boundary %c.\n", bcidir);
				fclose(fp);

				return 0;
			}

			sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s", &filedir, &lower, &upper, bdytype_buf);
		}

		fclose(fp);

		int start = (lower - origin) / cell_size;
		int end   = (upper - origin) / cell_size;

		return end - start + 1;
	}

	void gen_bdy_morton_codes
	(
		const SimulationParams& sim_params
	)
	{
		Coordinate current = 0;
	
		switch (direction)
		{
		case SOUTH:
		{
			for (int i = 0; i < this->num_cells(); i++)
			{
				current = this->start + i;

				this->codes[i] = generate_morton_code(current, 0);
			}

			break;
		}
		case NORTH:
		{
			for (int i = 0; i < this->num_cells(); i++)
			{
				current = this->start + i;

				this->codes[i] = generate_morton_code(current, sim_params.ysz - 1);
			}

			break;
		}
		case EAST:
		{
			for (int i = 0; i < this->num_cells(); i++)
			{
				current = this->start + i;

				this->codes[i] = generate_morton_code(sim_params.xsz - 1, current);
			}

			break;
		}
		case WEST:
		{
			for (int i = 0; i < this->num_cells(); i++)
			{
				current = this->start + i;

				this->codes[i] = generate_morton_code(0, current);
			}

			break;
		}
		default:
			break;
		}
	}

	void read_bdy_conds
	(
		const char*                 input_filename,
		const SimulationParams& sim_params,
		const real&                 cell_size,
		const int&                  test_case
	)
	{
		if (test_case != 0) return;
		
		char bcifilename[32] = {'\0'};
		char buf[64]         = {'\0'};
		char str[255]        = {'\0'};
	
		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for reading boundary cells, file: %s, line: %d", __FILE__, __LINE__);
			exit(-1);
		}

		while ( strncmp(buf, "bcifile", 7) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No boundary condition file found to read, proceeding with default (closed) boundary conditions.\n");
				fclose(fp);

				return;
			}

			sscanf(str, "%s %s", buf, bcifilename);
		}
	
		fclose(fp);

		real upper = C(0.0);
		real lower = C(0.0);

		char bcidir  = '\0';
		char filedir = '\0';

		char bdytype_buf[8] = {'\0'};

		real origin = C(0.0);

		switch (direction)
		{
		case NORTH:
			origin = sim_params.xmin;
			bcidir = 'N';
			break;
		case EAST:
			origin = sim_params.ymin;
			bcidir = 'E';
			break;
		case SOUTH:
			origin = sim_params.xmin;
			bcidir = 'S';
			break;
		case WEST:
			origin = sim_params.ymin;
			bcidir = 'W';
			break;
		default:
			break;
		}
	
		fp = fopen(bcifilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening boundary condition file, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}
		
		int  bdytype        = CLOSED;
		real inlet          = C(0.0);
		char timeseries[32] = {'\0'};

		while (filedir != bcidir)
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No specifications found for boundary %c, proceeding with closed boundaries.\n", bcidir);
				fclose(fp);

				return;
			}

			sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s", &filedir, &lower, &upper, bdytype_buf);
		}

		fclose(fp);
	
		if ( !strncmp(bdytype_buf, "CLOSED", 6) )
		{
			bdytype = CLOSED;
		}
		else if ( !strncmp(bdytype_buf, "FREE", 4) )
		{
			bdytype = FREE;
		}
		else if ( !strncmp(bdytype_buf, "HFIX", 4) )
		{
			bdytype = HFIX;
			sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %" NUM_FRMT, &filedir, &lower, &upper, bdytype_buf, &inlet);
		}
		else if ( !strncmp(bdytype_buf, "HVAR", 4) )
		{
			bdytype = HVAR;
			sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %s", &filedir, &lower, &upper, bdytype_buf, timeseries);
		}
		else if ( !strncmp(bdytype_buf, "QFIX", 4) )
		{
			bdytype = QFIX;
			sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %" NUM_FRMT, &filedir, &lower, &upper, bdytype_buf, &inlet);
		}
		else if ( !strncmp(bdytype_buf, "QVAR", 4) )
		{
			bdytype = QVAR;
			sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %s", &filedir, &lower, &upper, bdytype_buf, timeseries);
		}

		this->start   = (lower - origin) / cell_size;
		this->end     = (upper - origin) / cell_size - 1;
		gen_bdy_morton_codes(sim_params);
		this->bdytype = bdytype;
		this->inlet   = inlet;
		sprintf(this->timeseries, "%s", timeseries);
	}

	void read_time_series
	(
		const char* input_filename
	)
	{
		if ( (bdytype != HVAR && bdytype != QVAR) )
		{
			time_data  = nullptr;
			inlet_data = nullptr;
			
			return;
		}

		char str[255]        = {'\0'};
		char buf[64]         = {'\0'};
		char bdyfilename[64] = {'\0'};

		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for updating boundary inlet, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		while (strncmp(buf, "bdyfile", 7) )
		{
			if (NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stderr, "Error reading time varying boundary conditions, file: %s, line: %d.\n", __FILE__, __LINE__);
				fclose(fp);
				exit(-1);
			}

			sscanf(str, "%s %s", buf, bdyfilename);
		}

		fclose(fp);

		fp = fopen(bdyfilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening time varying boundary condition file %s, file: %s, line: %d.\n", bdyfilename, __FILE__, __LINE__);
			exit(-1);
		}

		char* timeseriesptr = timeseries;

		int num_char_timeseries = 0;

		while (*(timeseriesptr + num_char_timeseries) != '\0') num_char_timeseries++;

		while ( strncmp(buf, timeseries, num_char_timeseries) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stderr, "Error reading boundary inlet time series \"%s\", file: %s, line: %d.\n", timeseries, __FILE__, __LINE__);
				fclose(fp);
				exit(-1);
			}

			sscanf(str, "%s", buf);
		}

		int num_rows_timeseries = 0;

		fgets(str, sizeof(str), fp);

		sscanf(str, "%d %s", &num_rows_timeseries, buf);

		int time_multiplier = ( !strncmp(buf, "seconds", 7) ) ? 1 : ( !strncmp(buf, "minutes", 7) ) ? 60 : 3600;

		timeseries_len = num_rows_timeseries;

		if (num_rows_timeseries == 0)
		{
			fprintf(stderr, "Zero entries for timeseries: \"%s\", file: %s, line: %d.\n", timeseries, __FILE__, __LINE__);
			fclose(fp);
			exit(-1);
		}

		time_data  = (num_rows_timeseries > 0) ? new real[num_rows_timeseries] : nullptr;
		inlet_data = (num_rows_timeseries > 0) ? new real[num_rows_timeseries] : nullptr;

		for (int i = 0; i < num_rows_timeseries; i++)
		{
			fgets(str, sizeof(str), fp);

			sscanf(str, "%" NUM_FRMT " %" NUM_FRMT, &inlet_data[i], &time_data[i]);

			time_data[i] *= time_multiplier;
		}

		fclose(fp);
	}

	void update_inlet
	(
		const real& current_time
	)
	{
		if ( (bdytype != HVAR && bdytype != QVAR) ) return;

		if ( (row - 1) < timeseries_len )
		{
			real t_1 = time_data[row];
			real t_2 = time_data[row + 1];

			if (current_time > t_2)
			{
				row++; 
				
				t_1 = time_data[row];
				t_2 = time_data[row + 1];
			}

			real inlet_1 = inlet_data[row];
			real inlet_2 = inlet_data[row + 1];

			inlet = inlet_1 + (inlet_2 - inlet_1) / (t_2 - t_1) * (current_time - t_1);
		}
		else
		{
			inlet = inlet_data[timeseries_len - 1];
		}
	}

} Boundary;
#pragma once

#include "../classes/ScaleChildren.h"

typedef struct ChildScaleCoefficients
{
	ScaleChildren eta;
	ScaleChildren qx;
	ScaleChildren qy;
	ScaleChildren z;

} ChildScaleCoefficients;
#pragma once

#include "../classes/ScaleChildren.h"

typedef struct ChildScaleCoeffsHW
{
	ScaleChildrenHW eta;
	ScaleChildrenHW qx;
	ScaleChildrenHW qy;
	ScaleChildrenHW z;

} ChildScaleCoeffsHW;

typedef struct ChildScaleCoeffsMW
{
	ScaleChildrenMW eta;
	ScaleChildrenMW qx;
	ScaleChildrenMW qy;
	ScaleChildrenMW z;

} ChildScaleCoeffsMW;
target_sources(
	    gpu-mwdg2
		PRIVATE
		Details.cu
		ScaleCoefficients.cu
		SimulationParams.cpp
		SolverParams.cu
		SubDetails.cu
	)
#pragma once

#include "../utilities/cuda_utils.cuh"

typedef struct CompactionFlags
{
	bool* north_east;
	bool* south_west;
	bool  is_copy_cuda = false;

	CompactionFlags(const int& num_finest_elems)
	{
		size_t bytes = sizeof(bool) * num_finest_elems;

		north_east = (bool*)malloc_device(bytes);
		south_west = (bool*)malloc_device(bytes);
	}

	CompactionFlags(const CompactionFlags& original) { *this = original; is_copy_cuda = true; }

	~CompactionFlags()
	{
		if (!is_copy_cuda)
		{
			CHECK_CUDA_ERROR( free_device(north_east) );
			CHECK_CUDA_ERROR( free_device(south_west) );
		}
	}

} CompactionFlags;
#pragma once

#include "../types/real.h"

typedef struct Depths1D
{
	real hl;
	real hr;

	Depths1D(const int& test_case)
	{
		switch (test_case)
		{
		case 1: case 2: // wet c property
			this->hl = C(6.0);
			this->hr = C(6.0);
			break;
		case 3: case 4: // wet/dry c property
			this->hl = C(2.0);
			this->hr = C(2.0);
			break;
		case 5: case 6:   // wet dam break
		case 11: case 12: // wet overtopping
			this->hl = C(6.0);
			this->hr = C(2.0);
			break;
		case 7:  case 8:  // dry dam break
		case 9:  case 10: // dry dam break with fric
		case 13: case 14: // dry overtopping
			this->hl = C(6.0);
			this->hr = C(0.0);
			break;
		case 17: // three humps
			this->hl = C(2.0);
			this->hr = C(0.0);
			break;
		default:
			break;
		}
	}

} Depths1D;

/*
example of a designated initialiser
requires /std:c++latest
the (slight) advantage is bcs will be initialised upon construction
there is never a time when bcs is (partially) uninitialised

Depths1D bcs = {
	.hl = C(2.0),
	.hr = C(0.0),
	.ql = C(0.0),
	.qr = C(0.0),
	.reflectUp = C(0.0),
	.reflectDown = C(0.0),
	.hImposedUp = C(0.0),
	.qxImposedUp = C(0.0),
	.hImposedDown = C(0.0),
	.qxImposedDown = C(0.0)
};
*/
#pragma once

#include "../classes/SubDetail.h"
#include "../classes/Maxes.h"

typedef struct DetailHW
{
	SubDetailHW eta;
	SubDetailHW qx;
	SubDetailHW qy;
	SubDetailHW z;

	__device__ __forceinline__
	real get_norm_detail(Maxes maxes)
	{
		real norm_detail = C(0.0);

		real eta_norm = eta.get_max() / maxes.eta;
		real qx_norm  = qx.get_max()  / maxes.qx;
		real qy_norm  = qy.get_max()  / maxes.qy;
		real z_norm   = z.get_max()   / maxes.z;

		norm_detail = max(eta_norm, qx_norm);
		norm_detail = max(qy_norm,  norm_detail);
		norm_detail = max(z_norm,   norm_detail);

		return norm_detail;
	}

} DetailHW;

typedef struct DetailMW
{
	SubDetailMW eta;
	SubDetailMW qx;
	SubDetailMW qy;
	SubDetailMW z;

	__device__ __forceinline__
	real get_norm_detail(Maxes maxes)
	{
		real norm_detail = C(0.0);

		real eta_norm = eta.get_max() / maxes.eta;
		real qx_norm  =  qx.get_max() / maxes.qx;
		real qy_norm  =  qy.get_max() / maxes.qy;
		real z_norm   =   z.get_max() / maxes.z;

		norm_detail = max(eta_norm, qx_norm);
		norm_detail = max(qy_norm,  norm_detail);
		norm_detail = max(z_norm,   norm_detail);

		return norm_detail;
	}

} DetailMW;
#pragma once

#include "cuda_runtime.h"

typedef struct DetailChildren
{
	bool detail_0;
	bool detail_1;
	bool detail_2;
	bool detail_3;

	__device__ __forceinline__
	bool has_sig_detail()
	{
		bool is_sig = (detail_0 || detail_1 || detail_2 || detail_3);
		
		return is_sig;
	}

} DetailChildren;
#include "Details.h"

Details::Details
(
	const SolverParams& solver_params
)
:
	eta0(solver_params.L - 1),
	qx0 (solver_params.L - 1),
	qy0 (solver_params.L - 1),
	z0  (solver_params.L - 1),

	eta1x( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),
	qx1x ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),
	qy1x ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),
	z1x  ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),
	
	eta1y( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),
	qx1y ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),
	qy1y ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),
	z1y  ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1 ),

	solver_type(solver_params.solver_type)
{}

Details::Details
(
	const SolverParams& solver_params,
	const char*         dirroot,
	const char*         prefix
)
:
	eta0( solver_params.L - 1, dirroot, prefix, (solver_params.solver_type == MWDG2) ? "eta0-mw" : "eta0-hw"),
	qx0 ( solver_params.L - 1, dirroot, prefix, (solver_params.solver_type == MWDG2) ? "qx0-mw"  : "qx0-hw"),
	qy0 ( solver_params.L - 1, dirroot, prefix, (solver_params.solver_type == MWDG2) ? "qy0-mw"  : "qy0-hw"),
	z0  ( solver_params.L - 1, dirroot, prefix, (solver_params.solver_type == MWDG2) ? "z0-mw"   : "z0-hw"),
	
	eta1x( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "eta1x-mw"),
	qx1x ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "qx1x-mw" ),
	qy1x ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "qy1x-mw" ),
	z1x  ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "z1x-mw"  ),

	eta1y( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "eta1y-mw"),
	qx1y ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "qx1y-mw" ),
	qy1y ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "qy1y-mw" ),
	z1y  ( (solver_params.solver_type == MWDG2) ? solver_params.L - 1 : -1, dirroot, prefix, "z1y-mw"  ),
	
	solver_type(solver_params.solver_type)
{}

void Details::write_to_file
(
	const char* dirroot,
	const char* prefix
)
{
	if (this->solver_type == HWFV1)
	{
		eta0.write_to_file(dirroot, prefix, "eta0-hw");
		qx0.write_to_file(dirroot,  prefix, "qx0-hw");
		qy0.write_to_file(dirroot,  prefix, "qy0-hw");
		z0.write_to_file(dirroot,   prefix, "z0-hw");
	}
	else if (this->solver_type == MWDG2)
	{
		eta0.write_to_file(dirroot, prefix, "eta0-mw");
		qx0.write_to_file(dirroot,  prefix, "qx0-mw");
		qy0.write_to_file(dirroot,  prefix, "qy0-mw");
		z0.write_to_file(dirroot,   prefix, "z0-mw");

		eta1x.write_to_file(dirroot, prefix, "eta1x-mw");
		qx1x.write_to_file(dirroot,  prefix, "qx1x-mw");
		qy1x.write_to_file(dirroot,  prefix, "qy1x-mw");
		z1x.write_to_file(dirroot,   prefix, "z1x-mw");

		eta1y.write_to_file(dirroot, prefix, "eta1y-mw");
		qx1y.write_to_file(dirroot,  prefix, "qx1y-mw");
		qy1y.write_to_file(dirroot,  prefix, "qy1y-mw");
		z1y.write_to_file(dirroot,   prefix, "z1y-mw");
	}
}

real Details::verify
(
	const char* dirroot,
	const char* prefix
)
{
	if (this->solver_type == HWFV1)
	{
		const real error_eta0 = this->eta0.verify(dirroot, prefix, "eta0-hw");
		const real error_qx0  = this->qx0.verify(dirroot, prefix, "qx0-hw");
		const real error_qy0  = this->qy0.verify(dirroot, prefix, "qy0-hw");
		const real error_z0   = this->z0.verify(dirroot, prefix, "z0-hw");

		// mean
		// return (error_eta0 + error_qx0 + error_qy0 + error_z0) / C(4.0);

		// max
		return std::max({error_eta0, error_qx0, error_qy0, error_z0});
	}
	else if (this->solver_type == MWDG2)
	{
		const real error_eta0 = this->eta0.verify(dirroot, prefix, "eta0-mw");
		const real error_qx0  = this->qx0.verify(dirroot, prefix, "qx0-mw");
		const real error_qy0  = this->qy0.verify(dirroot, prefix, "qy0-mw");
		const real error_z0   = this->z0.verify(dirroot, prefix, "z0-mw");

		const real error_eta1x = this->eta1x.verify(dirroot, prefix, "eta1x-mw");
		const real error_qx1x  = this->qx1x.verify(dirroot, prefix, "qx1x-mw");
		const real error_qy1x  = this->qy1x.verify(dirroot, prefix, "qy1x-mw");
		const real error_z1x   = this->z1x.verify(dirroot, prefix, "z1x-mw");

		const real error_eta1y = this->eta1y.verify(dirroot, prefix, "eta1y-mw");
		const real error_qx1y  = this->qx1y.verify(dirroot, prefix, "qx1y-mw");
		const real error_qy1y  = this->qy1y.verify(dirroot, prefix, "qy1y-mw");
		const real error_z1y   = this->z1y.verify(dirroot, prefix, "z1y-mw");

		// mean
		// const real error_0  = (error_eta0  + error_qx0  + error_qy0  + error_z0 ) / C(4.0);
		// const real error_1x = (error_eta1x + error_qx1x + error_qy1x + error_z1x) / C(4.0);
		// const real error_1y = (error_eta1y + error_qx1y + error_qy1y + error_z1y) / C(4.0);
		// const real error = error_0 + error_1x + error_1y) / C(3.0);

		// max
		const real error = std::max({error_eta0,  error_qx0,  error_qy0,  error_z0,
                                     error_eta1x, error_qx1x, error_qy1x, error_z1x,
                                     error_eta1y, error_qx1y, error_qy1y, error_z1y});

		return error;
	}
	else
	{
		return C(-999.0);
	}
}
#pragma once

#include "SubDetails.h"
#include "../types/SolverTypes.h"

class Details
{
public:
	Details
	(
		const SolverParams& solver_params
	);

	Details
	(
		const SolverParams& solver_params,
		const char*         dirroot,
		const char*         prefix
	);

	void write_to_file
	(
		const char* dirroot,
		const char* prefix
	);

	real verify
	(
		const char* dirroot,
		const char* prefix
	);

	SubDetails eta0;
	SubDetails qx0;
	SubDetails qy0;
	SubDetails z0;

	SubDetails eta1x;
	SubDetails qx1x;
	SubDetails qy1x;
	SubDetails z1x;

	SubDetails eta1y;
	SubDetails qx1y;
	SubDetails qy1y;
	SubDetails z1y;

	int solver_type = 0;
};
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../types/real.h"

typedef struct FinestGrid
{
    real* h;
    real* qx;
    real* qy;
    real* z;
	
	bool is_copy_cuda = false;
	
	FinestGrid(const int& num_finest_elems)
	{
	    size_t bytes = sizeof(real) * num_finest_elems;
		
		h  = (real*)malloc_pinned(bytes);
		qx = (real*)malloc_pinned(bytes);
		qy = (real*)malloc_pinned(bytes);
		z  = (real*)malloc_pinned(bytes);
	}
	
	FinestGrid(const FinestGrid& original) { *this = original; is_copy_cuda = true; }
	
	~FinestGrid()
	{
	    if (!is_copy_cuda)
		{
		    CHECK_CUDA_ERROR( free_pinned(h)  );
		    CHECK_CUDA_ERROR( free_pinned(qx) );
		    CHECK_CUDA_ERROR( free_pinned(qy) );
		    CHECK_CUDA_ERROR( free_pinned(z)  );
		}
	}

} FinestGrid;
#pragma once

#include "../classes/FlowVector.h"
#include "../classes/PlanarCoefficients.h"
#include "../classes/LegendreBasis.h"
#include "../operators/eval_loc_face_val_dg2.cuh"

typedef struct FlowCoeffs
{
	PlanarCoefficients h;
	PlanarCoefficients qx;
	PlanarCoefficients qy;

	__host__ __device__
	FlowVector local_face_val(const LegendreBasis& basis)
	{
		return
		{
			eval_loc_face_val_dg2(h,  basis),
			eval_loc_face_val_dg2(qx, basis),
			eval_loc_face_val_dg2(qy, basis)
		};
	}
	
	__device__
	void set_0
	(
		const FlowVector& v
	)
	{
		h._0  = v.h;
		qx._0 = v.qx;
		qy._0 = v.qy;
	}

	__device__
	void set_1x
	(
		const FlowVector& v
	)
	{
		h._1x  = v.h;
		qx._1x = v.qx;
		qy._1x = v.qy;
	}

	__device__
	void set_1y
	(
		const FlowVector& v
	)
	{
		h._1y  = v.h;
		qx._1y = v.qx;
		qy._1y = v.qy;
	}

	__device__
	inline FlowCoeffs operator=
	(
		const FlowCoeffs& rhs
	)
	{
		h  = rhs.h;
		qx = rhs.qx;
		qy = rhs.qy;
		
		return *this;
	}
	
	__device__
	inline FlowCoeffs operator+=
	(
		const FlowCoeffs& rhs
	)
	{
		h  += rhs.h;
		qx += rhs.qx;
		qy += rhs.qy;

		return *this;
	}

} FlowCoeffs;

__device__
inline FlowCoeffs operator*
(
	const real& lhs,
	const FlowCoeffs& rhs
)
{
	return { lhs * rhs.h, lhs * rhs.qx, lhs * rhs.qy };
}

__device__
inline FlowCoeffs operator+
(
	const FlowCoeffs& lhs,
	const FlowCoeffs& rhs
)
{
	return { lhs.h + rhs.h, lhs.qx + rhs.qx,  lhs.qy + rhs.qy };
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

typedef struct FlowVector
{
    real h;
    real qx;
    real qy;

    __device__ __forceinline__
    real get_speed
    (
        const real& q,
        const real tol_h
    )
    {
        return (h < tol_h) ? 0 : q / h;
    }

    __device__ __forceinline__
    real calc_h_star
    (
        const real& z,
        const real& z_intermediate
    )
    {
        real eta = h + z;

        return max(C(0.0), eta - z_intermediate);
    }

    __device__ __forceinline__
    FlowVector get_star
    (
        const real& z,
        const real& z_intermediate,
        const real tol_h
    )
    {
        real h_star  = calc_h_star(z, z_intermediate);
        real qx_star = h_star * get_speed(qx, tol_h);
        real qy_star = h_star * get_speed(qy, tol_h);

        return { h_star, qx_star, qy_star };
    }

    __device__ __forceinline__
    FlowVector phys_flux_x
    (
        const real tol_h,
        const real& g
    )
    {
        if (h < tol_h)
        {
            return { 0, 0, 0 };
        }
        else
        {
            return { qx, qx * qx / h + g * h * h / C(2.0), qx * qy / h };
        }
    }

    __device__ __forceinline__
    FlowVector phys_flux_y
    (
        const real tol_h,
        const real& g
    )
    {
        if (h < tol_h)
        {
            return { 0, 0, 0 };
        }
        else
        {
            return { qy, qx * qy / h, qy * qy / h + g * h * h / C(2.0) };
        }
    }

} FlowVector;

__host__ __device__
inline FlowVector operator+
(
    const FlowVector& lhs,
    const FlowVector& rhs
)
{
    return { lhs.h + rhs.h, lhs.qx + rhs.qx, lhs.qy + rhs.qy };
}

__host__ __device__
inline FlowVector operator-
(
    const FlowVector& lhs,
    const FlowVector& rhs
)
{
    return { lhs.h - rhs.h, lhs.qx - rhs.qx, lhs.qy - rhs.qy };
}

__host__ __device__
inline FlowVector operator*
(
    const real& lhs,
    const FlowVector& rhs
)
{
    return { lhs * rhs.h, lhs * rhs.qx, lhs * rhs.qy };
}

__host__ __device__
inline FlowVector operator/
(
    const FlowVector& lhs,
    const real& rhs
)
{
    return { lhs.h / rhs, lhs.qx / rhs, lhs.qy / rhs };
}
#pragma once

#include "../types/real.h"

typedef struct LegendreBasis
{
	real _0;
	real _1x;
	real _1y;

} LegendreBasis;
#pragma once

#include "../types/real.h"

typedef struct Maxes
{
	real eta;
	real h;
	real qx;
	real qy;
	real z;

} Maxes;
#pragma once

#include "../classes/AssembledSolution.h"

typedef struct Neighbours
{
    AssembledSolution north;
    AssembledSolution east;
    AssembledSolution south;
    AssembledSolution west;

    Neighbours(const int& num_finest_elems, const int& solver_type)
    :
        north(num_finest_elems, solver_type),
        east (num_finest_elems, solver_type),
        south(num_finest_elems, solver_type),
        west (num_finest_elems, solver_type)
    {}

} Neighbours;
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../types/real.h"

typedef struct NodalValues
{
	real* h;
	real* qx;
	real* qy;
	real* z;
	bool  is_copy_cuda = false;

	NodalValues(const int& interface_dim)
	{
		size_t bytes = sizeof(real) * interface_dim * interface_dim;

		h  = (real*)malloc_device(bytes);
		qx = (real*)malloc_device(bytes);
		qy = (real*)malloc_device(bytes);
		z  = (real*)malloc_device(bytes);
	}

	NodalValues(const NodalValues& original) { *this = original; is_copy_cuda = true; }

	~NodalValues()
	{
		if (!is_copy_cuda)
		{
			CHECK_CUDA_ERROR( free_device(h)  );
			CHECK_CUDA_ERROR( free_device(qx) );
			CHECK_CUDA_ERROR( free_device(qy) );
			CHECK_CUDA_ERROR( free_device(z)  );
		}
	}

} NodalValues;
#pragma once

#include "../types/real.h"

typedef struct ParentScaleCoefficient
{
	real eta;
	real qx;
	real qy;
	real z;

} ParentScaleCoefficient;
#pragma once

#include "../types/real.h"

typedef struct ParentScaleCoeffsHW
{
	real eta;
	real qx;
	real qy;
	real z;

} ParentScaleCoeffsHW;

typedef struct ParentScaleCoeffsMW
{
	ParentScaleCoeffsHW _0;
	ParentScaleCoeffsHW _1x;
	ParentScaleCoeffsHW _1y;

} ParentScaleCoeffsMW;
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

typedef struct PlanarCoefficients
{
	real _0;
	real _1x;
	real _1y;

	__device__
	inline PlanarCoefficients operator=
	(
		const PlanarCoefficients& rhs
	)
	{
		_0  = rhs._0;
		_1x = rhs._1x;
		_1y = rhs._1y;

		return *this;
	}

	__device__
	inline PlanarCoefficients operator+=
	(
		const PlanarCoefficients& rhs
	)
	{
		_0  += rhs._0;
		_1x += rhs._1x;
		_1y += rhs._1y;

		return *this;
	}

} PlanarCoefficients;

__device__
inline PlanarCoefficients operator*
(
	const real& lhs,
	const PlanarCoefficients& rhs
)
{
	return { lhs * rhs._0, lhs * rhs._1x, lhs * rhs._1y };
}

__device__
inline PlanarCoefficients operator+
(
	const PlanarCoefficients& lhs,
	const PlanarCoefficients& rhs
)
{
	return { lhs._0 + rhs._0,  lhs._1x + rhs._1x,  lhs._1y + rhs._1y };
}
#pragma once

#include "../input/read_keyword_bool.h"
#include "../input/read_keyword_str.h"

typedef struct PlottingParams
{
	bool vtk           = false;
	bool c_prop        = false;
	bool raster_out    = false;
	bool voutput_stage = false;
	bool voutput       = false;
	bool qoutput       = false;
	bool elevoff       = false;
	bool depthoff      = false;
	bool cumulative    = false;
	char dirroot[128]  = {'\0'};
	char resroot[128]  = {'\0'};

	PlottingParams
	(
		const char* input_filename
	)
	{
		this->vtk           = read_keyword_bool(input_filename, "vtk");
		this->c_prop        = read_keyword_bool(input_filename, "c_prop");
		this->raster_out    = read_keyword_bool(input_filename, "raster_out");
		this->voutput_stage = read_keyword_bool(input_filename, "voutput_stage");
		this->voutput       = read_keyword_bool(input_filename, "voutput");
		this->qoutput       = read_keyword_bool(input_filename, "qoutput");
		this->elevoff       = read_keyword_bool(input_filename, "elevoff");
		this->depthoff      = read_keyword_bool(input_filename, "depthoff");
		this->cumulative    = read_keyword_bool(input_filename, "cumulative");
		
		read_keyword_str(input_filename, "resroot", this->resroot);
		read_keyword_str(input_filename, "dirroot", this->dirroot);

		// if no result filename prefix is specified
		if (this->resroot[0] == '\0')
		{
			// default prefix is "res"
			sprintf(this->resroot, "%s", "res");
		}
		
		// if no results folder name is specified
		if (this->dirroot[0] == '\0')
		{
			// results folder name is "res"
			sprintf(this->dirroot, "%s", "res");
		}

		make_output_directory();
	}

	void make_output_directory()
	{
		char sys_cmd_str_buf[255] = {'\0'};
		sprintf(sys_cmd_str_buf, "%s %s", "mkdir", this->dirroot);
		system(sys_cmd_str_buf);
	}

} PlottingParams;
#pragma once

#include "../types/real.h"

typedef struct Points
{
	real ll_x;
	real ll_y;
	real ul_x;
	real ul_y;
	real lr_x;
	real lr_y;
	real ur_x;
	real ur_y;
	
} Points;
#pragma once

#include "../utilities/cuda_utils.cuh"

#include <cstdio>
#include <cstdlib>
#include <cstring>

#include "../types/MortonCode.h"
#include "../types/InletTypes.h"
#include "../classes/SimulationParams.h"

#include "../zorder/generate_morton_code.cuh"

typedef struct PointSources
{
	MortonCode* h_codes         = nullptr;
	MortonCode* d_codes         = nullptr;
	real*       h_srcs          = nullptr;
	real*       d_srcs          = nullptr;
	int*        h_src_types     = nullptr;
	int*        d_src_types     = nullptr;
	char*       timeseries      = nullptr;
	int*        timeseries_lens = nullptr;
	real**      all_time_data   = nullptr;
	real**      all_src_data    = nullptr;
	int*        rows            = nullptr;
	int         num_srcs        = 0;
	bool        is_copy_cuda         = false;

	PointSources
	(
		const char*                 input_filename,
		const SimulationParams& sim_params,
		const real&                 cell_size,
		const int&                  test_case,
		const real&                 dt
	)
	{
		if (test_case != 0)
		{
			fprintf(stdout, "Running built-in test case without any point sources.\n");
			return;
		}
		
		num_srcs = read_num_point_srcs(input_filename);
		
		size_t bytes_codes     = sizeof(MortonCode) * num_srcs;
		size_t bytes_srcs      = sizeof(real)       * num_srcs;
		size_t bytes_src_types = sizeof(int)        * num_srcs;

		h_codes         = (num_srcs > 0) ? new MortonCode[num_srcs]                : nullptr;
		d_codes         = (num_srcs > 0) ? (MortonCode*)malloc_device(bytes_codes) : nullptr;
		h_srcs          = (num_srcs > 0) ? new real[num_srcs]()                    : nullptr;
		d_srcs          = (num_srcs > 0) ? (real*)malloc_device(bytes_srcs)        : nullptr;
		h_src_types     = (num_srcs > 0) ? new int[num_srcs]                       : nullptr;
		d_src_types     = (num_srcs > 0) ? (int*)malloc_device(bytes_src_types)    : nullptr;
		timeseries      = (num_srcs > 0) ? new char[num_srcs * 32]()               : nullptr;
		timeseries_lens = (num_srcs > 0) ? new int[num_srcs]()                     : nullptr;
		all_time_data   = (num_srcs > 0) ? new real*[num_srcs]()                   : nullptr;
		all_src_data    = (num_srcs > 0) ? new real*[num_srcs]()                   : nullptr;
		rows            = (num_srcs > 0) ? new int[num_srcs]()                     : nullptr;

		read_point_srcs
		(
			input_filename,
			num_srcs,
			sim_params,
			cell_size
		);

		read_all_timeseries(input_filename);

		update_all_srcs(dt);
	}

	PointSources(const PointSources& original) { *this = original; is_copy_cuda = true; }

	~PointSources()
	{
		if (!is_copy_cuda)
		{
			if (h_codes         != nullptr) delete[] h_codes;
			if (d_codes         != nullptr) CHECK_CUDA_ERROR( free_device(d_codes) );
			if (h_src_types     != nullptr) delete[] h_src_types;
			if (d_src_types     != nullptr) CHECK_CUDA_ERROR( free_device(d_src_types) );
			if (h_srcs          != nullptr) delete[] h_srcs;
			if (d_srcs          != nullptr) CHECK_CUDA_ERROR( free_device(d_srcs) );
			if (timeseries      != nullptr) delete[] timeseries;
			if (timeseries_lens != nullptr) delete[] timeseries_lens;
			
			if (all_time_data != nullptr)
			{
				for (int i = 0; i < num_srcs; i++)
				{
					if (all_time_data[i] != nullptr)
					{
						delete[] all_time_data[i];
					}
				}
			}

			if (all_time_data != nullptr) delete[]all_time_data;

			if (all_src_data != nullptr)
			{
				for (int i = 0; i < num_srcs; i++)
				{
					if (all_src_data[i] != nullptr)
					{
						delete[] all_src_data[i];
					}
				}
			}

			if (all_src_data != nullptr) delete[] all_src_data;

			if (rows != nullptr) delete[] rows;

		}
	}
	
	__device__ __forceinline__
	real q_src(const real& dt, const real& dx, const int idx)
	{
		return this->d_srcs[idx] * dt / dx;
	}

	int read_num_point_srcs
	(
		const char* input_filename
	)
	{
		char bcifilename[32] = {'\0'};
		char buf[128]        = {'\0'};
		char str[255]        = {'\0'};

		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for counting numer of point sources, file: %s, line: %d", __FILE__, __LINE__);
			exit(-1);
		}

		while ( strncmp(buf, "bcifile", 7) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No point source file found, proceeding without counting number of point sources.\n");
				fclose(fp);

				return 0;
			}

			sscanf(str, "%s %s", buf, bcifilename);
		}

		fclose(fp);

		fp = fopen(bcifilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening point source file for counting number of point sources, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		char point    = '\0';
		int  num_srcs = 0;

		while ( !( NULL == fgets(str, sizeof(str), fp) ) )
		{
			sscanf(str, "%c", &point);

			if (point == 'P') num_srcs++;
		}

		if (num_srcs == 0)
		{
			fprintf(stdout, "No point sources counted in boundary condition file, proceeding with zero point sources.\n");
			fclose(fp);

			return 0;
		}
	
		fclose(fp);

		return num_srcs;
	}

	void read_point_srcs
	(
		const char*                 input_filename,
		const int&                  num_srcs,
		const SimulationParams& sim_params,
		const real&                 cell_size
	)
	{
		if (num_srcs == 0) return;
		
		char bcifilename[32] = {'\0'};
		char buf[128]        = {'\0'};
		char str[255]        = {'\0'};

		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for reading point sources, file: %s, line: %d", __FILE__, __LINE__);
			exit(-1);
		}

		while ( strncmp(buf, "bcifile", 7) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No point source file found, proceeding with no point sources.\n");
				fclose(fp);

				return;
			}

			sscanf(str, "%s %s", buf, bcifilename);
		}

		fclose(fp);

		fp = fopen(bcifilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening point source file, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		real x_stage = C(0.0);
		real y_stage = C(0.0);
	
		Coordinate x = 0;
		Coordinate y = 0;

		char point             = '\0';
		char inlet_type_buf[8] = {'\0'};
		int  srcs_counted      = 0;

		while (srcs_counted < num_srcs)
		{
			fgets(str, sizeof(str), fp);

			sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s", &point, &x_stage, &y_stage, inlet_type_buf);

			if (point == 'P')
			{
				x = (x_stage - sim_params.xmin) / cell_size;
				y = (y_stage - sim_params.ymin) / cell_size;

				h_codes[srcs_counted] = generate_morton_code(x, y);

				if ( !strncmp(inlet_type_buf, "HFIX", 4) )
				{
					h_src_types[srcs_counted] = HFIX;
					sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %" NUM_FRMT, &point, &x_stage, &y_stage, inlet_type_buf, &h_srcs[srcs_counted]);
				}
				else if ( !strncmp(inlet_type_buf, "HVAR", 4) )
				{
					h_src_types[srcs_counted] = HVAR;
					sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %s", &point, &x_stage, &y_stage, inlet_type_buf, &timeseries[srcs_counted * 32]);
				}
				else if ( !strncmp(inlet_type_buf, "QFIX", 4) )
				{
					h_src_types[srcs_counted] = QFIX;
					sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %" NUM_FRMT, &point, &x_stage, &y_stage, inlet_type_buf, &h_srcs[srcs_counted]);
				}
				else if ( !strncmp(inlet_type_buf, "QVAR", 4) )
				{
					h_src_types[srcs_counted] = QVAR;
					sscanf(str, "%c %" NUM_FRMT " %" NUM_FRMT " %s %s", &point, &x_stage, &y_stage, inlet_type_buf, &timeseries[srcs_counted * 32]);
				}

				srcs_counted++;
			}
		}

		fclose(fp);
	
		size_t bytes_codes     = sizeof(MortonCode) * num_srcs;
		size_t bytes_srcs      = sizeof(real)       * num_srcs;
		size_t bytes_src_types = sizeof(int)        * num_srcs;

		copy_cuda(d_codes,     h_codes,     bytes_codes);
		copy_cuda(d_srcs,      h_srcs,      bytes_srcs);
		copy_cuda(d_src_types, h_src_types, bytes_src_types);
	}

	void read_timeseries
	(
		const char* input_filename,
		const int&  src_type,
		const char* timeseries,
		int&        timeseries_len,
		real*&      time_data,
		real*&      src_data
	)
	{
		if ( (src_type != HVAR && src_type != QVAR) )
		{
			time_data = nullptr;
			src_data  = nullptr;
			
			return;
		}

		char bdyfilename[64] = {'\0'};
		char str[255]        = {'\0'};
		char buf[128]        = {'\0'};

		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for updating boundary inlet, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		while (strncmp(buf, "bdyfile", 7) )
		{
			if (NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stderr, "Error reading time varying boundary conditions, file: %s, line: %d.\n", __FILE__, __LINE__);
				fclose(fp);
				exit(-1);
			}

			sscanf(str, "%s %s", buf, bdyfilename);
		}

		fclose(fp);

		fp = fopen(bdyfilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening bdyfile %s, file: %s, line: %d.\n", bdyfilename, __FILE__, __LINE__);
			exit(-1);
		}

		int num_char_timeseries = 0;

		while ( *(timeseries + num_char_timeseries) != '\0' ) num_char_timeseries++;

		while ( strncmp(buf, timeseries, num_char_timeseries) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stderr, "Error reading point source time series \"%s\", file: %s, line: %d.\n", timeseries, __FILE__, __LINE__);
				fclose(fp);
				exit(-1);
			}

			sscanf(str, "%s", buf);
		}

		int num_rows_timeseries = 0;

		fgets(str, sizeof(str), fp);

		sscanf(str, "%d %s", &num_rows_timeseries, buf);

		int time_multiplier = ( !strncmp(buf, "seconds", 7) ) ? 1 : ( !strncmp(buf, "minutes", 7) ) ? 60 : 3600;

		timeseries_len = num_rows_timeseries;

		if (num_rows_timeseries == 0)
		{
			fprintf(stderr, "Zero entries for timeseries: \"%s\", file: %s, line: %d.\n", timeseries, __FILE__, __LINE__);
			fclose(fp);
			exit(-1);
		}

		time_data = (num_rows_timeseries > 0) ? new real[num_rows_timeseries] : nullptr;
		src_data  = (num_rows_timeseries > 0) ? new real[num_rows_timeseries] : nullptr;

		real src  = C(0.0);
		real time = C(0.0);

		for (int i = 0; i < num_rows_timeseries; i++)
		{
			fgets(str, sizeof(str), fp);

			sscanf( str, "%" NUM_FRMT " %" NUM_FRMT, &src, &time );

			src_data[i]  = src;
			time_data[i] = time * time_multiplier;
		}

		fclose(fp);
	}

	void read_all_timeseries(const char* input_filename)
	{
		for (int i = 0; i < this->num_srcs; i++)
		{
			read_timeseries
			(
				input_filename, 
				this->h_src_types[i],
			    &this->timeseries[i * 32],
			    this->timeseries_lens[i],
			    this->all_time_data[i],
			    this->all_src_data[i]
			);
		}
	}

	void update_src
	(
		const real& current_time,
		const int&  src_type,
		real&       h_src,
		int&        row,
		const int&  timeseries_len,
		real*       time_data,
		real*       src_data
	)
	{
		if ( (src_type != HVAR && src_type != QVAR) ) return;

		if ( (row - 1) < timeseries_len )
		{
			real t_1 = time_data[row];
			real t_2 = time_data[row + 1];

			if (current_time > t_2)
			{
				row++; 
				
				t_1 = time_data[row];
				t_2 = time_data[row + 1];
			}

			real src_1 = src_data[row];
			real src_2 = src_data[row + 1];

			h_src = src_1 + (src_2 - src_1) / (t_2 - t_1) * (current_time - t_1);
		}
		else
		{
			h_src = src_data[timeseries_len - 1];
		}
	}

	void update_all_srcs(const real& current_time)
	{
		for (int i = 0; i < this->num_srcs; i++)
		{
			update_src
			(
				current_time,
				this->h_src_types[i],
			    this->h_srcs[i],
			    this->rows[i],
			    this->timeseries_lens[i],
			    this->all_time_data[i],
			    this->all_src_data[i]
			);
;		}

		size_t bytes_srcs = sizeof(real) * num_srcs;

		copy_cuda(d_srcs, h_srcs, bytes_srcs);
	}

} PointSources;
#pragma once

#include "../types/real.h"

typedef struct SaveInterval
{
	real interval;
	int  count;

	SaveInterval
    (
        const char* input_filename,
        const char* interval_type
    )
    {
        real interval = C(0.0);
    
        char str[255]{'\0'};
        char buf[64]{'\0'};
        
        int num_char_interval_id = 0;
    
        while ( *(interval_type + num_char_interval_id) != '\0' ) num_char_interval_id++;
        
        FILE* fp = fopen(input_filename, "r");
    
        if (NULL == fp)
        {
            fprintf(stderr, "Error opening input file for setting save interval: %s, file: %s, line: %d.\n", interval_type, __FILE__, __LINE__);
            exit(-1);
        }
    
        while ( strncmp(buf, interval_type, num_char_interval_id) )
        {
            if ( NULL == fgets(str, sizeof(str), fp) )
            {
                fprintf(stdout, "No %s found in input file, not saving any associated data.\n", interval_type);
                fclose(fp);
    
                this->interval = C(9999.0);
                this->count    = 9999;
                return;
            }
    
            sscanf(str, "%s %" NUM_FRMT, buf, &interval);
        }
    
        this->interval = interval;
        this->count    = 0;
    }
    
    bool save(real current_time)
	{
		if (current_time >= interval * count)
		{
			count++;
			return true;
		}
		
		return false;
	}

} SaveInterval;
#pragma once

#include "../types/real.h"

typedef struct ScaleChildrenHW
{
	real child_0;
	real child_1;
	real child_2;
	real child_3;

} ScaleChildrenHW;

typedef struct ScaleChildrenMW
{
	ScaleChildrenHW _0;
	ScaleChildrenHW _1x;
	ScaleChildrenHW _1y;

} ScaleChildrenMW;
#include "ScaleCoefficients.h"

ScaleCoefficients::ScaleCoefficients
(
    const SolverParams& solver_params
)
    : levels(solver_params.L), solver_type(solver_params.solver_type)
{
    const int num_scale_coeffs = get_lvl_idx(this->levels + 1);
	
	const size_t bytes = sizeof(real) * num_scale_coeffs;
	
	this->eta0 = (real*)malloc_device(bytes);
	this->qx0  = (real*)malloc_device(bytes);
	this->qy0  = (real*)malloc_device(bytes);
	this->z0   = (real*)malloc_device(bytes);

	this->eta1x = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;
	this->qx1x  = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;
	this->qy1x  = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;
	this->z1x   = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;

	this->eta1y = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;
	this->qx1y  = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;
	this->qy1y  = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;
	this->z1y   = (solver_type == MWDG2) ? (real*)malloc_device(bytes) : nullptr;
}

ScaleCoefficients::ScaleCoefficients
(
	const SolverParams& solver_params,
	const char*         dirroot,
	const char*         prefix
)
    : levels(solver_params.L), solver_type(solver_params.solver_type)
{
	if (this->solver_type == HWFV1)
	{
		char filename_eta0[255] = {'\0'};
		char filename_qx0[255]  = {'\0'};
		char filename_qy0[255]  = {'\0'};
		char filename_z0[255]   = {'\0'};

		sprintf(filename_eta0, "%s%s", prefix, "-scale-coeffs-eta0-hw");
		sprintf(filename_qx0,  "%s%s", prefix, "-scale-coeffs-qx0-hw");
		sprintf(filename_qy0,  "%s%s", prefix, "-scale-coeffs-qy0-hw");
		sprintf(filename_z0,   "%s%s", prefix, "-scale-coeffs-z0-hw");

		this->eta0 = read_hierarchy_array_real(this->levels, dirroot, filename_eta0);
		this->qx0  = read_hierarchy_array_real(this->levels, dirroot, filename_qx0);
		this->qy0  = read_hierarchy_array_real(this->levels, dirroot, filename_qy0);
		this->z0   = read_hierarchy_array_real(this->levels, dirroot, filename_z0);
	}
	else if (this->solver_type == MWDG2)
	{
		char filename_eta0[255]  = {'\0'};
		char filename_qx0[255]   = {'\0'};
		char filename_qy0[255]   = {'\0'};
		char filename_z0[255]    = {'\0'};
		char filename_eta1x[255] = {'\0'};
		char filename_qx1x[255]  = {'\0'};
		char filename_qy1x[255]  = {'\0'};
		char filename_z1x[255]   = {'\0'};
		char filename_eta1y[255] = {'\0'};
		char filename_qx1y[255]  = {'\0'};
		char filename_qy1y[255]  = {'\0'};
		char filename_z1y[255]   = {'\0'};

		sprintf(filename_eta0,  "%s%s", prefix, "-scale-coeffs-eta0-mw");
		sprintf(filename_qx0,   "%s%s", prefix, "-scale-coeffs-qx0-mw");
		sprintf(filename_qy0,   "%s%s", prefix, "-scale-coeffs-qy0-mw");
		sprintf(filename_z0,    "%s%s", prefix, "-scale-coeffs-z0-mw");
		sprintf(filename_eta1x, "%s%s", prefix, "-scale-coeffs-eta1x-mw");
		sprintf(filename_qx1x,  "%s%s", prefix, "-scale-coeffs-qx1x-mw");
		sprintf(filename_qy1x,  "%s%s", prefix, "-scale-coeffs-qy1x-mw");
		sprintf(filename_z1x,   "%s%s", prefix, "-scale-coeffs-z1x-mw");
		sprintf(filename_eta1y, "%s%s", prefix, "-scale-coeffs-eta1y-mw");
		sprintf(filename_qx1y,  "%s%s", prefix, "-scale-coeffs-qx1y-mw");
		sprintf(filename_qy1y,  "%s%s", prefix, "-scale-coeffs-qy1y-mw");
		sprintf(filename_z1y,   "%s%s", prefix, "-scale-coeffs-z1y-mw");
		
		this->eta0  = read_hierarchy_array_real(this->levels, dirroot, filename_eta0);
		this->qx0   = read_hierarchy_array_real(this->levels, dirroot, filename_qx0); 
		this->qy0   = read_hierarchy_array_real(this->levels, dirroot, filename_qy0); 
		this->z0    = read_hierarchy_array_real(this->levels, dirroot, filename_z0);  
		this->eta1x = read_hierarchy_array_real(this->levels, dirroot, filename_eta1x);
		this->qx1x  = read_hierarchy_array_real(this->levels, dirroot, filename_qx1x);
		this->qy1x  = read_hierarchy_array_real(this->levels, dirroot, filename_qy1x);
		this->z1x   = read_hierarchy_array_real(this->levels, dirroot, filename_z1x); 
		this->eta1y = read_hierarchy_array_real(this->levels, dirroot, filename_eta1y);
		this->qx1y  = read_hierarchy_array_real(this->levels, dirroot, filename_qx1y);
		this->qy1y  = read_hierarchy_array_real(this->levels, dirroot, filename_qy1y);
		this->z1y   = read_hierarchy_array_real(this->levels, dirroot, filename_z1y); 
	}
}

ScaleCoefficients::ScaleCoefficients(const ScaleCoefficients& original)
{
	*this        = original;
	is_copy_cuda = true;
}

ScaleCoefficients::~ScaleCoefficients()
{
    if (!is_copy_cuda)
	{
		CHECK_CUDA_ERROR( free_device(eta0) );
		CHECK_CUDA_ERROR( free_device(qx0) );
		CHECK_CUDA_ERROR( free_device(qy0) );
		CHECK_CUDA_ERROR( free_device(z0) );

		CHECK_CUDA_ERROR( free_device(eta1x) );
		CHECK_CUDA_ERROR( free_device(qx1x) );
		CHECK_CUDA_ERROR( free_device(qy1x) );
		CHECK_CUDA_ERROR( free_device(z1x) );

		CHECK_CUDA_ERROR( free_device(eta1y) );
		CHECK_CUDA_ERROR( free_device(qx1y) );
		CHECK_CUDA_ERROR( free_device(qy1y) );
		CHECK_CUDA_ERROR( free_device(z1y) );
	}
}

void ScaleCoefficients::write_to_file
(
	const char* dirroot,
	const char* prefix
)
{
    if (this->solver_type == HWFV1)
	{
		char filename_eta0[255] = {'\0'};
		char filename_qx0[255]  = {'\0'};
		char filename_qy0[255]  = {'\0'};
		char filename_z0[255]   = {'\0'};

		sprintf(filename_eta0, "%s%s", prefix, "-scale-coeffs-eta0-hw");
		sprintf(filename_qx0,  "%s%s", prefix, "-scale-coeffs-qx0-hw");
		sprintf(filename_qy0,  "%s%s", prefix, "-scale-coeffs-qy0-hw");
		sprintf(filename_z0,   "%s%s", prefix, "-scale-coeffs-z0-hw");
		
		write_hierarchy_array_real(dirroot, filename_eta0, this->eta0, this->levels);
		write_hierarchy_array_real(dirroot, filename_qx0,  this->qx0,  this->levels);
		write_hierarchy_array_real(dirroot, filename_qy0,  this->qy0,  this->levels);
		write_hierarchy_array_real(dirroot, filename_z0,   this->z0,   this->levels);
	}
	if (this->solver_type == MWDG2)
	{
		char filename_eta0[255]  = {'\0'};
		char filename_qx0[255]   = {'\0'};
		char filename_qy0[255]   = {'\0'};
		char filename_z0[255]    = {'\0'};
		char filename_eta1x[255] = {'\0'};
		char filename_qx1x[255]  = {'\0'};
		char filename_qy1x[255]  = {'\0'};
		char filename_z1x[255]   = {'\0'};
		char filename_eta1y[255] = {'\0'};
		char filename_qx1y[255]  = {'\0'};
		char filename_qy1y[255]  = {'\0'};
		char filename_z1y[255]   = {'\0'};

		sprintf(filename_eta0,  "%s%s", prefix, "-scale-coeffs-eta0-mw");
		sprintf(filename_qx0,   "%s%s", prefix, "-scale-coeffs-qx0-mw");
		sprintf(filename_qy0,   "%s%s", prefix, "-scale-coeffs-qy0-mw");
		sprintf(filename_z0,    "%s%s", prefix, "-scale-coeffs-z0-mw");
		sprintf(filename_eta1x, "%s%s", prefix, "-scale-coeffs-eta1x-mw");
		sprintf(filename_qx1x,  "%s%s", prefix, "-scale-coeffs-qx1x-mw");
		sprintf(filename_qy1x,  "%s%s", prefix, "-scale-coeffs-qy1x-mw");
		sprintf(filename_z1x,   "%s%s", prefix, "-scale-coeffs-z1x-mw");
		sprintf(filename_eta1y, "%s%s", prefix, "-scale-coeffs-eta1y-mw");
		sprintf(filename_qx1y,  "%s%s", prefix, "-scale-coeffs-qx1y-mw");
		sprintf(filename_qy1y,  "%s%s", prefix, "-scale-coeffs-qy1y-mw");
		sprintf(filename_z1y,   "%s%s", prefix, "-scale-coeffs-z1y-mw");
		
		write_hierarchy_array_real(dirroot, filename_eta0,  this->eta0,  this->levels);
		write_hierarchy_array_real(dirroot, filename_qx0,   this->qx0,   this->levels);
		write_hierarchy_array_real(dirroot, filename_qy0,   this->qy0,   this->levels);
		write_hierarchy_array_real(dirroot, filename_z0,    this->z0,    this->levels);
		write_hierarchy_array_real(dirroot, filename_eta1x, this->eta1x, this->levels);
		write_hierarchy_array_real(dirroot, filename_qx1x,  this->qx1x,  this->levels);
		write_hierarchy_array_real(dirroot, filename_qy1x,  this->qy1x,  this->levels);
		write_hierarchy_array_real(dirroot, filename_z1x,   this->z1x,   this->levels);
		write_hierarchy_array_real(dirroot, filename_eta1y, this->eta1y, this->levels);
		write_hierarchy_array_real(dirroot, filename_qx1y,  this->qx1y,  this->levels);
		write_hierarchy_array_real(dirroot, filename_qy1y,  this->qy1y,  this->levels);
		write_hierarchy_array_real(dirroot, filename_z1y,   this->z1y,   this->levels);
	}
}

real ScaleCoefficients::verify
(
	const char* dirroot,
	const char* prefix
)
{
	if (this->solver_type == HWFV1)
	{
		char filename_eta0[255] = {'\0'};
		char filename_qx0[255]  = {'\0'};
		char filename_qy0[255]  = {'\0'};
		char filename_z0[255]   = {'\0'};

		sprintf(filename_eta0, "%s%s", prefix, "-scale-coeffs-eta0-hw");
		sprintf(filename_qx0,  "%s%s", prefix, "-scale-coeffs-qx0-hw");
		sprintf(filename_qy0,  "%s%s", prefix, "-scale-coeffs-qy0-hw");
		sprintf(filename_z0,   "%s%s", prefix, "-scale-coeffs-z0-hw");
		
		real* d_eta0_verified = read_hierarchy_array_real(this->levels, dirroot, filename_eta0);
		real* d_qx0_verified  = read_hierarchy_array_real(this->levels, dirroot, filename_qx0);
		real* d_qy0_verified  = read_hierarchy_array_real(this->levels, dirroot, filename_qy0);
		real* d_z0_verified   = read_hierarchy_array_real(this->levels, dirroot, filename_z0);

		const int num_scale_coeffs = get_lvl_idx(this->levels + 1);

		real error_eta0 = compute_error(this->eta0, d_eta0_verified, num_scale_coeffs);
		real error_qx0  = compute_error(this->qx0,  d_qx0_verified,  num_scale_coeffs);
		real error_qy0  = compute_error(this->qy0,  d_qy0_verified,  num_scale_coeffs);
		real error_z0   = compute_error(this->z0,   d_z0_verified,   num_scale_coeffs);

		free_device(d_eta0_verified);
		free_device(d_qx0_verified);
		free_device(d_qy0_verified);
		free_device(d_z0_verified);

		// mean
		// return (error_eta0 + error_qx0 + error_qy0 + error_z0) / C(4.0);
		
		// max
		return std::max({error_eta0, error_qx0, error_qy0, error_z0});
	}
	else if (this->solver_type == MWDG2)
	{
		char filename_eta0[255]  = {'\0'};
		char filename_qx0[255]   = {'\0'};
		char filename_qy0[255]   = {'\0'};
		char filename_z0[255]    = {'\0'};
		char filename_eta1x[255] = {'\0'};
		char filename_qx1x[255]  = {'\0'};
		char filename_qy1x[255]  = {'\0'};
		char filename_z1x[255]   = {'\0'};
		char filename_eta1y[255] = {'\0'};
		char filename_qx1y[255]  = {'\0'};
		char filename_qy1y[255]  = {'\0'};
		char filename_z1y[255]   = {'\0'};

		sprintf(filename_eta0,  "%s%s", prefix, "-scale-coeffs-eta0-mw");
		sprintf(filename_qx0,   "%s%s", prefix, "-scale-coeffs-qx0-mw");
		sprintf(filename_qy0,   "%s%s", prefix, "-scale-coeffs-qy0-mw");
		sprintf(filename_z0,    "%s%s", prefix, "-scale-coeffs-z0-mw");
		sprintf(filename_eta1x, "%s%s", prefix, "-scale-coeffs-eta1x-mw");
		sprintf(filename_qx1x,  "%s%s", prefix, "-scale-coeffs-qx1x-mw");
		sprintf(filename_qy1x,  "%s%s", prefix, "-scale-coeffs-qy1x-mw");
		sprintf(filename_z1x,   "%s%s", prefix, "-scale-coeffs-z1x-mw");
		sprintf(filename_eta1y, "%s%s", prefix, "-scale-coeffs-eta1y-mw");
		sprintf(filename_qx1y,  "%s%s", prefix, "-scale-coeffs-qx1y-mw");
		sprintf(filename_qy1y,  "%s%s", prefix, "-scale-coeffs-qy1y-mw");
		sprintf(filename_z1y,   "%s%s", prefix, "-scale-coeffs-z1y-mw");
		
		real* d_eta0_verified  = read_hierarchy_array_real(this->levels, dirroot, filename_eta0);
		real* d_qx0_verified   = read_hierarchy_array_real(this->levels, dirroot, filename_qx0);
		real* d_qy0_verified   = read_hierarchy_array_real(this->levels, dirroot, filename_qy0);
		real* d_z0_verified    = read_hierarchy_array_real(this->levels, dirroot, filename_z0);
		real* d_eta1x_verified = read_hierarchy_array_real(this->levels, dirroot, filename_eta1x);
		real* d_qx1x_verified  = read_hierarchy_array_real(this->levels, dirroot, filename_qx1x);
		real* d_qy1x_verified  = read_hierarchy_array_real(this->levels, dirroot, filename_qy1x);
		real* d_z1x_verified   = read_hierarchy_array_real(this->levels, dirroot, filename_z1x);
		real* d_eta1y_verified = read_hierarchy_array_real(this->levels, dirroot, filename_eta1y);
		real* d_qx1y_verified  = read_hierarchy_array_real(this->levels, dirroot, filename_qx1y);
		real* d_qy1y_verified  = read_hierarchy_array_real(this->levels, dirroot, filename_qy1y);
		real* d_z1y_verified   = read_hierarchy_array_real(this->levels, dirroot, filename_z1y);

		const int num_scale_coeffs = get_lvl_idx(this->levels + 1);

		const real error_eta0  = compute_error(this->eta0,  d_eta0_verified,  num_scale_coeffs);
		const real error_qx0   = compute_error(this->qx0,   d_qx0_verified,   num_scale_coeffs);
		const real error_qy0   = compute_error(this->qy0,   d_qy0_verified,   num_scale_coeffs);
		const real error_z0    = compute_error(this->z0,    d_z0_verified,    num_scale_coeffs);
		const real error_eta1x = compute_error(this->eta1x, d_eta1x_verified, num_scale_coeffs);
		const real error_qx1x  = compute_error(this->qx1x,  d_qx1x_verified,  num_scale_coeffs);
		const real error_qy1x  = compute_error(this->qy1x,  d_qy1x_verified,  num_scale_coeffs);
		const real error_z1x   = compute_error(this->z1x,   d_z1x_verified,   num_scale_coeffs);
		const real error_eta1y = compute_error(this->eta1y, d_eta1y_verified, num_scale_coeffs);
		const real error_qx1y  = compute_error(this->qx1y,  d_qx1y_verified,  num_scale_coeffs);
		const real error_qy1y  = compute_error(this->qy1y,  d_qy1y_verified,  num_scale_coeffs);
		const real error_z1y   = compute_error(this->z1y,   d_z1y_verified,   num_scale_coeffs);

		// mean
		// const real error_0  = (error_eta0  + error_qx0  + error_qy0  + error_z0)  / C(4.0);
		// const real error_1x = (error_eta1x + error_qx1x + error_qy1x + error_z1x) / C(4.0);
		// const real error_1y = (error_eta1y + error_qx1y + error_qy1y + error_z1y) / C(4.0);
		// const real error = (error_0 + error_1x + error_1y) / C(3.0);

		// max
		const real error = std::max({error_eta0,  error_qx0,  error_qy0,  error_z0,
                                     error_eta1x, error_qx1x, error_qy1x, error_z1x,
                                     error_eta1y, error_qx1y, error_qy1y, error_z1y});

		free_device(d_eta0_verified);
		free_device(d_qx0_verified);
		free_device(d_qy0_verified);
		free_device(d_z0_verified);
		free_device(d_eta1x_verified);
		free_device(d_qx1x_verified);
		free_device(d_qy1x_verified);
		free_device(d_z1x_verified);
		free_device(d_eta1y_verified);
		free_device(d_qx1y_verified);
		free_device(d_qy1y_verified);
		free_device(d_z1y_verified);

		return error;
	}
}

#pragma once

#include <algorithm>

#include "../classes/SolverParams.h"
#include "../utilities/get_lvl_idx.cuh"
#include "../utilities/compute_error.cuh"
#include "../output/write_hierarchy_array_real.cuh"
#include "../input/read_hierarchy_array_real.cuh"

class ScaleCoefficients
{
public:
	ScaleCoefficients
	(
		const SolverParams& solver_params
	);
    
	ScaleCoefficients
	(
		const SolverParams& solver_params,
		const char*         dirroot,
		const char*         prefix
	);
    
	ScaleCoefficients
	(
		const ScaleCoefficients& original
	);
	
	~ScaleCoefficients();

    void write_to_file
	(
		const char* dirroot,
		const char* prefix
	);
    
	real verify
	(
		const char* dirroot,
		const char* prefix
	);
	
	real* eta0 = nullptr;
	real* qx0  = nullptr;
	real* qy0  = nullptr;
	real* z0   = nullptr;

	real* eta1x = nullptr;
	real* qx1x  = nullptr;
	real* qy1x  = nullptr;
	real* z1x   = nullptr;

	real* eta1y = nullptr;
	real* qx1y  = nullptr;
	real* qy1y  = nullptr;
	real* z1y   = nullptr;

	bool is_copy_cuda = false;

	int levels = 0;
	int solver_type = 0;
};
#include "SimulationParams.h"

SimulationParams::SimulationParams() = default;

SimulationParams::SimulationParams
(
    const int&  test_case,
    const char* input_filename,
    const int&  max_ref_lvl
)
    : test_case(test_case)
{
    int mesh_dim = 1 << max_ref_lvl;
    
    switch (this->test_case)
    {
        case 0: // raster file based test case
        {
            char dem_filename_buf[128] = {'\0'};
            read_keyword_str(input_filename, "DEMfile", dem_filename_buf);

            this->xsz       = read_keyword_int (dem_filename_buf, "ncols");
            this->ysz       = read_keyword_int (dem_filename_buf, "nrows");
            this->xmin      = read_keyword_real(dem_filename_buf, "xllcorner");
            this->ymin      = read_keyword_real(dem_filename_buf, "yllcorner");
            real cellsize   = read_keyword_real(dem_filename_buf, "cellsize");
            this->xmax      = this->xmin + this->xsz * cellsize;
            this->ymax      = this->ymin + this->ysz * cellsize;
            this->time      = read_keyword_real(input_filename, "sim_time");
            this->manning   = read_keyword_real(input_filename, "fpfric");
            this->is_monai  = read_keyword_bool(input_filename, "monai");
            this->is_oregon = read_keyword_bool(input_filename, "oregon-seaside");
        }
            break;
        case 1: // c prop
        case 2:
        case 3:
        case 4:
            this->xmin = C(0.0);
            this->xmax = C(50.0);
            this->ymin = C(0.0);
            this->ymax = C(50.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0);
            break;
        case 5: // wet dam break
        case 6: 
            this->xmin = C(0.0);
            this->xmax = C(50.0);
            this->ymin = C(0.0);
            this->ymax = C(50.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0);
            break;
        case 7: // dry dam break
        case 8:
            this->xmin = C(0.0);
            this->xmax = C(50.0);
            this->ymin = C(0.0);
            this->ymax = C(50.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0);
            break;
        case 9: // dry dam break w fric
        case 10:
            this->xmin = C(0.0);
            this->xmax = C(50.0);
            this->ymin = C(0.0);
            this->ymax = C(50.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.02);
            break;
        case 11: // building overtopping
        case 12:
        case 13:
        case 14:
            this->xmin = C(0.0);
            this->xmax = C(50.0);
            this->ymin = C(0.0);
            this->ymax = C(50.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.02);
            break;
        case 15: // triangle dam break
        case 16:
            this->xmin = C(0.0);
            this->xmax = C(38.0);
            this->ymin = C(0.0);
            this->ymax = C(38.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0125);
            break;
        case 17: // parabolic bowl, period "T" = 14.4 s
        case 18:
            this->xmin = C(-50.0);
            this->xmax = C( 50.0);
            this->ymin = C(-50.0);
            this->ymax = C( 50.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0);
            break;
        case 19: // three cones c prop
            this->xmin = C( 10.0);
            this->xmax = C( 70.0);
            this->ymin = C(-10.0);
            this->ymax = C( 50.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0);
            break;
        case 20: // three cones dam break
            this->xmin = C(0.0);
            this->xmax = C(70.0);
            this->ymin = C(0.0);
            this->ymax = C(30.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.018);
            break;
        case 21: // diff and non diff topo c prop
        case 22:
            this->xmin = C(0.0);
            this->xmax = C(75.0);
            this->ymin = C(0.0);
            this->ymax = C(75.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0);
            break;
        case 23: // radial dam break
            this->xmin = C(-20.0);
            this->xmax = C( 20.0);
            this->ymin = C(-20.0);
            this->ymax = C( 20.0);
            this->xsz  = mesh_dim;
            this->ysz  = mesh_dim;
            this->g    = C(9.80665);
            this->time = read_keyword_real(input_filename, "sim_time");
            this->manning = C(0.0);
            break;
        default:
            break;
    }
}
#pragma once

#include "../types/Coordinate.h"
#include "../types/real.h"
#include "../input/read_keyword_str.h"
#include "../classes/SolverParams.h"

class SimulationParams
{
public:
    SimulationParams();

    SimulationParams
    (
        const int&  test_case,
        const char* input_filename,
        const int&  max_ref_lvl
    );

	real       xmin      = C(0.0);
	real       xmax      = C(0.0);
	real       ymin      = C(0.0);
	real       ymax      = C(0.0);
	Coordinate xsz       = 0;
	Coordinate ysz       = 0;
	real       g         = C(9.80665);
	real       time      = C(0.0);
	real       manning   = C(0.0);
	bool       is_monai  = false;
	bool       is_oregon = false;
	int        test_case = -1;
};
#pragma once

#include "../types/real.h"

typedef struct Slopes
{
	real _1x;
	real _1y;

} Slopes;
#include "SolverParams.h"

SolverParams::SolverParams() = default;

SolverParams::SolverParams
(
    const char* input_filename
)
{
    this->L             = read_keyword_int (input_filename, "max_ref_lvl");
    this->initial_tstep = read_keyword_real(input_filename, "initial_tstep");
    this->epsilon       = read_keyword_real(input_filename, "epsilon");
    this->wall_height   = read_keyword_real(input_filename, "wall_height");

    if ( read_keyword_bool(input_filename, "hwfv1") )
    {
        this->solver_type = HWFV1;
        this->CFL         = C(0.5);
    }
    else if ( read_keyword_bool(input_filename, "mwdg2") )
    {
        this->solver_type = MWDG2;
        this->CFL         = C(0.3);
    }
    else
    {
        fprintf(stderr, "Error: invalid adaptive solver type specified, please specify either \"hwfv1\" or \"mwdg2\", file: %s, line: %d.\n", __FILE__, __LINE__);
        exit(-1);
    }

    this->grading = read_keyword_bool(input_filename, "grading");
    
    this->limitslopes = read_keyword_bool(input_filename, "limitslopes");
    
    if (this->limitslopes)
    {
        this->tol_Krivo = read_keyword_real(input_filename, "tol_Krivo");
    }
    
    this->refine_wall = read_keyword_bool(input_filename, "refine_wall");
    
    if (this->refine_wall)
    {
        this->ref_thickness = read_keyword_int(input_filename, "ref_thickness");
    }

    this->startq2d = read_keyword_bool(input_filename, "startq2d");
}
#pragma once

#include "../types/real.h"
#include "../types/SolverTypes.h"

#include "../input/read_keyword_int.h"
#include "../input/read_keyword_bool.h"
#include "../input/read_keyword_real.h"

class SolverParams
{
public:
	SolverParams();

	SolverParams
	(
		const char* input_filename
	);
	
	int  L             = 0;
	real initial_tstep = C(0.0);
	real epsilon       = C(0.0);
	real tol_h         = C(1e-3);
	real tol_q         = C(0.0);
	real tol_s         = C(1e-9);
	real wall_height   = C(0.0);
	int  solver_type   = 0;
	real CFL           = C(0.0);
	bool grading       = false;
	bool limitslopes   = false;
	real tol_Krivo     = C(9999.0);
	bool refine_wall   = false;
	int  ref_thickness = 0;
	bool startq2d      = false;
    
};
#pragma once

#include "../classes/SimulationParams.h"

#include "../zorder/generate_morton_code.cuh"

typedef struct StagePoints
{
	MortonCode* codes;
	int         num_points;
	bool        is_copy_cuda = false;

	StagePoints
	(
		const char*                input_filename,
		const SimulationParams sim_params,
		const real&                cell_size

	)
	{
		num_points = read_num_stage_points(input_filename);
		codes      = (num_points > 0) ? new MortonCode[num_points] : nullptr;

		read_stage_points
		(
			input_filename,
			cell_size,
			sim_params
		);
	}

	StagePoints(const StagePoints& original) { *this = original; is_copy_cuda = true; }

	~StagePoints() { if (!is_copy_cuda && codes != nullptr) delete[] codes; }

	int read_num_stage_points(const char* input_filename)
	{
		int num_stage_points = 0;
		
		char str[255]          = {'\0'};
		char buf[64]           = {'\0'};
		char stagefilename[64] = {'\0'};

		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for reading stage file name, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		while ( strncmp(buf, "stagefile", 9) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No stage file name found, proceeding without counting number of stage points.\n");
				fclose(fp);
				return 0;
			}

			sscanf(str, "%s %s", buf, stagefilename);
		}

		fclose(fp);

		fp = fopen(stagefilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening stage file for reading number of stage points, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		fscanf(fp, "%d", &num_stage_points);

		return num_stage_points;
	}

	void read_stage_points
	(
		const char*                 input_filename,
		const real&                 cell_size,
		const SimulationParams& sim_params
	)
	{
		if (num_points == 0) return;
		
		int num_stage_points = 0;

		char str[255]          = {'\0'};
		char buf[64]           = {'\0'};
		char stagefilename[64] = {'\0'};

		FILE* fp = fopen(input_filename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening input file for reading stage file name, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		while ( strncmp(buf, "stagefile", 9) )
		{
			if ( NULL == fgets(str, sizeof(str), fp) )
			{
				fprintf(stdout, "No stage file name found, proceeding without any stage points.\n");
				fclose(fp);
				return;
			}

			sscanf(str, "%s %s", buf, stagefilename);
		}

		fclose(fp);

		fp = fopen(stagefilename, "r");

		if (NULL == fp)
		{
			fprintf(stderr, "Error opening stage file for reading stage points, file: %s, line: %d.\n", __FILE__, __LINE__);
			exit(-1);
		}

		fscanf(fp, "%d", &num_stage_points);

		real x_stage = C(0.0);
		real y_stage = C(0.0);

		for (int i = 0; i < num_points; i++)
		{
			fscanf(fp, "%" NUM_FRMT " %" NUM_FRMT, &x_stage, &y_stage);

			Coordinate x = (x_stage - sim_params.xmin) / cell_size;
			Coordinate y = (y_stage - sim_params.ymin) / cell_size;

			codes[i] = generate_morton_code(x, y);
		}

		fclose(fp);
	}

} StagePoints;
#pragma once

#include "cuda_runtime.h"

#include <math.h>

#include "../types/real.h"


typedef struct SubDetailHW
{
	real alpha;
	real beta;
	real gamma;

	__device__  __forceinline__ real get_max()
	{
		real max_detail = C(0.0);

		max_detail = max( abs(alpha), abs(beta) );
		max_detail = max( abs(gamma), max_detail);

		return max_detail;
	}
	
} SubDetailHW;

typedef struct SubDetailMW
{
	SubDetailHW _0;
	SubDetailHW _1x;
	SubDetailHW _1y;

	__device__  __forceinline__ real get_max()
	{
		real max_detail = C(0.0);

		max_detail = max( _0.get_max(), _1x.get_max() );
		max_detail = max(_1y.get_max(), max_detail);

		return max_detail;
	}

} SubDetailMW;
#include "SubDetails.h"

SubDetails::SubDetails() = default;

SubDetails::SubDetails
(
	const int& levels
)
	: levels(levels)
{
	const int num_details = get_lvl_idx(this->levels + 1);
	
	size_t bytes = sizeof(real) * num_details;

	alpha = (this->levels > -1) ? (real*)malloc_device(bytes) : nullptr;
	beta  = (this->levels > -1) ? (real*)malloc_device(bytes) : nullptr;
	gamma = (this->levels > -1) ? (real*)malloc_device(bytes) : nullptr;
}

SubDetails::SubDetails
(
	const int&  levels,
	const char* dirroot,
	const char* prefix,
	const char* suffix
)
	: levels(levels)
{
	const int num_details = get_lvl_idx(this->levels + 1);
	
	char filename_alpha[255] = {'\0'};
	char filename_beta [255] = {'\0'};
	char filename_gamma[255] = {'\0'};

	sprintf(filename_alpha, "%s%s%s", prefix, "-details-alpha-", suffix);
	sprintf(filename_beta , "%s%s%s", prefix, "-details-beta-",  suffix);
	sprintf(filename_gamma, "%s%s%s", prefix, "-details-gamma-", suffix);

	alpha = (this->levels > -1) ? read_hierarchy_array_real(this->levels, dirroot, filename_alpha) : nullptr;
	beta  = (this->levels > -1) ? read_hierarchy_array_real(this->levels, dirroot, filename_beta)  : nullptr;
	gamma = (this->levels > -1) ? read_hierarchy_array_real(this->levels, dirroot, filename_gamma) : nullptr;
}

SubDetails::SubDetails(const SubDetails& original) { *this = original; is_copy_cuda = true; }

SubDetails::~SubDetails()
{
	if (!is_copy_cuda)
	{
		CHECK_CUDA_ERROR( free_device(alpha) );
		CHECK_CUDA_ERROR( free_device(beta) );
		CHECK_CUDA_ERROR( free_device(gamma) );
	}
}

void SubDetails::write_to_file
(
	const char* dirroot,
	const char* prefix,
	const char* suffix
)
{
	char filename_alpha[255] = {'\0'};
	char filename_beta [255] = {'\0'};
	char filename_gamma[255] = {'\0'};

	sprintf(filename_alpha, "%s%s%s", prefix, "-details-alpha-", suffix);
	sprintf(filename_beta , "%s%s%s", prefix, "-details-beta-",  suffix);
	sprintf(filename_gamma, "%s%s%s", prefix, "-details-gamma-", suffix);

	write_hierarchy_array_real(dirroot, filename_alpha, this->alpha, this->levels);
	write_hierarchy_array_real(dirroot, filename_beta,  this->beta,  this->levels);
	write_hierarchy_array_real(dirroot, filename_gamma, this->gamma, this->levels);
}

real SubDetails::verify
(
	const char* dirroot,
	const char* prefix,
	const char* suffix
)
{
	char filename_alpha[255] = {'\0'};
	char filename_beta [255] = {'\0'};
	char filename_gamma[255] = {'\0'};

	sprintf(filename_alpha, "%s%c%s%c%s", prefix, '-', "details-alpha", '-', suffix);
	sprintf(filename_beta , "%s%c%s%c%s", prefix, '-', "details-beta",  '-', suffix);
	sprintf(filename_gamma, "%s%c%s%c%s", prefix, '-', "details-gamma", '-', suffix);

	real* d_alpha = read_hierarchy_array_real(this->levels, dirroot, filename_alpha);
	real* d_beta  = read_hierarchy_array_real(this->levels, dirroot, filename_beta);
	real* d_gamma = read_hierarchy_array_real(this->levels, dirroot, filename_gamma);

	const int num_details = get_lvl_idx(this->levels + 1);

	real error_alpha = compute_error(this->alpha, d_alpha, num_details);
	real error_beta  = compute_error(this->beta , d_beta , num_details);
	real error_gamma = compute_error(this->gamma, d_gamma, num_details);

	free_device(d_alpha);
	free_device(d_beta );
	free_device(d_gamma);

	// mean
	// return (error_alpha + error_beta + error_gamma) / C(3.0);

	// max
	return max( error_alpha, max(error_beta, error_gamma) );
}
#pragma once

#include "../utilities/cuda_utils.cuh"
#include "../utilities/get_lvl_idx.cuh"
#include "../utilities/compute_error.cuh"

#include "../classes/SolverParams.h"

#include "../input/read_hierarchy_array_real.cuh"
#include "../output/write_hierarchy_array_real.cuh"

class SubDetails
{
public:
	SubDetails();

	SubDetails
	(
		const int& levels
	);

	SubDetails
	(
		const int&  levels,
		const char* dirroot,
		const char* prefix,
		const char* suffix
	);

	SubDetails
	(
		const SubDetails& original
	);

	~SubDetails();

	void write_to_file
	(
		const char* dirroot,
		const char* prefix,
		const char* suffix
	);

	real verify
	(
		const char* dirroot,
		const char* prefix,
		const char* suffix
	);

	real* alpha = nullptr;
	real* beta  = nullptr;
	real* gamma = nullptr;

	int   levels       = -1;
	bool  is_copy_cuda = false;
};
#pragma once

#include "../utilities/cuda_utils.cuh"

#if _USE_TRACER == 1

#include "nvtx3/nvToolsExt.h"

typedef struct Tracer
{
    Tracer(const char* label)
    {
        nvtxRangePushA(label);
    }
    
    ~Tracer()
    {
        CHECK_CUDA_ERROR( peek() );
        CHECK_CUDA_ERROR( sync() );

        nvtxRangePop();
    }

} Tracer;

#define TRACE(name) Tracer tracer(name);

#else

#define TRACE(name)

#endif

target_sources(
	    gpu-mwdg2
		PRIVATE
		read_and_project_modes_dg2.cu
		read_and_project_modes_fv1.cu
		read_cell_size.cpp
		read_command_line_params.cpp
		read_keyword_bool.cpp
		read_keyword_int.cpp
		read_keyword_real.cpp
		read_keyword_str.cpp
		read_raster_file.cpp
		read_test_case.cpp
		read_hierarchy_array_real.cu
		read_hierarchy_array_bool.cu
	)
#include "../input/read_and_project_modes_dg2.cuh"

__host__
void read_and_project_modes_dg2
(
	const char*              input_filename,
	const AssembledSolution& d_assem_sol,
	const NodalValues&       d_nodal_vals,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const int&               mesh_dim
)
{
	char h_raster_filename_buf[128]  = {'\0'};
	char qx_raster_filename_buf[128] = {'\0'};
	char qy_raster_filename_buf[128] = {'\0'};
	char dem_filename_buf[128]       = {'\0'};

	read_keyword_str(input_filename, "DEMfile", dem_filename_buf);
	
	// buffer for DEM filename should never be null char because DEM is always needed for realistic test case
	if (dem_filename_buf[0] == '\0')
	{
		fprintf(stderr, "Error reading DEM filename, file: %s, line: %d.\n", __FILE__, __LINE__);
	}
	
	read_keyword_str(input_filename, "startfile", h_raster_filename_buf);

	real* h_raster  = new real[d_assem_sol.length]();
	real* qx_raster = new real[d_assem_sol.length]();
	real* qy_raster = new real[d_assem_sol.length]();
	real* dem       = new real[d_assem_sol.length]();

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		dem[i] = solver_params.wall_height;
	}

	read_raster_file(h_raster_filename_buf,  h_raster,  mesh_dim, solver_params.wall_height);
	read_raster_file(dem_filename_buf,       dem,       mesh_dim, solver_params.wall_height);

	if (solver_params.startq2d)
	{
		sprintf(qx_raster_filename_buf, "%s%s", h_raster_filename_buf, ".Qx");
		sprintf(qy_raster_filename_buf, "%s%s", h_raster_filename_buf, ".Qy");

		read_raster_file(qx_raster_filename_buf, qx_raster, mesh_dim, solver_params.wall_height);
		read_raster_file(qy_raster_filename_buf, qy_raster, mesh_dim, solver_params.wall_height);
	}

	const int interface_dim = mesh_dim + 1;
	const int interface_y   = sim_params.ysz + 1;
	const int interface_x   = sim_params.xsz + 1;
	
	real* h_interface   = new real[interface_dim * interface_dim]();
	real* qx_interface  = new real[interface_dim * interface_dim]();
	real* qy_interface  = new real[interface_dim * interface_dim]();
	real* dem_interface = new real[interface_dim * interface_dim]();

	for (Coordinate y = 0; y < interface_dim; y++)
	{
		for (Coordinate x = 0; x < interface_dim; x++)
		{
			bool wall_or_border_x = (x == interface_x - 1 || x == interface_dim - 1);
			bool wall_or_border_y = (y == interface_y - 1 || y == interface_dim - 1);

			int i = (wall_or_border_x) ? x - 1 : x;
			int j = (wall_or_border_y) ? y - 1 : y;

			int interface_idx = (interface_dim - 1 - y) * interface_dim + x;
			int mode_idx      = (mesh_dim      - 1 - j) * mesh_dim      + i;

			h_interface[interface_idx]   = h_raster[mode_idx];
			qx_interface[interface_idx]  = qx_raster[mode_idx];
			qy_interface[interface_idx]  = qy_raster[mode_idx];
			dem_interface[interface_idx] = dem[mode_idx];
		}
	}

	size_t bytes = interface_dim * interface_dim * sizeof(real);

	copy_cuda(d_nodal_vals.h,  h_interface,   bytes);
	copy_cuda(d_nodal_vals.qx, qx_interface,  bytes);
	copy_cuda(d_nodal_vals.qy, qy_interface,  bytes);
	copy_cuda(d_nodal_vals.z,  dem_interface, bytes);

	const int num_blocks = get_num_blocks(d_assem_sol.length, THREADS_PER_BLOCK);

	modal_projections<<<num_blocks, THREADS_PER_BLOCK>>>
	(
		d_nodal_vals,
		d_assem_sol,
		solver_params,
		mesh_dim,
		interface_dim
	);

	delete[] h_raster;
	delete[] qx_raster;
	delete[] qy_raster;
	delete[] dem;
	
	delete[] h_interface;
	delete[] qx_interface;
	delete[] qy_interface;
	delete[] dem_interface;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../classes/SimulationParams.h"

#include "../input/read_raster_file.h"
#include "../input/read_keyword_str.h"
#include "../utilities/get_num_blocks.h"

#include "../mra/modal_projections.cuh"

__host__
void read_and_project_modes_dg2
(
	const char*              input_filename,
	const AssembledSolution& d_assem_sol,
	const NodalValues&       d_nodal_vals,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const int&               mesh_dim
);
#include "../input/read_and_project_modes_fv1.cuh"

__host__
void read_and_project_modes_fv1
(
	const char*              input_filename,
	const AssembledSolution& d_assem_sol,
	const int&               mesh_dim,
	const SolverParams&      solver_params
)
{
	char h_raster_filename_buf[128]  = {'\0'};
	char qx_raster_filename_buf[128] = {'\0'};
	char qy_raster_filename_buf[128] = {'\0'};
	char dem_filename_buf[128]       = {'\0'};

	read_keyword_str(input_filename, "DEMfile", dem_filename_buf);
	
	// buffer for DEM filename should never be null char because DEM is always needed for realistic test case
	if (dem_filename_buf[0] == '\0')
	{
		fprintf(stderr, "Error reading DEM filename, file: %s, line: %d.\n", __FILE__, __LINE__);
	}
	
	read_keyword_str(input_filename, "startfile", h_raster_filename_buf);

	real* h_raster  = new real[d_assem_sol.length]();
	real* qx_raster = new real[d_assem_sol.length]();
	real* qy_raster = new real[d_assem_sol.length]();
	real* dem       = new real[d_assem_sol.length]();

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		dem[i] = solver_params.wall_height;
	}

	read_raster_file(h_raster_filename_buf,  h_raster,  mesh_dim, solver_params.wall_height);
	read_raster_file(dem_filename_buf,       dem,       mesh_dim, solver_params.wall_height);

	if (solver_params.startq2d)
	{
		sprintf(qx_raster_filename_buf, "%s%s", h_raster_filename_buf, ".Qx");
		sprintf(qy_raster_filename_buf, "%s%s", h_raster_filename_buf, ".Qy");

		read_raster_file(qx_raster_filename_buf, qx_raster, mesh_dim, solver_params.wall_height);
		read_raster_file(qy_raster_filename_buf, qy_raster, mesh_dim, solver_params.wall_height);
	}

	size_t bytes = d_assem_sol.length * sizeof(real);

	copy_cuda(d_assem_sol.h0,  h_raster,  bytes);
	copy_cuda(d_assem_sol.qx0, qx_raster, bytes);
	copy_cuda(d_assem_sol.qy0, qy_raster, bytes);
	copy_cuda(d_assem_sol.z0,  dem,       bytes);

	delete[] h_raster;
	delete[] qx_raster;
	delete[] qy_raster;
	delete[] dem;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../classes/AssembledSolution.h"
#include "../classes/SolverParams.h"

#include "../input/read_raster_file.h"
#include "../input/read_keyword_str.h"

__host__
void read_and_project_modes_fv1
(
	const char*              input_filename,
	const AssembledSolution& d_assem_sol,
	const int&               mesh_dim,
	const SolverParams&      solver_params
);
#include "read_cell_size.h"

#define EXIT_READ_CELL_SIZE_LFP_82 { if (NULL == fp) { fprintf(stderr, "Error reading DEM file for cell size.\n"); exit(-1); } }

real read_cell_size(const char* input_filename)
{
	char dem_filename_buf[128] = {'\0'};
	read_keyword_str(input_filename, "DEMfile", dem_filename_buf);

	int  dummy          = 0;
	char dummy_buf[128] = {'\0'};
	real cell_size      = C(0.0);

	FILE* fp = fopen(dem_filename_buf, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening DEM file for cell size, file: %s, line: %d.\n", __FILE__, __LINE__);
		exit(-1);
	}

	// ESRI raster file header format:
	
	// ncols        392
	// nrows        243
	// xllcorner    0
	// yllcorner    0
	// cellsize     0.014
	// NODATA_value -9999

	// read up until cellsize
	fscanf(fp, "%s %d", dummy_buf, &dummy); EXIT_READ_CELL_SIZE_LFP_82
	fscanf(fp, "%s %d", dummy_buf, &dummy); EXIT_READ_CELL_SIZE_LFP_82
	fscanf(fp, "%s %" NUM_FRMT, dummy_buf, &cell_size); EXIT_READ_CELL_SIZE_LFP_82
	fscanf(fp, "%s %" NUM_FRMT, dummy_buf, &cell_size); EXIT_READ_CELL_SIZE_LFP_82
	fscanf(fp, "%s %" NUM_FRMT, dummy_buf, &cell_size);

	fclose(fp);

	return cell_size;
}
#pragma once

#include "../types/real.h"

#include "read_keyword_str.h"

real read_cell_size(const char* input_filename);
#include "read_command_line_params.h"

void read_command_line_params
(
	const int&        argc, 
	char**            argv,
	SimulationParams& sim_params,
	SolverParams&     solver_params,
	PlottingParams&   plot_params
)
{
	for (int i = 0; i < argc - 1; i++)
	{
		char* flag  = argv[i];
		char* value = argv[i+1];

		if ( !strncmp(flag, "-epsilon", 8) )
		{
			sscanf(value, "%" NUM_FRMT, &solver_params.epsilon);
		}
		else if ( !strncmp(flag, "-solver", 7) )
		{
			if ( !strncmp(value, "hwfv1", 5) )
			{
				solver_params.solver_type = HWFV1;
				solver_params.CFL         = C(0.5);
			}
			else if ( !strncmp(value, "mwdg2", 5) )
			{
				solver_params.solver_type = MWDG2;
				solver_params.CFL         = C(0.3);
			}
			else
			{
				fprintf(stderr, "Error: invalid adaptive solver type specified in command line, please specify either \"hwfv1\" or \"mwdg2\".");
				exit(-1);
			}
		}
		else if ( !strncmp(flag, "-dirroot", 8) )
		{
			int j = 0; while (plot_params.dirroot[j] != '\0') { plot_params.dirroot[j] = '\0'; j++; }
			
			sscanf(value, "%s", plot_params.dirroot);

			plot_params.make_output_directory();
		}
	}
}
#pragma once

#include <cstdlib>
#include <cstdio>
#include <cstring>

#include "../classes/SimulationParams.h"
#include "../classes/SolverParams.h"
#include "../classes/PlottingParams.h"

void read_command_line_params
(
	const int&        argc, 
	char**            argv,
	SimulationParams& sim_params,
	SolverParams&     solver_params,
	PlottingParams&   plot_params
);
#include "read_hierarchy_array_bool.cuh"

bool* read_hierarchy_array_bool
(
	const int&  levels,
	const char* dirroot,
	const char* filename
)
{
	// setting up host and device hierarchy arrays
	const int    num_all_elems = get_lvl_idx(levels + 1);
	const size_t bytes         = sizeof(bool) * num_all_elems;
	      bool*  h_hierarchy   = new bool[num_all_elems];
	      bool*  d_hierarchy   = (bool*)malloc_device(bytes);
	
	// reading into host array from file
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", dirroot, '/', filename, ".txt");

	FILE* fp = fopen(fullpath, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s for reading hierarchy array.\n", fullpath);
		fclose(fp);
		exit(-1);
	}

	bool dummy = 0;

	for (int i = 0; i < num_all_elems; i++)
	{
		fscanf(fp, "%d", &dummy);
		
		h_hierarchy[i] = dummy;
	}

	// copying host hierarchy to device hierarchy
	copy_cuda(d_hierarchy, h_hierarchy, bytes);

	fclose(fp);

	delete[] h_hierarchy;

	return d_hierarchy;
}
#pragma once

#include <cstdio>

#include "../utilities/get_lvl_idx.cuh"
#include "../utilities/cuda_utils.cuh"

bool* read_hierarchy_array_bool
(
	const int&  levels,
	const char* dirroot,
	const char* filename
);
#include "read_hierarchy_array_real.cuh"

real* read_hierarchy_array_real
(
	const int&  levels,
	const char* dirroot,
	const char* filename
)
{
	// setting up host and device hierarchy arrays
	const int    num_all_elems = get_lvl_idx(levels + 1);
	const size_t bytes         = sizeof(real) * num_all_elems;
	      real*  h_hierarchy   = new real[num_all_elems];
	      real*  d_hierarchy   = (real*)malloc_device(bytes);
	
	// reading into host array from file
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", dirroot, '/', filename, ".txt");

	FILE* fp = fopen(fullpath, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s for reading hierarchy array.\n", fullpath);
		fclose(fp);
		exit(-1);
	}

	real dummy = C(0.0);

	for (int i = 0; i < num_all_elems; i++)
	{
		fscanf(fp, "%" NUM_FRMT, &dummy);
		
		h_hierarchy[i] = dummy;
	}

	// copying host hierarchy to device hierarchy
	copy_cuda(d_hierarchy, h_hierarchy, bytes);

	fclose(fp);

	delete[] h_hierarchy;

	return d_hierarchy;
}
#pragma once

#include <cstdio>

#include "../utilities/get_lvl_idx.cuh"
#include "../utilities/cuda_utils.cuh"

#include "../types/real.h"

real* read_hierarchy_array_real
(
	const int&  levels,
	const char* dirroot,
	const char* filename
);
#include "read_keyword_bool.h"

bool read_keyword_bool
(
	const char* filename,
	const char* keyword
)
{
	const int num_char = strlen(keyword);
	
	if (num_char > 128)
	{
		fprintf(stderr, "Keyword length %s exceeds keyword buffer size 128, file: %s line: %d.\n", keyword, __FILE__, __LINE__);
		exit(-1);
	}

	FILE* fp = fopen(filename, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s for reading keyword %s, file: %s line: %d.\n", filename, keyword, __FILE__, __LINE__);
		exit(-1);
	}

	char keyword_buf[128] = {'\0'};
	char line_buf   [255] = {'\0'};

	while ( strncmp(keyword_buf, keyword, num_char) )
	{
		if ( NULL == fgets(line_buf, sizeof(line_buf), fp) )
		{
			fprintf(stderr, "Keyword %s not found when reading file %s.\n", keyword, filename);
			fclose(fp);
			return false;
		}

		sscanf(line_buf, "%s", keyword_buf);
	}

	fclose(fp);

	return true;
}
#pragma once

#include <cstdlib>
#include <cstdio>
#include <cstring>

bool read_keyword_bool
(
	const char* filename,
	const char* keyword
);
#include "read_keyword_int.h"

int read_keyword_int
(
	const char* filename,
	const char* keyword
)
{
	const int num_char = strlen(keyword);

	if (num_char > 128)
	{
		fprintf(stderr, "Keyword length %s exceeds keyword buffer size 255, file: %s line: %d.\n", keyword, __FILE__, __LINE__);
		exit(-1);
	}

	FILE* fp = fopen(filename, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s for reading keyword %s, file: %s line: %d.\n", filename, keyword, __FILE__, __LINE__);
		exit(-1);
	}

	int value = 0;

	char keyword_buf[128] = {'\0'};
	char line_buf   [255] = {'\0'};

	while ( strncmp(keyword_buf, keyword, num_char) )
	{
		if ( NULL == fgets(line_buf, 255, fp) )
		{
			fprintf(stderr, "Keyword %s not found when reading file %s.\n", keyword, filename);
			fclose(fp);
			return 0;
		}

		sscanf(line_buf, "%s %d", keyword_buf, &value);
	}

	fclose(fp);

	return value;
}
#pragma once

#include <cstdlib>
#include <cstdio>
#include <cstring>

int read_keyword_int
(
	const char* filename,
	const char* keyword
);
#include "read_keyword_real.h"

real read_keyword_real
(
	const char* filename,
	const char* keyword
)
{
	const int num_char = strlen(keyword); 
	
	if (num_char > 128)
	{
		fprintf(stderr, "Keyword length %s exceeds keyword buffer size 128, file: %s line: %d.\n", keyword, __FILE__, __LINE__);
		exit(-1);
	}
	
	FILE* fp = fopen(filename, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s for reading keyword %s, file: %s line: %d.\n", filename, keyword, __FILE__, __LINE__);
		exit(-1);
	}

	real value = C(0.0);

	char keyword_buf[128] = {'\0'};
	char line_buf   [255] = {'\0'};

	while ( strncmp(keyword_buf, keyword, num_char) )
	{
		if ( NULL == fgets(line_buf, 255, fp) )
		{
			fprintf(stderr, "Keyword %s not found when reading file %s.\n", keyword, filename);
			fclose(fp);
			return C(0.0);
		}

		sscanf(line_buf, "%s %" NUM_FRMT, keyword_buf, &value);
	}

	fclose(fp);

	return value;
}
#pragma once

#include <cstdlib>
#include <cstdio>
#include <cstring>

#include "../types/real.h"

real read_keyword_real
(
	const char* filename,
	const char* keyword
);
#include "read_keyword_str.h"

void read_keyword_str
(
	const char* filename,
	const char* keyword,
	      char* value_buf
)
{
	const int num_char = strlen(keyword); 
	
	if (num_char > 128)
	{
		fprintf(stderr, "Keyword length %s exceeds keyword buffer size 128, file: %s line: %d.\n", keyword, __FILE__, __LINE__);
		exit(-1);
	}

	FILE* fp = fopen(filename, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s for reading keyword %s, file: %s line: %d.\n", filename, keyword, __FILE__, __LINE__);
		exit(-1);
	}

	char keyword_buf[128] = {'\0'};
	char line_buf   [255] = {'\0'};

	while ( strncmp(keyword_buf, keyword, num_char) )
	{
		if ( NULL == fgets(line_buf, sizeof(line_buf), fp) )
		{
			fprintf(stderr, "Keyword %s not found when reading file %s.\n", keyword, filename);
			fclose(fp);
			value_buf[0] = '\0';
			return;
		}

		sscanf(line_buf, "%s %s", keyword_buf, value_buf);
	}

	fclose(fp);
}
#pragma once

#include <cstdlib>
#include <cstdio>
#include <cstring>

void read_keyword_str
(
	const char* filename,
	const char* keyword,
	      char* value_buf
);
#include "../input/read_raster_file.h"

void read_raster_file
(
	const char* raster_filename,
	real*       raster_array,
	const int&  mesh_dim,
	const real& wall_height
)
{
	char buf[255];

	int nrows = 0;
	int ncols = 0;

	real dummy = C(0.0);

	FILE* fp = fopen(raster_filename, "r");

	if (NULL == fp)
	{
		fprintf(stdout, "No raster file found: %s, using default values.\n", raster_filename);
		return;
	}

	fscanf(fp, "%s %d", buf, &ncols);
	fscanf(fp, "%s %d", buf, &nrows);
	fscanf(fp, "%s %" NUM_FRMT, buf, &dummy);
	fscanf(fp, "%s %" NUM_FRMT, buf, &dummy);
	fscanf(fp, "%s %" NUM_FRMT, buf, &dummy);
	fscanf(fp, "%s %" NUM_FRMT, buf, &dummy);

	for (int j = 0; j < nrows; j++)
	{
		for (int i = 0; i < ncols; i++)
		{
			fscanf(fp, "%" NUM_FRMT, &dummy);

			bool nodata = ( fabs( dummy + C(9999.0) ) < C(1e-10) );

			raster_array[ (nrows - 1 - j) * mesh_dim + i ] = (nodata) ? wall_height : dummy;

			int a = 1;
		}
	}

	fclose(fp);
}
#pragma once

#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <math.h>

#include "../types/real.h"

void read_raster_file
(
	const char* raster_filename,
	real*       raster_array,
	const int&  mesh_dim,
	const real& wall_height
);
#include "read_test_case.h"

int read_test_case(const char* input_file)
{
	const int test_case = read_keyword_int(input_file, "test_case");

	// the number of synthetic test cases
	const int max_test_case_number = 23;

	if (test_case > max_test_case_number || test_case < 0)
	{
		printf("Error: please rerun and enter a number between 0 and %d for the test case number. Exiting program, file: %s, line: %d.\n", max_test_case_number, __FILE__, __LINE__);
		exit(-1);
	}

	return test_case;
}

#pragma once

#include "read_keyword_int.h"

int read_test_case(const char* input_file);
target_sources(
	    gpu-mwdg2
		PRIVATE
		decoding_kernel_hw.cu
		decoding_kernel_single_block_hw.cu
		decoding_kernel_mw.cu
		decoding_kernel_single_block_mw.cu
		decoding.cu
		encode_flow_kernel_hw.cu
		encode_flow_kernel_single_block_hw.cu
		encode_flow_kernel_mw.cu
		encode_flow_kernel_single_block_mw.cu
		encode_flow.cu
		encode_topography_kernel_hw.cu
		encode_topography_kernel_mw.cu
		extra_significance.cu
		get_max_scale_coeffs.cu
		get_modal_values.cu
		get_nodal_values.cu
		get_reg_tree.cu
		init_eta_temp.cu
		init_nodal_values.cu
		init_sig_details.cu
		insert_point_srcs.cu
		modal_projections.cu
		preflag_details.cu
		preflag_topo.cu
		regularisation.cu
		refine_high_wall.cu
		reinsert_assem_sol.cu
		reinsert_point_srcs.cu
		traverse_tree_of_sig_details.cu
		zero_details.cu
	)
#pragma once

#include "cuda_runtime.h"

#include "../mra/Filters.h"
#include "../classes/SubDetail.h"
#include "../classes/ScaleChildren.h"

__device__ __forceinline__
real decode_0(real& u, SubDetailHW& sub_detail);

__device__ __forceinline__
real decode_1(real& u, SubDetailHW& sub_detail);

__device__ __forceinline__
real decode_2(real& u, SubDetailHW& sub_detail);

__device__ __forceinline__
real decode_3(real& u, SubDetailHW& sub_detail);

__device__ __forceinline__
ScaleChildrenHW decode_scale_children
(
	real      u,
	SubDetailHW sub_detail
)
{
	return
	{
		decode_0(u, sub_detail), // child 0
		decode_1(u, sub_detail), // child 1
		decode_2(u, sub_detail), // child 2
		decode_3(u, sub_detail)  // child 3
	};
}

__device__ __forceinline__
real decode_0(real& u, SubDetailHW& sub_detail)
{
	return ( H0 * (H0 * u + G0 * sub_detail.alpha) + G0 * (H0 * sub_detail.beta + G0 * sub_detail.gamma) ) * C(2.0);
}

__device__ __forceinline__
real decode_2(real& u, SubDetailHW& sub_detail)
{
	return ( H0 * (H1 * u + G1 * sub_detail.alpha) + G0 * (H1 * sub_detail.beta + G1 * sub_detail.gamma) ) * C(2.0);
}

__device__ __forceinline__
real decode_1(real& u, SubDetailHW& sub_detail)
{
	return ( H1 * (H0 * u + G0 * sub_detail.alpha) + G1 * (H0 * sub_detail.beta + G0 * sub_detail.gamma) ) * C(2.0);
}

__device__ __forceinline__
real decode_3(real& u, SubDetailHW& sub_detail)
{
	return ( H1 * (H1 * u + G1 * sub_detail.alpha) + G1 * (H1 * sub_detail.beta + G1 * sub_detail.gamma) ) * C(2.0);
}

__device__ __forceinline__
real decode_0_0
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH0_11 * u0  + HH0_21 * u1x  + HH0_31 * u1y  +
		   GA0_11 * da0 + GA0_21 * da1x + GA0_31 * da1y +
		   GB0_11 * db0 + GB0_21 * db1x + GB0_31 * db1y +
		   GC0_11 * dg0 + GC0_21 * dg1x + GC0_31 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_0_1x
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH0_12 * u0  + HH0_22 * u1x  + HH0_32 * u1y  +
		   GA0_12 * da0 + GA0_22 * da1x + GA0_32 * da1y +
		   GB0_12 * db0 + GB0_22 * db1x + GB0_32 * db1y +
		   GC0_12 * dg0 + GC0_22 * dg1x + GC0_32 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_0_1y
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH0_13 * u0  + HH0_23 * u1x  + HH0_33 * u1y  +
		   GA0_13 * da0 + GA0_23 * da1x + GA0_33 * da1y +
		   GB0_13 * db0 + GB0_23 * db1x + GB0_33 * db1y +
		   GC0_13 * dg0 + GC0_23 * dg1x + GC0_33 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_2_0
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH1_11 * u0  + HH1_21 * u1x  + HH1_31 * u1y  +
		   GA1_11 * da0 + GA1_21 * da1x + GA1_31 * da1y +
		   GB1_11 * db0 + GB1_21 * db1x + GB1_31 * db1y +
		   GC1_11 * dg0 + GC1_21 * dg1x + GC1_31 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_2_1x
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH1_12 * u0  + HH1_22 * u1x  + HH1_32 * u1y  +
		   GA1_12 * da0 + GA1_22 * da1x + GA1_32 * da1y +
		   GB1_12 * db0 + GB1_22 * db1x + GB1_32 * db1y +
		   GC1_12 * dg0 + GC1_22 * dg1x + GC1_32 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_2_1y
(
	const real& u0,	 const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH1_13 * u0  + HH1_23 * u1x  + HH1_33 * u1y  +
		   GA1_13 * da0 + GA1_23 * da1x + GA1_33 * da1y +
		   GB1_13 * db0 + GB1_23 * db1x + GB1_33 * db1y +
		   GC1_13 * dg0 + GC1_23 * dg1x + GC1_33 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_1_0
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH2_11 * u0  + HH2_21 * u1x  + HH2_31 * u1y  +
		   GA2_11 * da0 + GA2_21 * da1x + GA2_31 * da1y +
		   GB2_11 * db0 + GB2_21 * db1x + GB2_31 * db1y +
		   GC2_11 * dg0 + GC2_21 * dg1x + GC2_31 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_1_1x
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,	
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH2_12 * u0  + HH2_22 * u1x  + HH2_32 * u1y  +
		   GA2_12 * da0 + GA2_22 * da1x + GA2_32 * da1y +
		   GB2_12 * db0 + GB2_22 * db1x + GB2_32 * db1y +
		   GC2_12 * dg0 + GC2_22 * dg1x + GC2_32 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_1_1y
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH2_13 * u0  + HH2_23 * u1x  + HH2_33 * u1y  +
		   GA2_13 * da0 + GA2_23 * da1x + GA2_33 * da1y +
		   GB2_13 * db0 + GB2_23 * db1x + GB2_33 * db1y +
		   GC2_13 * dg0 + GC2_23 * dg1x + GC2_33 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_3_0
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH3_11 * u0  + HH3_21 * u1x  + HH3_31 * u1y  +
		   GA3_11 * da0 + GA3_21 * da1x + GA3_31 * da1y +
		   GB3_11 * db0 + GB3_21 * db1x + GB3_31 * db1y +
		   GC3_11 * dg0 + GC3_21 * dg1x + GC3_31 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_3_1x
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH3_12 * u0  + HH3_22 * u1x  + HH3_32 * u1y  +
		   GA3_12 * da0 + GA3_22 * da1x + GA3_32 * da1y +
		   GB3_12 * db0 + GB3_22 * db1x + GB3_32 * db1y +
		   GC3_12 * dg0 + GC3_22 * dg1x + GC3_32 * dg1y) * C(2.0);
}

__device__ __forceinline__
real decode_3_1y
(
	const real& u0,  const real& u1x,  const real& u1y,
	const real& da0, const real& da1x, const real& da1y,
	const real& db0, const real& db1x, const real& db1y,
	const real& dg0, const real& dg1x, const real& dg1y
)
{
	return (HH3_13 * u0  + HH3_23 * u1x  + HH3_33 * u1y  +
		   GA3_13 * da0 + GA3_23 * da1x + GA3_33 * da1y +
		   GB3_13 * db0 + GB3_23 * db1x + GB3_33 * db1y +
		   GC3_13 * dg0 + GC3_23 * dg1x + GC3_33 * dg1y) * C(2.0);
}
#pragma once

#include "cuda_runtime.h"

#include "../mra/Filters.h"
#include "../classes/ParentScaleCoeffs.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../classes/Detail.h"
#include "decode_scale_children.cuh"

__device__ __forceinline__
ChildScaleCoeffsHW decode_scale_coeffs
(
	ParentScaleCoeffsHW& parent_coeffs,
	DetailHW&            detail
)
{
	return
	{
		decode_scale_children(parent_coeffs.eta, detail.eta),
		decode_scale_children(parent_coeffs.qx,  detail.qx),
		decode_scale_children(parent_coeffs.qy,  detail.qy),
		{ 0, 0, 0, 0 }
	};
}

__device__ __forceinline__
ChildScaleCoeffsMW decode_scale_coeffs
(
	ParentScaleCoeffsMW& u,
	DetailMW&            d
)
{
	return
	{
		{
			{
				decode_0_0(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_1_0(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_2_0(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_3_0(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma)
			},
			{
				decode_0_1x(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_1_1x(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_2_1x(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_3_1x(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma)
			},
			{
				decode_0_1y(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_1_1y(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_2_1y(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma),
				decode_3_1y(u._0.eta, u._1x.eta, u._1y.eta, d.eta._0.alpha, d.eta._1x.alpha, d.eta._1y.alpha, d.eta._0.beta, d.eta._1x.beta, d.eta._1y.beta, d.eta._0.gamma, d.eta._1x.gamma, d.eta._1y.gamma)
			}
		},
		{
			{
				decode_0_0(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_1_0(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_2_0(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_3_0(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma)
			},
			{
				decode_0_1x(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_1_1x(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_2_1x(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_3_1x(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma)
			},
			{
				decode_0_1y(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_1_1y(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_2_1y(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma),
				decode_3_1y(u._0.qx, u._1x.qx, u._1y.qx, d.qx._0.alpha, d.qx._1x.alpha, d.qx._1y.alpha, d.qx._0.beta, d.qx._1x.beta, d.qx._1y.beta, d.qx._0.gamma, d.qx._1x.gamma, d.qx._1y.gamma)
			}
		},
		{
			{
				decode_0_0(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_1_0(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_2_0(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_3_0(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma)
			},
			{
				decode_0_1x(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_1_1x(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_2_1x(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_3_1x(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma)
			},
			{
				decode_0_1y(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_1_1y(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_2_1y(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma),
				decode_3_1y(u._0.qy, u._1x.qy, u._1y.qy, d.qy._0.alpha, d.qy._1x.alpha, d.qy._1y.alpha, d.qy._0.beta, d.qy._1x.beta, d.qy._1y.beta, d.qy._0.gamma, d.qy._1x.gamma, d.qy._1y.gamma)
			}
		},
		{
			{
				C(0.0), C(0.0), C(0.0), C(0.0)
			},
			{
				C(0.0), C(0.0), C(0.0), C(0.0)
			},
			{
				C(0.0), C(0.0), C(0.0), C(0.0)
			}
		}
	};
}
#include "decoding.cuh"

void decoding
(
	bool*              d_sig_details,
	real*              d_norm_details,
	Details&           d_details,
	ScaleCoefficients& d_scale_coeffs,
	SolverParams&      solver_params
)
{	
	extra_significance<true><<<1, THREADS_PER_BLOCK>>>
	(
		d_sig_details, 
		d_norm_details, 
		solver_params, 
		0,
		THREADS_PER_BLOCK
	);
	
	for (int level = LVL_SINGLE_BLOCK; level < solver_params.L - 1; level++)
	{
		int num_threads = 1 << (2 * level);
		int num_blocks  = get_num_blocks(num_threads, THREADS_PER_BLOCK);

		extra_significance<false><<<num_blocks, THREADS_PER_BLOCK>>>
		(
			d_sig_details,
			d_norm_details,
			solver_params,
			level,
			num_threads
		);
	}
	cudaError_t status = cudaFuncSetCacheConfig(decoding_kernel_mw, cudaFuncCachePreferL1);

	if (status != cudaSuccess)
	{
		printf("Error about L1, decoding.\n");
	}
	if (solver_params.solver_type == HWFV1)
	{
		decoding_kernel_single_block_hw<<<1, THREADS_PER_BLOCK>>>
		(
			d_sig_details, 
			d_details, 
			d_scale_coeffs, 
			solver_params, 
			0, 
			THREADS_PER_BLOCK
		);
	}
	else if (solver_params.solver_type == MWDG2)
	{
		decoding_kernel_single_block_mw<<<1, THREADS_PER_BLOCK>>>
		(
			d_sig_details, 
			d_details, 
			d_scale_coeffs, 
			solver_params, 
			0, 
			THREADS_PER_BLOCK
		);
	}

	for (int level = LVL_SINGLE_BLOCK; level < solver_params.L; level++)
	{				
		int num_threads = 1 << (2 * level);
		int num_blocks  = get_num_blocks(num_threads, THREADS_PER_BLOCK);

		if (solver_params.solver_type == HWFV1)
		{
			decoding_kernel_hw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_sig_details, 
				d_details, 
				d_scale_coeffs, 
				solver_params, 
				level, 
				num_threads
			);
		}
		else if (solver_params.solver_type == MWDG2)
		{
			decoding_kernel_mw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_sig_details, 
				d_details, 
				d_scale_coeffs, 
				solver_params, 
				level, 
				num_threads
			);
		}
	}
}
#pragma once

#include "../utilities/get_num_blocks.h"

#include "../utilities/cuda_utils.cuh"
#include "decoding_kernel_hw.cuh"
#include "decoding_kernel_single_block_hw.cuh"
#include "decoding_kernel_mw.cuh"
#include "decoding_kernel_single_block_mw.cuh"
#include "extra_significance.cuh"

void decoding
(
	bool*              d_sig_details,
	real*              d_norm_details,
	Details&           d_details,
	ScaleCoefficients& d_scale_coeffs,
	SolverParams&      solver_params
);
#include "decoding_kernel_hw.cuh"

__global__
void decoding_kernel_hw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;
	typedef cub::BlockScan<int, THREADS_PER_BLOCK> block_scan;

	__shared__ union
	{
		typename block_scan::TempStorage temp_storage;
		real     coeffs[4 * THREADS_PER_BLOCK];

	} shared;

	__shared__ HierarchyIndex shared_parents[THREADS_PER_BLOCK];

	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	HierarchyIndex parent = curr_lvl_idx + idx;

	int is_sig = d_sig_details[parent];

	int thread_prefix_sum = 0;

	int num_sig_details = 0;

	block_scan(shared.temp_storage).ExclusiveSum
	(
		is_sig,
		thread_prefix_sum,
		num_sig_details
	);

	__syncthreads();

	if (is_sig) shared_parents[thread_prefix_sum] = parent;

	__syncthreads();

	if (t_idx >= num_sig_details) return;

	parent = shared_parents[t_idx];

	ParentScaleCoeffsHW parents = load_parent_scale_coeffs_hw(d_scale_coeffs, parent);
	DetailHW            detail = load_details_hw(d_details, parent);
	ChildScaleCoeffsHW  children = decode_scale_coeffs(parents, detail);

	// storing eta
	shared.coeffs[4 * t_idx + 0] = children.eta.child_0;
	shared.coeffs[4 * t_idx + 1] = children.eta.child_1;
	shared.coeffs[4 * t_idx + 2] = children.eta.child_2;
	shared.coeffs[4 * t_idx + 3] = children.eta.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.eta0[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qx
	shared.coeffs[4 * t_idx + 0] = children.qx.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qx.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qx.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qx.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qx0[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qy
	shared.coeffs[4 * t_idx + 0] = children.qy.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qy.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qy.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qy.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qy0[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../classes/SolverParams.h"
#include "../types/HierarchyIndex.h"
#include "../classes/Details.h"
#include "../classes/ScaleCoefficients.h"
#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../utilities/get_lvl_idx.cuh"
#include "load_details.cuh"
#include "load_parent_scale_coeffs.cuh"
#include "decode_scale_coeffs.cuh"
#include "store_scale_coeffs.cuh"

__global__
void decoding_kernel_hw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
);
#include "decoding_kernel_mw.cuh"

__global__
void decoding_kernel_mw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;
	typedef cub::BlockScan<int, THREADS_PER_BLOCK> block_scan;

	__shared__ union
	{
		typename block_scan::TempStorage temp_storage;
		real     coeffs[4 * THREADS_PER_BLOCK];

	} shared;

	__shared__ HierarchyIndex shared_parents[THREADS_PER_BLOCK];

	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	HierarchyIndex parent = curr_lvl_idx + idx;

	int is_sig = d_sig_details[parent];

	int thread_prefix_sum = 0;

	int num_sig_details = 0;

	block_scan(shared.temp_storage).ExclusiveSum
	(
		is_sig,
		thread_prefix_sum,
		num_sig_details
	);

	__syncthreads();

	if (is_sig) shared_parents[thread_prefix_sum] = parent;

	__syncthreads();

	if (t_idx >= num_sig_details) return;

	parent = shared_parents[t_idx];

	ParentScaleCoeffsMW parents = load_parent_scale_coeffs_mw(d_scale_coeffs, parent);
	DetailMW            detail = load_details_mw(d_details, parent);
	ChildScaleCoeffsMW  children = decode_scale_coeffs(parents, detail);

	// storing eta
	shared.coeffs[4 * t_idx + 0] = children.eta._0.child_0;
	shared.coeffs[4 * t_idx + 1] = children.eta._0.child_1;
	shared.coeffs[4 * t_idx + 2] = children.eta._0.child_2;
	shared.coeffs[4 * t_idx + 3] = children.eta._0.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.eta0[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qx
	shared.coeffs[4 * t_idx + 0] = children.qx._0.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qx._0.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qx._0.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qx._0.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qx0[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qy
	shared.coeffs[4 * t_idx + 0] = children.qy._0.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qy._0.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qy._0.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qy._0.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qy0[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing eta
	shared.coeffs[4 * t_idx + 0] = children.eta._1x.child_0;
	shared.coeffs[4 * t_idx + 1] = children.eta._1x.child_1;
	shared.coeffs[4 * t_idx + 2] = children.eta._1x.child_2;
	shared.coeffs[4 * t_idx + 3] = children.eta._1x.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.eta1x[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qx
	shared.coeffs[4 * t_idx + 0] = children.qx._1x.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qx._1x.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qx._1x.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qx._1x.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qx1x[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qy
	shared.coeffs[4 * t_idx + 0] = children.qy._1x.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qy._1x.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qy._1x.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qy._1x.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qy1x[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing eta
	shared.coeffs[4 * t_idx + 0] = children.eta._1y.child_0;
	shared.coeffs[4 * t_idx + 1] = children.eta._1y.child_1;
	shared.coeffs[4 * t_idx + 2] = children.eta._1y.child_2;
	shared.coeffs[4 * t_idx + 3] = children.eta._1y.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.eta1y[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qx
	shared.coeffs[4 * t_idx + 0] = children.qx._1y.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qx._1y.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qx._1y.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qx._1y.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qx1y[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();

	// storing qy
	shared.coeffs[4 * t_idx + 0] = children.qy._1y.child_0;
	shared.coeffs[4 * t_idx + 1] = children.qy._1y.child_1;
	shared.coeffs[4 * t_idx + 2] = children.qy._1y.child_2;
	shared.coeffs[4 * t_idx + 3] = children.qy._1y.child_3;
	__syncthreads();

	for (int i = 0; i < 4; i++)
	{
		HierarchyIndex shared_idx = t_idx + i * num_sig_details;
		HierarchyIndex child = next_lvl_idx + 4 * (shared_parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		d_scale_coeffs.qy1y[child] = shared.coeffs[shared_idx];
	}
	__syncthreads();
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../classes/SolverParams.h"
#include "../types/HierarchyIndex.h"
#include "../classes/Details.h"
#include "../classes/ScaleCoefficients.h"
#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../utilities/get_lvl_idx.cuh"
#include "load_details.cuh"
#include "load_parent_scale_coeffs.cuh"
#include "decode_scale_coeffs.cuh"
#include "store_scale_coeffs.cuh"

__global__
void decoding_kernel_mw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
);
#include "decoding_kernel_single_block_hw.cuh"

__global__
void decoding_kernel_single_block_hw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;

	for (int level_block = 0; level_block < LVL_SINGLE_BLOCK; level_block++)
	{
		int num_threads_block = 1 << (2 * level_block);

		if (idx < num_threads_block)
		{
			HierarchyIndex curr_lvl_idx = get_lvl_idx(level_block);
			HierarchyIndex next_lvl_idx = get_lvl_idx(level_block + 1);

			HierarchyIndex parent = curr_lvl_idx + idx;
			HierarchyIndex child = next_lvl_idx + 4 * idx;

			bool is_sig = d_sig_details[parent];

			if (is_sig)
			{
				ParentScaleCoeffsHW parents = load_parent_scale_coeffs_hw(d_scale_coeffs, parent);
				DetailHW            detail = load_details_hw(d_details, parent);
				ChildScaleCoeffsHW  children = decode_scale_coeffs(parents, detail);

				store_scale_coeffs(children, d_scale_coeffs, child);
			}
		}

		__syncthreads();
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../classes/SolverParams.h"
#include "../types/HierarchyIndex.h"
#include "../classes/Details.h"
#include "../classes/ScaleCoefficients.h"
#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../utilities/get_lvl_idx.cuh"
#include "load_details.cuh"
#include "load_parent_scale_coeffs.cuh"
#include "decode_scale_coeffs.cuh"
#include "store_scale_coeffs.cuh"

__global__
void decoding_kernel_single_block_hw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
);
#include "decoding_kernel_single_block_mw.cuh"

__global__
void decoding_kernel_single_block_mw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;

	for (int level_block = 0; level_block < LVL_SINGLE_BLOCK; level_block++)
	{
		int num_threads_block = 1 << (2 * level_block);

		if (idx < num_threads_block)
		{
			HierarchyIndex curr_lvl_idx = get_lvl_idx(level_block);
			HierarchyIndex next_lvl_idx = get_lvl_idx(level_block + 1);

			HierarchyIndex parent = curr_lvl_idx + idx;
			HierarchyIndex child = next_lvl_idx + 4 * idx;

			bool is_sig = d_sig_details[parent];

			if (is_sig)
			{
				ParentScaleCoeffsMW parents = load_parent_scale_coeffs_mw(d_scale_coeffs, parent);
				DetailMW            detail = load_details_mw(d_details, parent);
				ChildScaleCoeffsMW  children = decode_scale_coeffs(parents, detail);

				store_scale_coeffs(children, d_scale_coeffs, child);
			}
		}

		__syncthreads();
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../classes/SolverParams.h"
#include "../types/HierarchyIndex.h"
#include "../classes/Details.h"
#include "../classes/ScaleCoefficients.h"
#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../utilities/get_lvl_idx.cuh"
#include "load_details.cuh"
#include "load_parent_scale_coeffs.cuh"
#include "decode_scale_coeffs.cuh"
#include "store_scale_coeffs.cuh"

__global__
void decoding_kernel_single_block_mw
(
	bool*             d_sig_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	int               level,
	int               num_threads
);
#pragma once

#include "../classes/Detail.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../mra/Filters.h"

// encodes the details alpha, beta and gamma for eta, qx, qy and z
__host__ __device__ __forceinline__
real encode_detail_alpha(const ScaleChildrenHW& u);

__host__ __device__ __forceinline__
real encode_detail_beta(const ScaleChildrenHW& u);

__host__ __device__ __forceinline__
real encode_detail_gamma(const ScaleChildrenHW& u);

__host__ __device__ __forceinline__
DetailHW encode_details(const ChildScaleCoeffsHW& child_coeffs)
{
	SubDetailHW eta =
	{
		encode_detail_alpha(child_coeffs.eta),
		encode_detail_beta(child_coeffs.eta),
		encode_detail_gamma(child_coeffs.eta)
	};

	SubDetailHW qx =
	{
		encode_detail_alpha(child_coeffs.qx),
		encode_detail_beta(child_coeffs.qx),
		encode_detail_gamma(child_coeffs.qx)
	};

	SubDetailHW qy =
	{
		encode_detail_alpha(child_coeffs.qy),
		encode_detail_beta(child_coeffs.qy),
		encode_detail_gamma(child_coeffs.qy)
	};
	
	SubDetailHW z =
	{
		encode_detail_alpha(child_coeffs.z),
		encode_detail_beta(child_coeffs.z),
		encode_detail_gamma(child_coeffs.z)
	};

	return
	{
		eta,
		qx,
		qy,
		z
	};
}

__host__ __device__ __forceinline__
real encode_detail_alpha(const ScaleChildrenHW& u)
{
	return C(0.5) * ( H0 * (G0 * u.child_0 + G1 * u.child_2) + H1 * (G0 * u.child_1 + G1 * u.child_3) );
}

__host__ __device__ __forceinline__
real encode_detail_beta(const ScaleChildrenHW& u)
{
	return C(0.5) * ( G0 * (H0 * u.child_0 + H1 * u.child_2) + G1 * (H0 * u.child_1 + H1 * u.child_3) );
}

__host__ __device__ __forceinline__
real encode_detail_gamma(const ScaleChildrenHW& u)
{
	return C(0.5) * ( G0 * (G0 * u.child_0 + G1 * u.child_2) + G1 * (G0 * u.child_1 + G1 * u.child_3) );
}

__host__ __device__ __forceinline__
real encode_detail_alpha_0(const ScaleChildrenMW& u)
{
	return (GA0_11 * u._0.child_0 + GA0_12 * u._1x.child_0 + GA0_13 * u._1y.child_0 +
		    GA1_11 * u._0.child_2 + GA1_12 * u._1x.child_2 + GA1_13 * u._1y.child_2 +
		    GA2_11 * u._0.child_1 + GA2_12 * u._1x.child_1 + GA2_13 * u._1y.child_1 +
		    GA3_11 * u._0.child_3 + GA3_12 * u._1x.child_3 + GA3_13 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_beta_0(const ScaleChildrenMW& u)
{
	return (GB0_11 * u._0.child_0 + GB0_12 * u._1x.child_0 + GB0_13 * u._1y.child_0 +
		    GB1_11 * u._0.child_2 + GB1_12 * u._1x.child_2 + GB1_13 * u._1y.child_2 +
		    GB2_11 * u._0.child_1 + GB2_12 * u._1x.child_1 + GB2_13 * u._1y.child_1 +
		    GB3_11 * u._0.child_3 + GB3_12 * u._1x.child_3 + GB3_13 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_gamma_0(const ScaleChildrenMW& u)
{
	return (GC0_11 * u._0.child_0 + GC0_12 * u._1x.child_0 + GC0_13 * u._1y.child_0 +
		    GC1_11 * u._0.child_2 + GC1_12 * u._1x.child_2 + GC1_13 * u._1y.child_2 +
		    GC2_11 * u._0.child_1 + GC2_12 * u._1x.child_1 + GC2_13 * u._1y.child_1 +
		    GC3_11 * u._0.child_3 + GC3_12 * u._1x.child_3 + GC3_13 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_alpha_1x(const ScaleChildrenMW& u)
{
	return (GA0_21 * u._0.child_0 + GA0_22 * u._1x.child_0 + GA0_23 * u._1y.child_0 +
		    GA1_21 * u._0.child_2 + GA1_22 * u._1x.child_2 + GA1_23 * u._1y.child_2 +
		    GA2_21 * u._0.child_1 + GA2_22 * u._1x.child_1 + GA2_23 * u._1y.child_1 +
		    GA3_21 * u._0.child_3 + GA3_22 * u._1x.child_3 + GA3_23 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_beta_1x(const ScaleChildrenMW& u)
{
	return (GB0_21 * u._0.child_0 + GB0_22 * u._1x.child_0 + GB0_23 * u._1y.child_0 +
		    GB1_21 * u._0.child_2 + GB1_22 * u._1x.child_2 + GB1_23 * u._1y.child_2 +
		    GB2_21 * u._0.child_1 + GB2_22 * u._1x.child_1 + GB2_23 * u._1y.child_1 +
		    GB3_21 * u._0.child_3 + GB3_22 * u._1x.child_3 + GB3_23 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_gamma_1x(const ScaleChildrenMW& u)

{
	return (GC0_21 * u._0.child_0 + GC0_22 * u._1x.child_0 + GC0_23 * u._1y.child_0 +
		    GC1_21 * u._0.child_2 + GC1_22 * u._1x.child_2 + GC1_23 * u._1y.child_2 +
		    GC2_21 * u._0.child_1 + GC2_22 * u._1x.child_1 + GC2_23 * u._1y.child_1 +
		    GC3_21 * u._0.child_3 + GC3_22 * u._1x.child_3 + GC3_23 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_alpha_1y(const ScaleChildrenMW& u)
{
	return (GA0_31 * u._0.child_0 + GA0_32 * u._1x.child_0 + GA0_33 * u._1y.child_0 +
		    GA1_31 * u._0.child_2 + GA1_32 * u._1x.child_2 + GA1_33 * u._1y.child_2 +
		    GA2_31 * u._0.child_1 + GA2_32 * u._1x.child_1 + GA2_33 * u._1y.child_1 +
		    GA3_31 * u._0.child_3 + GA3_32 * u._1x.child_3 + GA3_33 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_beta_1y(const ScaleChildrenMW& u)
{
	return (GB0_31 * u._0.child_0 + GB0_32 * u._1x.child_0 + GB0_33 * u._1y.child_0 +
		    GB1_31 * u._0.child_2 + GB1_32 * u._1x.child_2 + GB1_33 * u._1y.child_2 +
		    GB2_31 * u._0.child_1 + GB2_32 * u._1x.child_1 + GB2_33 * u._1y.child_1 +
		    GB3_31 * u._0.child_3 + GB3_32 * u._1x.child_3 + GB3_33 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_detail_gamma_1y(const ScaleChildrenMW& u)
{
	return (GC0_31 * u._0.child_0 + GC0_32 * u._1x.child_0 + GC0_33 * u._1y.child_0 +
		    GC1_31 * u._0.child_2 + GC1_32 * u._1x.child_2 + GC1_33 * u._1y.child_2 +
		    GC2_31 * u._0.child_1 + GC2_32 * u._1x.child_1 + GC2_33 * u._1y.child_1 +
		    GC3_31 * u._0.child_3 + GC3_32 * u._1x.child_3 + GC3_33 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
SubDetailHW encode_detail_0(const ScaleChildrenMW& u)
{
	return
	{
		encode_detail_alpha_0(u),
		encode_detail_beta_0(u),
		encode_detail_gamma_0(u)
	};
}
__host__ __device__ __forceinline__
SubDetailHW encode_detail_1x(const ScaleChildrenMW& u)
{
	return
	{
		encode_detail_alpha_1x(u),
		encode_detail_beta_1x(u),
		encode_detail_gamma_1x(u)
	};
}

__host__ __device__ __forceinline__
SubDetailHW encode_detail_1y(const ScaleChildrenMW& u)
{
	return
	{
		encode_detail_alpha_1y(u),
		encode_detail_beta_1y(u),
		encode_detail_gamma_1y(u)
	};
}

__host__ __device__ __forceinline__
SubDetailMW encode_detail(const ScaleChildrenMW& u)
{
	return
	{
		encode_detail_0 (u),
		encode_detail_1x(u),
		encode_detail_1y(u)
	};
}

__host__ __device__ __forceinline__
DetailMW encode_details(const ChildScaleCoeffsMW& child_coeffs)
{
	return
	{
		encode_detail(child_coeffs.eta),
		encode_detail(child_coeffs.qx),
		encode_detail(child_coeffs.qy),
		encode_detail(child_coeffs.z)
	};
}
#include "encode_flow.cuh"

__host__
void encode_flow
(
	ScaleCoefficients& d_scale_coeffs,
	Details&           d_details,
	real*              d_norm_details,
	bool*              d_sig_details,
	bool*              d_preflagged_details,
	Maxes&             maxes, 
	SolverParams&      solver_params,
	bool               for_nghbrs
)
{
	TRACE("This is encoding.");
	cudaError_t status = cudaFuncSetCacheConfig(encode_flow_kernel_mw, cudaFuncCachePreferL1);
	
	if (status != cudaSuccess)
	{
		printf("Error about L1 encoding.\n");
	}

	for (int level = solver_params.L - 1; level >= LVL_SINGLE_BLOCK; level--)
	{
	    int num_threads = 1 << (2 * level);
		int num_blocks  = get_num_blocks(num_threads, THREADS_PER_BLOCK);
		
		if (solver_params.solver_type == HWFV1)
		{
			encode_flow_kernel_hw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_scale_coeffs,
				d_details,
				d_norm_details,
				d_sig_details,
				d_preflagged_details,
				maxes,
				solver_params,
				level,
				num_threads,
				for_nghbrs
			);
		}
		else if (solver_params.solver_type == MWDG2)
		{
			encode_flow_kernel_mw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_scale_coeffs,
				d_details,
				d_norm_details,
				d_sig_details,
				d_preflagged_details,
				maxes,
				solver_params,
				level,
				num_threads,
				for_nghbrs
			);
		}
	}

	for (int level = LVL_SINGLE_BLOCK - 1; level >= 0; level--)
	{
		int num_threads = 1 << (2 * level);
		int num_blocks  = get_num_blocks(num_threads, THREADS_PER_BLOCK);

		if (solver_params.solver_type == HWFV1)
		{
			encode_flow_kernel_single_block_hw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_scale_coeffs,
				d_details,
				d_norm_details,
				d_sig_details,
				d_preflagged_details,
				maxes,
				solver_params,
				level,
				num_threads,
				for_nghbrs
			);
		}
		else if (solver_params.solver_type == MWDG2)
		{
			encode_flow_kernel_single_block_mw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_scale_coeffs,
				d_details,
				d_norm_details,
				d_sig_details,
				d_preflagged_details,
				maxes,
				solver_params,
				level,
				num_threads,
				for_nghbrs
			);
		}
	}
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../classes/Tracer.h"
#include "../classes/SolverParams.h"
#include "../types/HierarchyIndex.h"

#include "../utilities/get_num_blocks.h"

#include "encode_flow_kernel_hw.cuh"
#include "encode_flow_kernel_single_block_hw.cuh"
#include "encode_flow_kernel_mw.cuh"
#include "encode_flow_kernel_single_block_mw.cuh"

__host__
void encode_flow
(
	ScaleCoefficients& d_scale_coeffs,
	Details&           d_details,
	real*              d_norm_details,
	bool*              d_sig_details,
	bool*              d_preflagged_details,
	Maxes&             maxes, 
	SolverParams&      solver_params,
	bool               for_nghbrs
);
#include "encode_flow_kernel_hw.cuh"

/*
 *
 * This kernel launches every refinement level starting from n = L, using 4^n threads.
 * These threads load the scale coefficients into shared memory.
 * These scale coefficients are the child coefficients of the sub-elements at n - 1.
 * At n - 1, there are 4^(n-1) sub-elements i.e. a quarter compared to 4^n.
 * Hence, after loading the scale coefficients into shared memory, only 4^(n-1) threads are kept.
 * Thereafter, each thread loads four child coefficients from shared memory to encode the parent and detail.
 * A block size that is a multiple of 4 is used to ensure enough child coefficients are loaded.
 * For the block sizes below, there is a refinement level at which only one thread block is launched:
 * 
 * Block size: 64.   Level at which only a single block is launched (LVL_SINGLE_BLOCK): 3.
 * Block size: 256.  Level at which only a single block is launched (LVL_SINGLE_BLOCK): 4.
 * Block size: 1024. Level at which only a single block is launched (LVL_SINGLE_BLOCK): 5.
 * 
 * In this scenario, the kernel is not relaunched, as a single block has enough threads for all subsequent levels.
 * Instead, there is an internal for-loop across levels, which writes the scale coefficients to shared memory.
 * The threads in the next iteration of the loop access the shared memory, which is visible to all threads within a block.
 * 
 */

__global__
void encode_flow_kernel_hw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;
	
	real norm_detail   = C(0.0);
	real epsilon_local = solver_params.epsilon / ( 1 << (solver_params.L - level) );

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	real tol_q = solver_params.tol_q;

	typedef cub::BlockScan<int, THREADS_PER_BLOCK> block_scan;

	__shared__ union
	{
		typename block_scan::TempStorage temp_storage;
		real     coeffs[THREADS_PER_BLOCK];

	} shared;
	
	__shared__ HierarchyIndex parents[THREADS_PER_BLOCK]; 

	HierarchyIndex parent_idx = curr_lvl_idx + idx;
	HierarchyIndex child_idx  = next_lvl_idx + 4 * idx;

	int is_sig = d_sig_details[parent_idx];

	int thread_prefix_sum = 0;

	int num_sig_details = 0;

	block_scan(shared.temp_storage).ExclusiveSum
	(
		is_sig,
		thread_prefix_sum,
		num_sig_details
	);

	__syncthreads();

	if (!for_nghbrs) d_sig_details[parent_idx] = INSIGNIFICANT;

	if (is_sig) parents[thread_prefix_sum] = parent_idx;

	__syncthreads();

	if (t_idx >= num_sig_details) return;

	parent_idx = parents[t_idx];

	HierarchyIndex shared_idx = 0;

	real eta[4];
	real  qx[4];
	real  qy[4];

#pragma unroll
	for (int i = 0; i < 4; i++)
	{
		shared_idx = t_idx + i * num_sig_details;
		child_idx = next_lvl_idx + 4 * (parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		// loading eta
		shared.coeffs[t_idx] = d_scale_coeffs.eta0[child_idx];
		__syncthreads();
#pragma unroll
		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) eta[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		// loading qx
		shared.coeffs[t_idx] = d_scale_coeffs.qx0[child_idx];
		__syncthreads();
#pragma unroll
		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) qx[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		// loading qy
		shared.coeffs[t_idx] = d_scale_coeffs.qy0[child_idx];
		__syncthreads();
#pragma unroll
		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) qy[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();
	}

	ChildScaleCoeffsHW child_coeffs =
	{
		{ eta[0], eta[1], eta[2], eta[3] },
		{ qx[0], qx[1], qx[2], qx[3] },
		{ qy[0], qy[1], qy[2], qy[3] },
		{ C(0.0), C(0.0), C(0.0), C(0.0) }
	};

	ParentScaleCoeffsHW parent_coeffs = encode_scale_coeffs(child_coeffs);
	DetailHW            detail = encode_details(child_coeffs);

	norm_detail = detail.get_norm_detail(maxes);

	store_scale_coeffs
	(
		parent_coeffs,
		d_scale_coeffs,
		parent_idx
	);

	store_details
	(
		detail,
		d_details,
		parent_idx
	);

	d_norm_details[parent_idx] = norm_detail;

	d_sig_details[parent_idx] = (norm_detail >= epsilon_local) ? SIGNIFICANT : INSIGNIFICANT;

	if (d_preflagged_details[parent_idx] == SIGNIFICANT) d_sig_details[parent_idx] = SIGNIFICANT;
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../types/HierarchyIndex.h"
#include "../classes/ScaleCoefficients.h"
#include "../classes/SolverParams.h"
#include "../classes/Details.h"
#include "../classes/Detail.h"
#include "../classes/Maxes.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../classes/ParentScaleCoeffs.h"

#include "../utilities/get_lvl_idx.cuh"
#include "store_details.cuh"
#include "store_scale_coeffs.cuh"
#include "encode_scale_coeffs.cuh"
#include "encode_details.cuh"

__global__
void encode_flow_kernel_hw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
);
#include "encode_flow_kernel_mw.cuh"

/*
 *
 * This kernel launches every refinement level starting from n = L, using 4^n threads.
 * These threads load the scale coefficients into shared memory.
 * These scale coefficients are the child coefficients of the sub-elements at n - 1.
 * At n - 1, there are 4^(n-1) sub-elements i.e. a quarter compared to 4^n.
 * Hence, after loading the scale coefficients into shared memory, only 4^(n-1) threads are kept.
 * Thereafter, each thread loads four child coefficients from shared memory to encode the parent and detail.
 * A block size that is a multiple of 4 is used to ensure enough child coefficients are loaded.
 * For the block sizes below, there is a refinement level at which only one thread block is launched:
 * 
 * Block size: 64.   Level at which only a single block is launched (LVL_SINGLE_BLOCK): 3.
 * Block size: 256.  Level at which only a single block is launched (LVL_SINGLE_BLOCK): 4.
 * Block size: 1024. Level at which only a single block is launched (LVL_SINGLE_BLOCK): 5.
 * 
 * In this scenario, the kernel is not relaunched, as a single block has enough threads for all subsequent levels.
 * Instead, there is an internal for-loop across levels, which writes the scale coefficients to shared memory.
 * The threads in the next iteration of the loop access the shared memory, which is visible to all threads within a block.
 * 
 */

__global__
void encode_flow_kernel_mw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;
	
	real norm_detail   = C(0.0);
	real epsilon_local = solver_params.epsilon / ( 1 << (solver_params.L - level) );

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	typedef cub::BlockScan<int, THREADS_PER_BLOCK> block_scan;

	__shared__ union
	{
		typename block_scan::TempStorage temp_storage;
		real     coeffs[THREADS_PER_BLOCK];

	} shared;
	
	__shared__ HierarchyIndex parents[THREADS_PER_BLOCK]; 

	HierarchyIndex parent_idx = curr_lvl_idx + idx;
	HierarchyIndex child_idx  = next_lvl_idx + 4 * idx;

	int is_sig = d_sig_details[parent_idx];

	int thread_prefix_sum = 0;

	int num_sig_details = 0;

	block_scan(shared.temp_storage).ExclusiveSum
	(
		is_sig,
		thread_prefix_sum,
		num_sig_details
	);

	__syncthreads();

	if (!for_nghbrs) d_sig_details[parent_idx] = INSIGNIFICANT;

	if (is_sig) parents[thread_prefix_sum] = parent_idx;

	__syncthreads();

	if (t_idx >= num_sig_details) return;

	parent_idx = parents[t_idx];

	HierarchyIndex shared_idx = 0;

	real s0[4];
	real s1x[4];
	real s1y[4];

	for (int i = 0; i < 4; i++)
	{
		shared_idx = t_idx + i * num_sig_details;
		child_idx = next_lvl_idx + 4 * (parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		shared.coeffs[t_idx] = d_scale_coeffs.eta0[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s0[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		shared.coeffs[t_idx] = d_scale_coeffs.eta1x[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s1x[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		shared.coeffs[t_idx] = d_scale_coeffs.eta1y[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s1y[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();
	}

	ScaleChildrenMW children =
	{
		{  s0[0],  s0[1],  s0[2],  s0[3] },
		{ s1x[0], s1x[1], s1x[2], s1x[3] },
		{ s1y[0], s1y[1], s1y[2], s1y[3] }
	};

	d_scale_coeffs.eta0[parent_idx]  = encode_scale_0 (children);
	d_scale_coeffs.eta1x[parent_idx] = encode_scale_1x(children);
	d_scale_coeffs.eta1y[parent_idx] = encode_scale_1y(children);

	SubDetailMW subdetail = encode_detail(children);

	store_details
	(
		d_details.eta0,
		d_details.eta1x,
		d_details.eta1y,
		subdetail,
		parent_idx
	);

	norm_detail = max(norm_detail, subdetail.get_max() / maxes.eta);

	for (int i = 0; i < 4; i++)
	{
		shared_idx = t_idx + i * num_sig_details;
		child_idx = next_lvl_idx + 4 * (parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		shared.coeffs[t_idx] = d_scale_coeffs.qx0[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s0[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		shared.coeffs[t_idx] = d_scale_coeffs.qx1x[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s1x[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		shared.coeffs[t_idx] = d_scale_coeffs.qx1y[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s1y[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();
	}

	children =
	{
		{  s0[0],  s0[1],  s0[2],  s0[3] },
		{ s1x[0], s1x[1], s1x[2], s1x[3] },
		{ s1y[0], s1y[1], s1y[2], s1y[3] }
	};

	d_scale_coeffs.qx0[parent_idx]  = encode_scale_0 (children);
	d_scale_coeffs.qx1x[parent_idx] = encode_scale_1x(children);
	d_scale_coeffs.qx1y[parent_idx] = encode_scale_1y(children);

	subdetail = encode_detail(children);

	store_details
	(
		d_details.qx0,
		d_details.qx1x,
		d_details.qx1y,
		subdetail,
		parent_idx
	);

	norm_detail = max(norm_detail, subdetail.get_max() / maxes.qx);

	for (int i = 0; i < 4; i++)
	{
		shared_idx = t_idx + i * num_sig_details;
		child_idx = next_lvl_idx + 4 * (parents[shared_idx / 4] - curr_lvl_idx) + shared_idx % 4;

		shared.coeffs[t_idx] = d_scale_coeffs.qy0[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s0[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		shared.coeffs[t_idx] = d_scale_coeffs.qy1x[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s1x[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();

		shared.coeffs[t_idx] = d_scale_coeffs.qy1y[child_idx];
		__syncthreads();

		for (int j = 0; j < 4; j++) if ((4 * t_idx + j) / num_sig_details == i) s1y[j] = shared.coeffs[4 * t_idx + j - (i * num_sig_details)];
		__syncthreads();
	}

	children =
	{
		{  s0[0],  s0[1],  s0[2],  s0[3] },
		{ s1x[0], s1x[1], s1x[2], s1x[3] },
		{ s1y[0], s1y[1], s1y[2], s1y[3] }
	};

	d_scale_coeffs.qy0[parent_idx]  = encode_scale_0 (children);
	d_scale_coeffs.qy1x[parent_idx] = encode_scale_1x(children);
	d_scale_coeffs.qy1y[parent_idx] = encode_scale_1y(children);

	subdetail = encode_detail(children);

	store_details
	(
		d_details.qy0,
		d_details.qy1x,
		d_details.qy1y,
		subdetail,
		parent_idx
	);

	norm_detail = max(norm_detail, subdetail.get_max() / maxes.qy);

	if (!for_nghbrs)
	{
		d_norm_details[parent_idx] = norm_detail;

		d_sig_details[parent_idx] = (norm_detail >= epsilon_local || d_preflagged_details[parent_idx] == SIGNIFICANT)
			? SIGNIFICANT 
			: INSIGNIFICANT;
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../types/HierarchyIndex.h"
#include "../classes/ScaleCoefficients.h"
#include "../classes/SolverParams.h"
#include "../classes/Details.h"
#include "../classes/Detail.h"
#include "../classes/Maxes.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../classes/ParentScaleCoeffs.h"

#include "../utilities/get_lvl_idx.cuh"
#include "store_details.cuh"
#include "store_scale_coeffs.cuh"
#include "encode_scale_coeffs.cuh"
#include "encode_details.cuh"

__global__
void encode_flow_kernel_mw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
);
#include "encode_flow_kernel_single_block_hw.cuh"

/*
 *
 * This kernel launches every refinement level starting from n = L, using 4^n threads.
 * These threads load the scale coefficients into shared memory.
 * These scale coefficients are the child coefficients of the sub-elements at n - 1.
 * At n - 1, there are 4^(n-1) sub-elements i.e. a quarter compared to 4^n.
 * Hence, after loading the scale coefficients into shared memory, only 4^(n-1) threads are kept.
 * Thereafter, each thread loads four child coefficients from shared memory to encode the parent and detail.
 * A block size that is a multiple of 4 is used to ensure enough child coefficients are loaded.
 * For the block sizes below, there is a refinement level at which only one thread block is launched:
 * 
 * Block size: 64.   Level at which only a single block is launched (LVL_SINGLE_BLOCK): 3.
 * Block size: 256.  Level at which only a single block is launched (LVL_SINGLE_BLOCK): 4.
 * Block size: 1024. Level at which only a single block is launched (LVL_SINGLE_BLOCK): 5.
 * 
 * In this scenario, the kernel is not relaunched, as a single block has enough threads for all subsequent levels.
 * Instead, there is an internal for-loop across levels, which writes the scale coefficients to shared memory.
 * The threads in the next iteration of the loop access the shared memory, which is visible to all threads within a block.
 * 
 */

__global__
void encode_flow_kernel_single_block_hw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;
	
	real norm_detail   = C(0.0);
	real epsilon_local = solver_params.epsilon / ( 1 << (solver_params.L - level) );

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	real tol_q = solver_params.tol_q;

	HierarchyIndex parent_idx = curr_lvl_idx + t_idx;
	HierarchyIndex child_idx  = next_lvl_idx + 4 * t_idx;

	bool is_sig = d_sig_details[parent_idx];

	if (is_sig)
	{
		real* eta = &d_scale_coeffs.eta0[child_idx];
		real* qx = &d_scale_coeffs.qx0[child_idx];
		real* qy = &d_scale_coeffs.qy0[child_idx];

		ChildScaleCoeffsHW child_coeffs =
		{
			{ eta[0], eta[1], eta[2], eta[3] },

			{
				(abs(qx[0]) > tol_q) ? qx[0] : C(0.0),
				(abs(qx[1]) > tol_q) ? qx[1] : C(0.0),
				(abs(qx[2]) > tol_q) ? qx[2] : C(0.0),
				(abs(qx[3]) > tol_q) ? qx[3] : C(0.0)
			},

			{
				(abs(qy[0]) > tol_q) ? qy[0] : C(0.0),
				(abs(qy[1]) > tol_q) ? qy[1] : C(0.0),
				(abs(qy[2]) > tol_q) ? qy[2] : C(0.0),
				(abs(qy[3]) > tol_q) ? qy[3] : C(0.0)
			},

			{ C(0.0), C(0.0), C(0.0), C(0.0) }
		};

		ParentScaleCoeffsHW parent_coeffs = encode_scale_coeffs(child_coeffs);
		DetailHW            detail = encode_details(child_coeffs);

		parent_coeffs.qx *= (abs(parent_coeffs.qx) > tol_q);
		parent_coeffs.qy *= (abs(parent_coeffs.qy) > tol_q);

		norm_detail = detail.get_norm_detail(maxes);

		store_scale_coeffs
		(
			parent_coeffs,
			d_scale_coeffs,
			parent_idx
		);

		store_details
		(
			detail,
			d_details,
			parent_idx
		);

		d_norm_details[parent_idx] = norm_detail;

		d_sig_details[parent_idx] = (norm_detail >= epsilon_local) ? SIGNIFICANT : INSIGNIFICANT;

		if (d_preflagged_details[parent_idx] == SIGNIFICANT) d_sig_details[parent_idx] = SIGNIFICANT;
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../types/HierarchyIndex.h"
#include "../classes/ScaleCoefficients.h"
#include "../classes/SolverParams.h"
#include "../classes/Details.h"
#include "../classes/Detail.h"
#include "../classes/Maxes.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../classes/ParentScaleCoeffs.h"

#include "../utilities/get_lvl_idx.cuh"
#include "store_details.cuh"
#include "store_scale_coeffs.cuh"
#include "encode_scale_coeffs.cuh"
#include "encode_details.cuh"

__global__
void encode_flow_kernel_single_block_hw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
);

__global__
void encode_flow_kernel_single_block
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
);
#include "encode_flow_kernel_single_block_mw.cuh"

/*
 *
 * This kernel launches every refinement level starting from n = L, using 4^n threads.
 * These threads load the scale coefficients into shared memory.
 * These scale coefficients are the child coefficients of the sub-elements at n - 1.
 * At n - 1, there are 4^(n-1) sub-elements i.e. a quarter compared to 4^n.
 * Hence, after loading the scale coefficients into shared memory, only 4^(n-1) threads are kept.
 * Thereafter, each thread loads four child coefficients from shared memory to encode the parent and detail.
 * A block size that is a multiple of 4 is used to ensure enough child coefficients are loaded.
 * For the block sizes below, there is a refinement level at which only one thread block is launched:
 * 
 * Block size: 64.   Level at which only a single block is launched (LVL_SINGLE_BLOCK): 3.
 * Block size: 256.  Level at which only a single block is launched (LVL_SINGLE_BLOCK): 4.
 * Block size: 1024. Level at which only a single block is launched (LVL_SINGLE_BLOCK): 5.
 * 
 * In this scenario, the kernel is not relaunched, as a single block has enough threads for all subsequent levels.
 * Instead, there is an internal for-loop across levels, which writes the scale coefficients to shared memory.
 * The threads in the next iteration of the loop access the shared memory, which is visible to all threads within a block.
 * 
 */

__global__
void encode_flow_kernel_single_block_mw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;
	
	real norm_detail   = C(0.0);
	real epsilon_local = solver_params.epsilon / ( 1 << (solver_params.L - level) );

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	real tol_q = solver_params.tol_q;

	HierarchyIndex parent_idx = curr_lvl_idx + t_idx;
	HierarchyIndex child_idx  = next_lvl_idx + 4 * t_idx;

	bool is_sig = d_sig_details[parent_idx];

	if (is_sig)
	{
		real* eta0 = &d_scale_coeffs.eta0[child_idx];
		real* qx0 = &d_scale_coeffs.qx0[child_idx];
		real* qy0 = &d_scale_coeffs.qy0[child_idx];

		real* eta1x = &d_scale_coeffs.eta1x[child_idx];
		real* qx1x = &d_scale_coeffs.qx1x[child_idx];
		real* qy1x = &d_scale_coeffs.qy1x[child_idx];

		real* eta1y = &d_scale_coeffs.eta1y[child_idx];
		real* qx1y = &d_scale_coeffs.qx1y[child_idx];
		real* qy1y = &d_scale_coeffs.qy1y[child_idx];

		ChildScaleCoeffsMW child_coeffs =
		{
			{
				{  eta0[0],  eta0[1],  eta0[2],  eta0[3] },
				{ eta1x[0], eta1x[1], eta1x[2], eta1x[3] },
				{ eta1y[0], eta1y[1], eta1y[2], eta1y[3] }
			},
			{
				{
					(abs(qx0[0]) > tol_q) ? qx0[0] : C(0.0),
					(abs(qx0[1]) > tol_q) ? qx0[1] : C(0.0),
					(abs(qx0[2]) > tol_q) ? qx0[2] : C(0.0),
					(abs(qx0[3]) > tol_q) ? qx0[3] : C(0.0)
				},
				{
					(abs(qx1x[0]) > tol_q) ? qx1x[0] : C(0.0),
					(abs(qx1x[1]) > tol_q) ? qx1x[1] : C(0.0),
					(abs(qx1x[2]) > tol_q) ? qx1x[2] : C(0.0),
					(abs(qx1x[3]) > tol_q) ? qx1x[3] : C(0.0)
				},
				{
					(abs(qx1y[0]) > tol_q) ? qx1y[0] : C(0.0),
					(abs(qx1y[1]) > tol_q) ? qx1y[1] : C(0.0),
					(abs(qx1y[2]) > tol_q) ? qx1y[2] : C(0.0),
					(abs(qx1y[3]) > tol_q) ? qx1y[3] : C(0.0)
				}
			},
			{
				{
					(abs(qy0[0]) > tol_q) ? qy0[0] : C(0.0),
					(abs(qy0[1]) > tol_q) ? qy0[1] : C(0.0),
					(abs(qy0[2]) > tol_q) ? qy0[2] : C(0.0),
					(abs(qy0[3]) > tol_q) ? qy0[3] : C(0.0)
				},
				{
					(abs(qy1x[0]) > tol_q) ? qy1x[0] : C(0.0),
					(abs(qy1x[1]) > tol_q) ? qy1x[1] : C(0.0),
					(abs(qy1x[2]) > tol_q) ? qy1x[2] : C(0.0),
					(abs(qy1x[3]) > tol_q) ? qy1x[3] : C(0.0)
				},
				{
					(abs(qy1y[0]) > tol_q) ? qy1y[0] : C(0.0),
					(abs(qy1y[1]) > tol_q) ? qy1y[1] : C(0.0),
					(abs(qy1y[2]) > tol_q) ? qy1y[2] : C(0.0),
					(abs(qy1y[3]) > tol_q) ? qy1y[3] : C(0.0)
				}
			},
			{
				{ C(0.0), C(0.0), C(0.0), C(0.0) },
				{ C(0.0), C(0.0), C(0.0), C(0.0) },
				{ C(0.0), C(0.0), C(0.0), C(0.0) }
			}
		};

		ParentScaleCoeffsMW parent_coeffs = encode_scale_coeffs(child_coeffs);
		DetailMW            detail = (!for_nghbrs) ? encode_details(child_coeffs) : DetailMW{};

		parent_coeffs._0.qx *= (abs(parent_coeffs._0.qx) > tol_q);
		parent_coeffs._1x.qx *= (abs(parent_coeffs._1x.qx) > tol_q);
		parent_coeffs._1y.qx *= (abs(parent_coeffs._1y.qx) > tol_q);
		parent_coeffs._0.qy *= (abs(parent_coeffs._0.qy) > tol_q);
		parent_coeffs._1x.qy *= (abs(parent_coeffs._1x.qy) > tol_q);
		parent_coeffs._1y.qy *= (abs(parent_coeffs._1y.qy) > tol_q);

		norm_detail = detail.get_norm_detail(maxes);

		store_scale_coeffs
		(
			parent_coeffs,
			d_scale_coeffs,
			parent_idx
		);

		if (!for_nghbrs)
		{
			store_details
			(
				detail,
				d_details,
				parent_idx
			);
		}
	}

	if (!for_nghbrs)
	{
		d_norm_details[parent_idx] = norm_detail;

		d_sig_details[parent_idx] = (norm_detail >= epsilon_local) ? SIGNIFICANT : INSIGNIFICANT;

		if (d_preflagged_details[parent_idx] == SIGNIFICANT) d_sig_details[parent_idx] = SIGNIFICANT;
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../types/HierarchyIndex.h"
#include "../classes/ScaleCoefficients.h"
#include "../classes/SolverParams.h"
#include "../classes/Details.h"
#include "../classes/Detail.h"
#include "../classes/Maxes.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../classes/ParentScaleCoeffs.h"

#include "../utilities/get_lvl_idx.cuh"
#include "store_details.cuh"
#include "store_scale_coeffs.cuh"
#include "encode_scale_coeffs.cuh"
#include "encode_details.cuh"

__global__
void encode_flow_kernel_single_block_mw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level,
	int               num_threads,
	bool              for_nghbrs
);
#pragma once

#include "../types/real.h"
#include "../classes/ScaleChildren.h"
#include "../mra/Filters.h"

__host__ __device__ __forceinline__
real encode_scale(const ScaleChildrenHW& u)
{
	return C(0.5) * (H0 * (H0 * u.child_0 + H1 * u.child_2) + H1 * (H0 * u.child_1 + H1 * u.child_3));
}

__host__ __device__ __forceinline__
real encode_scale_0(const ScaleChildrenMW& u)
{
	return (HH0_11 * u._0.child_0 + HH0_12 * u._1x.child_0 + HH0_13 * u._1y.child_0 +
		    HH1_11 * u._0.child_2 + HH1_12 * u._1x.child_2 + HH1_13 * u._1y.child_2 +
		    HH2_11 * u._0.child_1 + HH2_12 * u._1x.child_1 + HH2_13 * u._1y.child_1 +
		    HH3_11 * u._0.child_3 + HH3_12 * u._1x.child_3 + HH3_13 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_scale_1x(const ScaleChildrenMW& u)
{
	return (HH0_21 * u._0.child_0 + HH0_22 * u._1x.child_0 + HH0_23 * u._1y.child_0 +
		    HH1_21 * u._0.child_2 + HH1_22 * u._1x.child_2 + HH1_23 * u._1y.child_2 +
		    HH2_21 * u._0.child_1 + HH2_22 * u._1x.child_1 + HH2_23 * u._1y.child_1 +
		    HH3_21 * u._0.child_3 + HH3_22 * u._1x.child_3 + HH3_23 * u._1y.child_3) / C(2.0);
}

__host__ __device__ __forceinline__
real encode_scale_1y(const ScaleChildrenMW& u)
{
	return (HH0_31 * u._0.child_0 + HH0_32 * u._1x.child_0 + HH0_33 * u._1y.child_0 +
		    HH1_31 * u._0.child_2 + HH1_32 * u._1x.child_2 + HH1_33 * u._1y.child_2 +
		    HH2_31 * u._0.child_1 + HH2_32 * u._1x.child_1 + HH2_33 * u._1y.child_1 +
		    HH3_31 * u._0.child_3 + HH3_32 * u._1x.child_3 + HH3_33 * u._1y.child_3) / C(2.0);
}
#pragma once

#include "cuda_runtime.h"

#include "../classes/ChildScaleCoeffs.h"
#include "../classes/ParentScaleCoeffs.h"
#include "encode_scale.cuh"

__device__ __forceinline__
ParentScaleCoeffsHW encode_scale_coeffs(const ChildScaleCoeffsHW& child_coeffs)
{
	return
	{
		encode_scale(child_coeffs.eta),
		encode_scale(child_coeffs.qx),
		encode_scale(child_coeffs.qy),
		encode_scale(child_coeffs.z)
	};
}

__device__ __forceinline__
ParentScaleCoeffsMW encode_scale_coeffs(const ChildScaleCoeffsMW& child_coeffs)
{
	return
	{
		{
			encode_scale_0(child_coeffs.eta),
			encode_scale_0(child_coeffs.qx),
			encode_scale_0(child_coeffs.qy),
			encode_scale_0(child_coeffs.z)
		},
		{
			encode_scale_1x(child_coeffs.eta),
			encode_scale_1x(child_coeffs.qx),
			encode_scale_1x(child_coeffs.qy),
			encode_scale_1x(child_coeffs.z)
		},
		{
			encode_scale_1y(child_coeffs.eta),
			encode_scale_1y(child_coeffs.qx),
			encode_scale_1y(child_coeffs.qy),
			encode_scale_1y(child_coeffs.z)
		}
	};
}
#include "encode_topography_kernel_hw.cuh"

__global__
void encode_topography_kernel_hw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level
)
{
	MortonCode idx = blockIdx.x * blockDim.x + threadIdx.x;
	
	int num_threads = 1 << (2 * level);

	if (idx >= num_threads) return;

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	HierarchyIndex parent_idx = curr_lvl_idx + idx;
	HierarchyIndex child_idx  = next_lvl_idx + 4 * idx;

	real epsilon_local = solver_params.epsilon / ( 1 << (solver_params.L - level) );

	ScaleChildrenHW z_children =
	{
		d_scale_coeffs.z0[child_idx + 0],
		d_scale_coeffs.z0[child_idx + 1],
		d_scale_coeffs.z0[child_idx + 2],
		d_scale_coeffs.z0[child_idx + 3]
	};

	SubDetailHW z_details =
	{
		encode_detail_alpha(z_children),
		encode_detail_beta (z_children),
		encode_detail_gamma(z_children)
	};

	d_details.z0.alpha[parent_idx] = z_details.alpha;
	d_details.z0.beta[parent_idx]  = z_details.beta;
	d_details.z0.gamma[parent_idx] = z_details.gamma;

	d_scale_coeffs.z0[parent_idx] = encode_scale(z_children);

	if ( (z_details.get_max() / maxes.z) >= epsilon_local ) d_preflagged_details[parent_idx] = SIGNIFICANT;
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../utilities/get_lvl_idx.cuh"
#include "../types/MortonCode.h"
#include "../types/Coordinate.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"
#include "../classes/Maxes.h"
#include "store_details.cuh"
#include "store_scale_coeffs.cuh"
#include "encode_scale_coeffs.cuh"
#include "encode_details.cuh"
#include "../zorder/compact.cuh"
#include "../zorder/generate_morton_code.cuh"

__global__ 
void encode_topography_kernel_hw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level
);
#include "encode_topography_kernel_mw.cuh"

__global__
void encode_topography_kernel_mw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level
)
{
	MortonCode idx = blockIdx.x * blockDim.x + threadIdx.x;
	
	int num_threads = 1 << (2 * level);

	if (idx >= num_threads) return;

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	HierarchyIndex parent_idx = curr_lvl_idx + idx;
	HierarchyIndex child_idx  = next_lvl_idx + 4 * idx;

	real epsilon_local = solver_params.epsilon / ( 1 << (solver_params.L - level) );

	real* z0  = &d_scale_coeffs.z0 [child_idx + 0];
	real* z1x = &d_scale_coeffs.z1x[child_idx + 0];
	real* z1y = &d_scale_coeffs.z1y[child_idx + 0];
	
	ScaleChildrenMW z_children =
	{
		{  z0[0],  z0[1],  z0[2],  z0[3] },
		{ z1x[0], z1x[1], z1x[2], z1x[3] },
		{ z1y[0], z1y[1], z1y[2], z1y[3] }
	};
	
	d_scale_coeffs.z0[parent_idx]  = encode_scale_0 (z_children);
	d_scale_coeffs.z1x[parent_idx] = encode_scale_1x(z_children);
	d_scale_coeffs.z1y[parent_idx] = encode_scale_1y(z_children);

	SubDetailMW z_details = encode_detail(z_children);

	d_details.z0.alpha[parent_idx]  = z_details._0.alpha;
	d_details.z0.beta[parent_idx]   = z_details._0.beta;
	d_details.z0.gamma[parent_idx]  = z_details._0.gamma;
	d_details.z1x.alpha[parent_idx] = z_details._1x.alpha;
	d_details.z1x.beta[parent_idx]  = z_details._1x.beta;
	d_details.z1x.gamma[parent_idx] = z_details._1x.gamma;
	d_details.z1y.alpha[parent_idx] = z_details._1y.alpha;
	d_details.z1y.beta[parent_idx]  = z_details._1y.beta;
	d_details.z1y.gamma[parent_idx] = z_details._1y.gamma;

	if ( (z_details.get_max() / maxes.z) >= epsilon_local ) d_preflagged_details[parent_idx] = SIGNIFICANT;
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../utilities/get_lvl_idx.cuh"
#include "../types/MortonCode.h"
#include "../types/Coordinate.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"
#include "../classes/Maxes.h"
#include "store_details.cuh"
#include "store_scale_coeffs.cuh"
#include "encode_scale_coeffs.cuh"
#include "encode_details.cuh"
#include "../zorder/compact.cuh"
#include "../zorder/generate_morton_code.cuh"

__global__
void encode_topography_kernel_mw
(
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	bool*             d_preflagged_details,
	Maxes             maxes,
	SolverParams      solver_params,
	int               level
);
#include "extra_significance.cuh"

template<bool SINGLE_BLOCK>
__global__
void extra_significance
(
	bool*            d_sig_details,
	real*            d_norm_details,
	SolverParams solver_params,
	int              level,
	int              num_threads
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= num_threads) return;

	if (SINGLE_BLOCK)
	{
		for (int lvl = 0; lvl < LVL_SINGLE_BLOCK; lvl++)
		{
			HierarchyIndex curr_lvl_idx_block = get_lvl_idx(lvl);
			HierarchyIndex next_lvl_idx_block = get_lvl_idx(lvl + 1);
			int            num_threads_block  = 1 << (2 * lvl);

			if (idx < num_threads_block)
			{
				HierarchyIndex parent_idx = curr_lvl_idx_block + idx;
				HierarchyIndex child_idx  = next_lvl_idx_block + 4 * idx;

				bool is_sig = d_sig_details[parent_idx];

				real norm_detail = d_norm_details[parent_idx];

				real eps_local_block     = solver_params.epsilon / ( 1 << (solver_params.L - lvl) );
				real eps_extra_sig_block = eps_local_block * pow(C(2.0), M_BAR + 1);

				bool is_extra_sig = (norm_detail >= eps_extra_sig_block);

				if (is_sig && is_extra_sig)
				{
					d_sig_details[child_idx + 0] = SIGNIFICANT;
					d_sig_details[child_idx + 1] = SIGNIFICANT;
					d_sig_details[child_idx + 2] = SIGNIFICANT;
					d_sig_details[child_idx + 3] = SIGNIFICANT;
				}
			}

			__syncthreads();
		}
	}
	else
	{
		HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
		HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);
		
		HierarchyIndex parent_idx = curr_lvl_idx + idx;

		real eps_local     = solver_params.epsilon / (1 << (solver_params.L - level));
		real eps_extra_sig = eps_local * pow(C(2.0), M_BAR + 1);

		bool sig_detail  = d_sig_details[parent_idx];
		real norm_detail = d_norm_details[parent_idx];

		bool is_extra_sig = (norm_detail >= eps_extra_sig);

		if ( !(sig_detail && is_extra_sig) ) return;

		HierarchyIndex child_idx = next_lvl_idx + 4 * idx;

		d_sig_details[child_idx + 0] = SIGNIFICANT;
		d_sig_details[child_idx + 1] = SIGNIFICANT;
		d_sig_details[child_idx + 2] = SIGNIFICANT;
		d_sig_details[child_idx + 3] = SIGNIFICANT;
	}
}

inline void dummy_template_instantiator
(
	bool*            d_sig_details,
	real*            d_norm_details,
	SolverParams solver_params,
	int              level,
	int              num_threads
)
{
	extra_significance<false><<<1,1>>>(d_sig_details, d_norm_details, solver_params, level, num_threads);
	extra_significance<true> <<<1,1>>>(d_sig_details, d_norm_details, solver_params, level, num_threads);
}
#pragma once

#ifndef M_BAR
	#define M_BAR C(1.5)
#endif // !M_BAR


#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../classes/SolverParams.h"
#include "../types/HierarchyIndex.h"

#include "../utilities/get_lvl_idx.cuh"

template<bool SINGLE_BLOCK>
__global__
void extra_significance
(
	bool*            d_sig_details,
	real*            d_norm_details,
	SolverParams solver_params,
	int              level,
	int              num_threads
);
#pragma once

#include "../types/real.h"

#define H0  C(1.0) / sqrt( C(2.0) )
#define H1  C(1.0) / sqrt( C(2.0) )
#define G0  C(1.0) / sqrt( C(2.0) )
#define G1 -C(1.0) / sqrt( C(2.0) )

#define HH0_11 ( C(1.0) / C(2.0) ) 
#define HH0_12 ( C(0.0) )
#define HH0_13 ( C(0.0) )

#define HH0_21 ( -sqrt( C(3.0) ) / C(4.0) ) 
#define HH0_22 ( C(1.0) / C(4.0) ) 
#define HH0_23 ( C(0.0) )

#define HH0_31 ( -sqrt( C(3.0) ) / C(4.0) ) 
#define HH0_32 ( C(0.0) ) 
#define HH0_33 ( C(1.0) / C(4.0) ) 

#define HH1_11 ( C(1.0) / C(2.0) ) 
#define HH1_12 ( C(0.0) )
#define HH1_13 ( C(0.0) )

#define HH1_21 ( -sqrt( C(3.0) ) / C(4.0) ) 
#define HH1_22 ( C(1.0) / C(4.0) ) 
#define HH1_23 ( C(0.0) )

#define HH1_31 ( sqrt( C(3.0) ) / C(4.0) ) 
#define HH1_32 ( C(0.0) ) 
#define HH1_33 ( C(1.0) / C(4.0) ) 

#define HH2_11 ( C(1.0) / C(2.0) ) 
#define HH2_12 ( C(0.0) )
#define HH2_13 ( C(0.0) )

#define HH2_21 ( sqrt( C(3.0) ) / C(4.0) ) 
#define HH2_22 ( C(1.0) / C(4.0) ) 
#define HH2_23 ( C(0.0) )

#define HH2_31 ( -sqrt( C(3.0) ) / C(4.0) ) 
#define HH2_32 ( C(0.0) ) 
#define HH2_33 ( C(1.0) / C(4.0) ) 

#define HH3_11 ( C(1.0) / C(2.0) ) 
#define HH3_12 ( C(0.0) )
#define HH3_13 ( C(0.0) )

#define HH3_21 ( sqrt( C(3.0) ) / C(4.0) ) 
#define HH3_22 ( C(1.0) / C(4.0) ) 
#define HH3_23 ( C(0.0) )

#define HH3_31 ( sqrt( C(3.0) ) / C(4.0) ) 
#define HH3_32 ( C(0.0) ) 
#define HH3_33 ( C(1.0) / C(4.0) ) 

#define GA0_11 ( -sqrt( C(14.0) ) / C(14.0) )
#define GA0_12 ( -sqrt( C(42.0) ) / C(14.0) )
#define GA0_13 ( -sqrt( C(42.0) ) / C(14.0) )

#define GA0_21 ( C(0.0) ) 
#define GA0_22 ( C(0.0) )
#define GA0_23 ( -sqrt( C(2.0) ) / C(2.0) )

#define GA0_31 ( C(0.0) )
#define GA0_32 ( -sqrt( C(2.0) ) / C(2.0) )
#define GA0_33 ( C(0.0) )

#define GA1_11 ( C(0.0) ) 
#define GA1_12 ( C(0.0) ) 
#define GA1_13 ( C(0.0) ) 

#define GA1_21 ( C(0.0) ) 
#define GA1_22 ( C(0.0) )
#define GA1_23 ( C(0.0) ) 

#define GA1_31 ( C(0.0) )
#define GA1_32 ( C(0.0) ) 
#define GA1_33 ( C(0.0) )

#define GA2_11 ( C(0.0) ) 
#define GA2_12 ( C(0.0) ) 
#define GA2_13 ( C(0.0) ) 

#define GA2_21 ( C(0.0) ) 
#define GA2_22 ( C(0.0) )
#define GA2_23 ( C(0.0) ) 

#define GA2_31 ( C(0.0) )
#define GA2_32 ( C(0.0) ) 
#define GA2_33 ( C(0.0) )

#define GA3_11 ( sqrt( C(14.0) ) / C(14.0) )
#define GA3_12 ( -sqrt( C(42.0) ) / C(14.0) )
#define GA3_13 ( -sqrt( C(42.0) ) / C(14.0) )

#define GA3_21 ( C(0.0) ) 
#define GA3_22 ( C(0.0) )
#define GA3_23 ( sqrt( C(2.0) ) / C(2.0) )

#define GA3_31 ( C(0.0) )
#define GA3_32 ( sqrt( C(2.0) ) / C(2.0) )
#define GA3_33 ( C(0.0) )

#define GB0_11 ( C(0.0) ) 
#define GB0_12 ( C(0.0) ) 
#define GB0_13 ( C(0.0) ) 

#define GB0_21 ( C(0.0) ) 
#define GB0_22 ( C(0.0) )
#define GB0_23 ( C(0.0) ) 

#define GB0_31 ( C(0.0) )
#define GB0_32 ( C(0.0) ) 
#define GB0_33 ( C(0.0) )

#define GB1_11 ( -sqrt( C(14.0) ) / C(14.0) )
#define GB1_12 ( -sqrt( C(42.0) ) / C(14.0) )
#define GB1_13 ( sqrt( C(42.0) ) / C(14.0) )

#define GB1_21 ( C(0.0) ) 
#define GB1_22 ( C(0.0) )
#define GB1_23 ( -sqrt( C(2.0) ) / C(2.0) )

#define GB1_31 ( C(0.0) )
#define GB1_32 ( -sqrt( C(2.0) ) / C(2.0) )
#define GB1_33 ( C(0.0) )

#define GB2_11 ( sqrt( C(14.0) ) / C(14.0) )
#define GB2_12 ( -sqrt( C(42.0) ) / C(14.0) )
#define GB2_13 ( sqrt( C(42.0) ) / C(14.0) )

#define GB2_21 ( C(0.0) ) 
#define GB2_22 ( C(0.0) )
#define GB2_23 ( sqrt( C(2.0) ) / C(2.0) )

#define GB2_31 ( C(0.0) )
#define GB2_32 ( sqrt( C(2.0) ) / C(2.0) )
#define GB2_33 ( C(0.0) )

#define GB3_11 ( C(0.0) ) 
#define GB3_12 ( C(0.0) ) 
#define GB3_13 ( C(0.0) ) 

#define GB3_21 ( C(0.0) ) 
#define GB3_22 ( C(0.0) )
#define GB3_23 ( C(0.0) ) 

#define GB3_31 ( C(0.0) )
#define GB3_32 ( C(0.0) ) 
#define GB3_33 ( C(0.0) )

#define GC0_11 ( C(1.0) / C(2.0) ) 
#define GC0_12 ( C(0.0) ) 
#define GC0_13 ( C(0.0) ) 

#define GC0_21 ( -sqrt( C(21.0) ) / C(28.0) )
#define GC0_22 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )
#define GC0_23 ( C(2.0) * sqrt( C(7.0) ) / C(14.0) )

#define GC0_31 ( -sqrt( C(21.0) ) / C(28.0) )
#define GC0_32 ( C(2.0) * sqrt( C(7.0) ) / C(14.0) )
#define GC0_33 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )

#define GC1_11 ( -C(1.0) / C(2.0) ) 
#define GC1_12 ( C(0.0) ) 
#define GC1_13 ( C(0.0) ) 

#define GC1_21 ( -sqrt( C(21.0) ) / C(28.0) )
#define GC1_22 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )
#define GC1_23 ( -C(2.0) * sqrt( C(7.0) ) / C(14.0) )

#define GC1_31 ( sqrt( C(21.0) ) / C(28.0) )
#define GC1_32 ( -C(2.0) * sqrt( C(7.0) ) / C(14.0) )
#define GC1_33 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )

#define GC2_11 ( -C(1.0) / C(2.0) ) 
#define GC2_12 ( C(0.0) ) 
#define GC2_13 ( C(0.0) ) 

#define GC2_21 ( sqrt( C(21.0) ) / C(28.0) )
#define GC2_22 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )
#define GC2_23 ( -C(2.0) * sqrt( C(7.0) ) / C(14.0) )

#define GC2_31 ( -sqrt( C(21.0) ) / C(28.0) )
#define GC2_32 ( -C(2.0) * sqrt( C(7.0) ) / C(14.0) )
#define GC2_33 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )

#define GC3_11 ( C(1.0) / C(2.0) ) 
#define GC3_12 ( C(0.0) ) 
#define GC3_13 ( C(0.0) ) 

#define GC3_21 ( sqrt( C(21.0) ) / C(28.0) )
#define GC3_22 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )
#define GC3_23 ( C(2.0) * sqrt( C(7.0) ) / C(14.0) )

#define GC3_31 ( sqrt( C(21.0) ) / C(28.0) )
#define GC3_32 ( C(2.0) * sqrt( C(7.0) ) / C(14.0) )
#define GC3_33 ( -C(3.0) * sqrt( C(7.0) ) / C(28.0) )
#pragma once

#include "cuda_runtime.h"

#include "../classes/DetailChildren.h"

__device__ __forceinline__
DetailChildren get_child_details
(
	bool* shared_child_details,
	int   t_idx
)
{
	DetailChildren child_details =
	{
		shared_child_details[t_idx + 0], // detail_0
		shared_child_details[t_idx + 1], // detail_1
		shared_child_details[t_idx + 2], // detail_2
		shared_child_details[t_idx + 3]  // detail_3
	};

	return child_details;
}
#include "get_max_scale_coeffs.cuh"

__host__
Maxes get_max_scale_coeffs
(
	AssembledSolution& d_assem_sol,
	real*&             d_eta_temp
)
{
	Maxes maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	
	int num_blocks = get_num_blocks(d_assem_sol.length, THREADS_PER_BLOCK);
	
	init_eta_temp<<<num_blocks, THREADS_PER_BLOCK>>>
	(
		d_assem_sol, 
		d_eta_temp
	);

	maxes.eta = max( C(1.0), get_max_from_array(d_eta_temp,      d_assem_sol.length) );
	maxes.h   = max( C(1.0), get_max_from_array(d_assem_sol.h0,  d_assem_sol.length) );
	maxes.qx  = max( C(1.0), get_max_from_array(d_assem_sol.qx0, d_assem_sol.length) );
	maxes.qy  = max( C(1.0), get_max_from_array(d_assem_sol.qx0, d_assem_sol.length) );
	maxes.z   = max( C(1.0), get_max_from_array(d_assem_sol.z0,  d_assem_sol.length) );

	return maxes;
}
#pragma once

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../classes/AssembledSolution.h"
#include "../classes/Maxes.h"

#include "../utilities/get_num_blocks.h"
#include "../utilities/get_max_from_array.cuh"

#include "../mra/init_eta_temp.cuh"

__host__
Maxes get_max_scale_coeffs
(
	AssembledSolution& d_assem_sol,
	real*&             d_eta_temp
);
#include "get_modal_values.cuh"

__host__
void get_modal_values
(
	NodalValues&       d_nodal_vals,
	AssembledSolution& d_assem_sol,
	SolverParams&      solver_params,
	SimulationParams&  sim_params,
	const int&         mesh_dim,
	const int&         interface_dim,
	const int&         test_case,
	const char*        input_filename
)
{
	if (test_case != 0) // synthetic test cases
	{
		const int num_blocks = get_num_blocks(d_assem_sol.length, THREADS_PER_BLOCK);

		modal_projections<<<num_blocks, THREADS_PER_BLOCK>>>
		(
			d_nodal_vals,
			d_assem_sol,
			solver_params,
			mesh_dim,
			interface_dim
		);
	}
	else // use raster information
	{		
		if (solver_params.solver_type == HWFV1)
		{
			read_and_project_modes_fv1
			(
				input_filename,
				d_assem_sol,
				mesh_dim,
				solver_params
			);
		}
		else if (solver_params.solver_type == MWDG2)
		{
			read_and_project_modes_dg2
			(
				input_filename,
				d_assem_sol,
				d_nodal_vals,
				sim_params,
				solver_params,
				mesh_dim
			);
		}
	}
}
#pragma once

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../utilities/cuda_utils.cuh"

#include "../utilities/get_lvl_idx.cuh"
#include "../input/read_and_project_modes_fv1.cuh"
#include "../input/read_and_project_modes_dg2.cuh"

__host__
void get_modal_values
(
	NodalValues&          d_nodal_vals,
	AssembledSolution&    d_assem_sol,
	SolverParams&     solver_params,
	SimulationParams& sim_params,
	const int&            mesh_dim,
	const int&            interface_dim,
	const int&            test_case,
	const char*           input_filename
);
#include "get_nodal_values.cuh"

__host__ void get_nodal_values
(
	NodalValues&                d_nodal_vals,
	const real&                 dx_finest,
	const real&                 dy_finest,
	const Depths1D&             bcs,
	const SimulationParams& sim_params,
	const int&                  interface_dim,
	const int&                  test_case
)
{
	// number of nodes
	int num_elements = interface_dim * interface_dim;
	int num_blocks   = get_num_blocks(num_elements, THREADS_PER_BLOCK);

	init_nodal_values<<<num_blocks, THREADS_PER_BLOCK>>>
	(
		d_nodal_vals,
		dx_finest,
		dy_finest,
		bcs,
		sim_params,
		interface_dim,
		test_case
	);
}
#pragma once

#include "cuda_runtime.h"

#include "../utilities/cuda_utils.cuh"
#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../classes/SimulationParams.h"

#include "../utilities/get_num_blocks.h"
#include "init_nodal_values.cuh"

__host__ void get_nodal_values
(
	NodalValues&                d_nodal_vals,
	const real&                 dx_finest,
	const real&                 dy_finest,
	const Depths1D&             bcs,
	const SimulationParams& sim_params,
	const int&                  interface_dim,
	const int&                  test_case
);
#include "get_reg_tree.cuh"

__host__
void get_reg_tree
(
	bool*            d_sig_details,
	SolverParams solver_params
)
{
	for (int level = solver_params.L - 1; level > LVL_SINGLE_BLOCK; level--)
	{		
		int num_threads  = 1 << (2 * level);
		int num_blocks = get_num_blocks(num_threads, THREADS_PER_BLOCK);

		regularisation<false><<<num_blocks, THREADS_PER_BLOCK>>>
		(
			d_sig_details,
			level,
			num_threads
		);
	}

	HierarchyIndex prev_lvl_idx = get_lvl_idx(LVL_SINGLE_BLOCK - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(LVL_SINGLE_BLOCK);
	HierarchyIndex next_lvl_idx = get_lvl_idx(LVL_SINGLE_BLOCK + 1);
    
	int num_threads  = 1 << (2 * LVL_SINGLE_BLOCK);

	regularisation<true><<<1, THREADS_PER_BLOCK>>>
	(
		d_sig_details,
		LVL_SINGLE_BLOCK,
		num_threads
	);
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../types/HierarchyIndex.h"
#include "../classes/SolverParams.h"

#include "../utilities/get_num_blocks.h"

#include "regularisation.cuh"

__host__
void get_reg_tree
(
	bool*        d_sig_details,
	SolverParams solver_params
);
#include "../mra/init_eta_temp.cuh"

__global__
void init_eta_temp
(
	AssembledSolution d_assem_sol,
	real*             d_eta_temp
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= d_assem_sol.length) return;

	d_eta_temp[idx] = d_assem_sol.h0[idx] + d_assem_sol.z0[idx];
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/AssembledSolution.h"

__global__
void init_eta_temp
(
	AssembledSolution d_assem_sol,
	real*             d_eta_temp
);
#include "init_nodal_values.cuh"

/*
 * FLATTENED ARRAY RATIONALE:
 *
 * 1D arrays emulating 2D arrays are used to hold the flow variables at the finest resolution.
 * These 1D arrays are obtained by 'flattening' a 2D array.
 * The following is an example of a 2D array of dimensions 3x3, that uses 'row-major indexing':
 *
 * ---|---|---
 * -0-|-1-|-2-
 * ---|---|---
 * -3-|-4-|-5-
 * ---|---|---
 * -6-|-7-|-8-
 * ---|---|---
 *
 * It can be flattened into a 1D array of length 3x3 = 9:
 *
 * ---|---|---|---|---|---|---|---|---
 * -0-|-1-|-2-|-3-|-4-|-5-|-6-|-7-|-8-
 * ---|---|---|---|---|---|---|---|---
 *
 * As example, consider a 2D array that has 'num_cols' columns flattened into a 1D array.
 * To access the nth element of the the mth row, an index for the 1D array needs to be obtained.
 * This index = (m - 1) * num_cols + (n - 1), -1 since indexing starts from zero.
 * The reverse process can also be done i.e. finding the row and column given the 1D index and the num_cols:
 * - row number    = index / num_cols
 * - column number = index % num_cols
 */

__global__
void init_nodal_values
(
	NodalValues          d_nodal_vals,
	real                 dx_finest,
	real                 dy_finest,
	Depths1D             bcs,
	SimulationParams sim_params,
	int                  interface_dim,
	int                  test_case
)
{
	HierarchyIndex idx = blockDim.x * blockIdx.x + threadIdx.x;

	if ( idx >= (interface_dim * interface_dim) ) return;

	// obtaining 2D indices from the 'flattened' index (here 'idx')
	Coordinate x_idx = idx % interface_dim;
	Coordinate y_idx = idx / interface_dim;

	// calculating x- and y-nodal values
	const real x_int = sim_params.xmin + dx_finest * x_idx;
	const real y_int = sim_params.ymin + dy_finest * y_idx;

	real& z_int = d_nodal_vals.z[idx];

	z_int = topo
	(
		x_int, 
		y_int, 
		test_case
	);

	d_nodal_vals.h[idx] = h_init
	(
		x_int, 
		y_int, 
		z_int, 
		bcs, 
		test_case
	);

	d_nodal_vals.qx[idx] = 0;
	d_nodal_vals.qy[idx] = 0;
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/Depths1D.h"
#include "../classes/SimulationParams.h"
#include "../classes/NodalValues.h"
#include "../types/HierarchyIndex.h"
#include "../types/Coordinate.h"

#include "../synthetic/h_init.cuh"
#include "../synthetic/topo.cuh"

// initialise nodal values of h, qx, qy and z depending on x, y nodal values
__global__
void init_nodal_values
(
	NodalValues          d_nodal_vals,
	real                 dx_finest,
	real                 dy_finest,
	Depths1D             bcs,
	SimulationParams sim_params,
	int                  interface_dim,
	int                  test_case
);
#include "init_sig_details.cuh"

__global__
void init_sig_details
(
	bool* d_sig_details,
	int   num_details
)
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= num_details) return;

	d_sig_details[idx] = true;
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

__global__
void init_sig_details
(
	bool* d_sig_details, 
	int   num_details
);
#include "insert_point_srcs.cuh"

__global__
void insert_point_srcs
(
	AssembledSolution d_assem_sol,
	PointSources      point_sources,
	real              dt,
	real              dx_finest
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= point_sources.num_srcs) return;

	HierarchyIndex h_idx = point_sources.d_codes[idx];

	int src_type = point_sources.d_src_types[idx];

	if (src_type == HFIX || src_type == HVAR)
	{
		d_assem_sol.h0[h_idx] = point_sources.d_srcs[idx] - d_assem_sol.z0[idx];
	}
	else if (src_type == QFIX || src_type == QVAR)
	{
		d_assem_sol.h0[h_idx] += point_sources.q_src(dt, dx_finest, idx);
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/AssembledSolution.h"
#include "../classes/PointSources.h"

#include "../utilities/get_lvl_idx.cuh"

__global__
void insert_point_srcs
(
	AssembledSolution d_assem_sol,
	PointSources      point_sources,
	real              dt,
	real              dx_finest
);
#pragma once

#include "cuda_runtime.h"

#include "../classes/Detail.h"
#include "../classes/Details.h"
#include "../types/HierarchyIndex.h"

__device__ __forceinline__ DetailHW load_details_hw
(
	const Details&  d_details,
	const HierarchyIndex& h_idx
)
{
	return
	{
		{
			d_details.eta0.alpha[h_idx],
			d_details.eta0.beta[h_idx],
			d_details.eta0.gamma[h_idx]
		},
		{
			d_details.qx0.alpha[h_idx],
			d_details.qx0.beta[h_idx],
			d_details.qx0.gamma[h_idx]
		},
		{
			d_details.qy0.alpha[h_idx],
			d_details.qy0.beta[h_idx],
			d_details.qy0.gamma[h_idx]
		},
		{
			d_details.z0.alpha[h_idx],
			d_details.z0.beta[h_idx],
			d_details.z0.gamma[h_idx]
		}
	};
}

__device__ __forceinline__ DetailMW load_details_mw
(
	const Details&  d_details,
	const HierarchyIndex& h_idx
)
{
	return
	{
		{
			{
				d_details.eta0.alpha[h_idx],
				d_details.eta0.beta[h_idx],
				d_details.eta0.gamma[h_idx]
			},
			{
				d_details.eta1x.alpha[h_idx],
				d_details.eta1x.beta[h_idx],
				d_details.eta1x.gamma[h_idx]
			},
			{
				d_details.eta1y.alpha[h_idx],
				d_details.eta1y.beta[h_idx],
				d_details.eta1y.gamma[h_idx]
			}
		},
		{
			{
				d_details.qx0.alpha[h_idx],
				d_details.qx0.beta[h_idx],
				d_details.qx0.gamma[h_idx]
			},
			{
				d_details.qx1x.alpha[h_idx],
				d_details.qx1x.beta[h_idx],
				d_details.qx1x.gamma[h_idx]
			},
			{
				d_details.qx1y.alpha[h_idx],
				d_details.qx1y.beta[h_idx],
				d_details.qx1y.gamma[h_idx]
			}
		},
		{
			{
				d_details.qy0.alpha[h_idx],
				d_details.qy0.beta[h_idx],
				d_details.qy0.gamma[h_idx]
			},
			{
				d_details.qy1x.alpha[h_idx],
				d_details.qy1x.beta[h_idx],
				d_details.qy1x.gamma[h_idx]
			},
			{
				d_details.qy1y.alpha[h_idx],
				d_details.qy1y.beta[h_idx],
				d_details.qy1y.gamma[h_idx]
			}
		},
		{
			{
				d_details.z0.alpha[h_idx],
				d_details.z0.beta[h_idx],
				d_details.z0.gamma[h_idx]
			},
			{
				d_details.z1x.alpha[h_idx],
				d_details.z1x.beta[h_idx],
				d_details.z1x.gamma[h_idx]
			},
			{
				d_details.z1y.alpha[h_idx],
				d_details.z1y.beta[h_idx],
				d_details.z1y.gamma[h_idx]
			}
		}
	};
}
#pragma once

#include "cuda_runtime.h"

#include "../classes/ScaleCoefficients.h"
#include "../classes/ParentScaleCoeffs.h"

__device__ __forceinline__ ParentScaleCoeffsHW load_parent_scale_coefficients
(
	ScaleCoefficients& d_scale_coeffs,
	int&               h_idx
)
{
	ParentScaleCoeffsHW parent_coeffs =
	{
		d_scale_coeffs.eta0[h_idx],
		d_scale_coeffs.qx0[h_idx],
		d_scale_coeffs.qy0[h_idx],
		d_scale_coeffs.z0[h_idx]
	};

	return parent_coeffs;
}
#pragma once

#include "cuda_runtime.h"

#include "../classes/ScaleCoefficients.h"
#include "../classes/ParentScaleCoeffs.h"

__device__ __forceinline__
ParentScaleCoeffsHW load_parent_scale_coeffs_hw
(
	ScaleCoefficients& d_scale_coeffs,
	int&               h_idx
)
{
	return
	{
		d_scale_coeffs.eta0[h_idx],
		d_scale_coeffs.qx0[h_idx],
		d_scale_coeffs.qy0[h_idx],
		d_scale_coeffs.z0[h_idx]
	};
}

__device__ __forceinline__ 
ParentScaleCoeffsMW load_parent_scale_coeffs_mw
(
	ScaleCoefficients& d_scale_coeffs,
	int&               h_idx
)
{
	return
	{
		{
			d_scale_coeffs.eta0[h_idx],
			d_scale_coeffs.qx0[h_idx],
			d_scale_coeffs.qy0[h_idx],
			d_scale_coeffs.z0[h_idx]
		},
		{
			d_scale_coeffs.eta1x[h_idx],
			d_scale_coeffs.qx1x[h_idx],
			d_scale_coeffs.qy1x[h_idx],
			d_scale_coeffs.z1x[h_idx]
		},
		{
			d_scale_coeffs.eta1y[h_idx],
			d_scale_coeffs.qx1y[h_idx],
			d_scale_coeffs.qy1y[h_idx],
			d_scale_coeffs.z1y[h_idx]
		}
	};
}
#include "../mra/modal_projections.cuh"

/*
 * SQUARE SHARED MEMORY BLOCKS:
 * 
 * The modal projections are done using a kernel that uses square blocks of shared memory.
 * Only square blocks fit neatly into the square mesh (diagram below), and also minimse global memory accesses.
 *
 * -----|-----|-----|-----
 * -0,0-|-0,1-|-0,2-|-0,3-
 * -----|-----|-----|-----
 * -1,0-|-1,1-|-1,2-|-1,3-
 * -----|-----|-----|-----
 * -2,0-|-2,1-|-2,2-|-2,3-
 * -----|-----|-----|-----
 * -3,0-|-3,1-|-3,2-|-3,3-
 * -----|-----|-----|-----
 *
 * For example, (1,2) is the 3rd block in the 2nd row of blocks.
 * Each square block must be emulated using a 1D array, as done previously (grep 'FLATTENED ARRAY RATIONALE').
 * Since square blocks are used, the number of threads must be a square number i.e. 64, 256 or 1024.
 * The square root of this number is the side length of the emulated square block, #defined as 'SHARED_MEMORY_BLOCK_DIM'.
 * There can be (mesh_dim / SHARED_MEMORY_BLOCK_DIM) blocks per row.
 * This number and the side length are equal since the mesh and block of shared memory are both square.
 * Hence, it is stored as 'shared_memory_blocks_per_side'.
 */

__global__
void modal_projections
(
	NodalValues       d_nodal_vals,
	AssembledSolution d_assem_sol,
	SolverParams  solver_params,
	int               mesh_dim,
	int               interface_dim
)
{
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockDim.x * blockIdx.x + t_idx;
	
	if ( idx >= d_assem_sol.length ) return;

	Coordinate x = idx % mesh_dim;
	Coordinate y = idx / mesh_dim;

	HierarchyIndex SW =  y      * interface_dim + x;
	HierarchyIndex SE =  y      * interface_dim + x + 1;
	HierarchyIndex NW = (y + 1) * interface_dim + x;
	HierarchyIndex NE = (y + 1) * interface_dim + x + 1;

	real h_SW = d_nodal_vals.h[SW];
	real h_SE = d_nodal_vals.h[SE];
	real h_NW = d_nodal_vals.h[NW];
	real h_NE = d_nodal_vals.h[NE];

	real qx_SW = d_nodal_vals.qx[SW];
	real qx_SE = d_nodal_vals.qx[SE];
	real qx_NW = d_nodal_vals.qx[NW];
	real qx_NE = d_nodal_vals.qx[NE];

	real qy_SW = d_nodal_vals.qy[SW];
	real qy_SE = d_nodal_vals.qy[SE];
	real qy_NW = d_nodal_vals.qy[NW];
	real qy_NE = d_nodal_vals.qy[NE];

	real z_SW = d_nodal_vals.z[SW];
	real z_SE = d_nodal_vals.z[SE];
	real z_NW = d_nodal_vals.z[NW];
	real z_NE = d_nodal_vals.z[NE];

	d_assem_sol.h0[idx]  = C(0.25) * (h_NW  + h_NE  + h_SE  + h_SW );
	d_assem_sol.qx0[idx] = C(0.25) * (qx_NW + qx_NE + qx_SE + qx_SW);
	d_assem_sol.qy0[idx] = C(0.25) * (qy_NW + qy_NE + qy_SE + qy_SW);
	d_assem_sol.z0[idx]  = C(0.25) * (z_NW  + z_NE  + z_SE  + z_SW );

	if (solver_params.solver_type == MWDG2)
	{
		d_assem_sol.h1x[idx]  = (h_NE  - h_NW  + h_SE  - h_SW ) / ( C(4.0) * sqrt( C(3.0) ) );
		d_assem_sol.qx1x[idx] = (qx_NE - qx_NW + qx_SE - qx_SW) / ( C(4.0) * sqrt( C(3.0) ) );
		d_assem_sol.qy1x[idx] = (qy_NE - qy_NW + qy_SE - qy_SW) / ( C(4.0) * sqrt( C(3.0) ) );
		d_assem_sol.z1x[idx]  = (z_NE  - z_NW  + z_SE  - z_SW ) / ( C(4.0) * sqrt( C(3.0) ) );

		d_assem_sol.h1y[idx]  = (h_NE  - h_SE  + h_NW  - h_SW ) / ( C(4.0) * sqrt( C(3.0) ) );
		d_assem_sol.qx1y[idx] = (qx_NE - qx_SE + qx_NW - qx_SW) / ( C(4.0) * sqrt( C(3.0) ) );
		d_assem_sol.qy1y[idx] = (qy_NE - qy_SE + qy_NW - qy_SW) / ( C(4.0) * sqrt( C(3.0) ) );
		d_assem_sol.z1y[idx]  = (z_NE  - z_SE  + z_NW  - z_SW ) / ( C(4.0) * sqrt( C(3.0) ) );
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../classes/NodalValues.h"
#include "../types/HierarchyIndex.h"
#include "../types/Coordinate.h"
#include "../classes/AssembledSolution.h"
#include "../classes/SolverParams.h"

__global__
void modal_projections
(
	NodalValues       d_nodal_vals,
	AssembledSolution d_assem_sol,
	SolverParams  solver_params,
	int               mesh_dim,
	int               interface_dim
);
#include "preflag_details.cuh"

__host__
bool* preflag_details
(
	const Boundaries&        boundaries,
	const PointSources&      point_sources,
	const StagePoints&       stage_points,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const int&               num_details,
	const int&               max_ref_lvl,
	const int&               test_case
)
{
	size_t bytes = num_details * sizeof(bool);
	
	bool* h_preflagged_details = new bool[num_details]();

	bool* d_preflagged_details = (bool*)malloc_device(bytes);

	HierarchyIndex starting_idx = get_lvl_idx(max_ref_lvl - 1);

	for (int i = 0; i < stage_points.num_points; i++)
	{
		MortonCode child_idx = stage_points.codes[i] / 4; // to get Morton code one level below

		h_preflagged_details[starting_idx + child_idx] = true;
	}

	if (nullptr != boundaries.north.codes)
	{
		for (int i = 0; i < boundaries.north.num_cells(); i++)
		{
			MortonCode child_idx = boundaries.north.codes[i] / 4;

			h_preflagged_details[starting_idx + child_idx] = true;
		}
	}

	if (nullptr != boundaries.east.codes)
	{
		for (int i = 0; i < boundaries.east.num_cells(); i++)
		{
			MortonCode child_idx = boundaries.east.codes[i] / 4;

			h_preflagged_details[starting_idx + child_idx] = true;
		}
	}

	if (nullptr != boundaries.south.codes)
	{
		for (int i = 0; i < boundaries.south.num_cells(); i++)
		{
			MortonCode child_idx = boundaries.south.codes[i] / 4;

			h_preflagged_details[starting_idx + child_idx] = true;
		}
	}

	if (nullptr != boundaries.west.codes)
	{
		for (int i = 0; i < boundaries.west.num_cells(); i++)
		{
			MortonCode child_idx = boundaries.west.codes[i] / 4;

			h_preflagged_details[starting_idx + child_idx] = true;
		}
	}

	for (int i = 0; i < point_sources.num_srcs; i++)
	{
		MortonCode child_idx = point_sources.h_codes[i] / 4;

		h_preflagged_details[starting_idx + child_idx] = true;
	}

	if (test_case == 0 && solver_params.refine_wall)
	{
		refine_high_wall
		(
			sim_params,
			solver_params,
			max_ref_lvl,
			h_preflagged_details
		);
	}

	copy_cuda(d_preflagged_details, h_preflagged_details, bytes);

	delete[] h_preflagged_details;

	return d_preflagged_details;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../classes/Boundaries.h"
#include "../classes/PointSources.h"
#include "../classes/StagePoints.h"
#include "../classes/SimulationParams.h"
#include "../classes/SolverParams.h"

#include "../utilities/get_lvl_idx.cuh"
#include "refine_high_wall.cuh"

__host__
bool* preflag_details
(
	const Boundaries&        boundaries,
	const PointSources&      point_sources,
	const StagePoints&       stage_points,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const int&               num_details,
	const int&               max_ref_lvl,
	const int&               test_case
);
#include "preflag_topo.cuh"

__host__
void preflag_topo
(
	ScaleCoefficients& d_scale_coeffs,
	Details&           d_details,
	bool*              d_preflagged_details,
	Maxes&             maxes, 
	SolverParams&      solver_params
)
{
	for (int level = solver_params.L - 1; level >= 0; level--)
	{	
		int num_threads = 1 << (2 * level);
		int num_blocks  = get_num_blocks(num_threads, THREADS_PER_BLOCK);

		if (solver_params.solver_type == HWFV1)
		{
			encode_topography_kernel_hw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_scale_coeffs,
				d_details,
				d_preflagged_details,
				maxes,
				solver_params,
				level
			);
		}
		else if (solver_params.solver_type == MWDG2)
		{
			encode_topography_kernel_mw<<<num_blocks, THREADS_PER_BLOCK>>>
			(
				d_scale_coeffs,
				d_details,
				d_preflagged_details,
				maxes,
				solver_params,
				level
			);
		}
	}
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../classes/SolverParams.h"
#include "../utilities/get_num_blocks.h"
#include "../types/HierarchyIndex.h"

#include "encode_topography_kernel_hw.cuh"
#include "encode_topography_kernel_mw.cuh"

__host__
void preflag_topo
(
	ScaleCoefficients& d_scale_coeffs,
	Details&           d_details,
	bool*              d_preflagged_details,
	Maxes&             maxes, 
	SolverParams&      solver_params
);
#include "refine_high_wall.cuh"

__host__
void refine_high_wall
(
	const SimulationParams& sim_params,
	const SolverParams&     solver_params,
	const int               max_ref_lvl,
	      bool*             h_preflagged_details
)
{
	const int refinement_thickness = solver_params.ref_thickness;

	const int num_refined_cells_x = refinement_thickness * sim_params.xsz;
	const int num_refined_cells_y = refinement_thickness * sim_params.ysz;
	const int num_refined_cells   = num_refined_cells_x + num_refined_cells_y;

	MortonCode* refined_high_wall_codes = new MortonCode[num_refined_cells];

	Coordinate x_max = sim_params.xsz - 1;
	Coordinate y_max = sim_params.ysz - 1;

	// refining the northern wall
	for (int j = 0; j < refinement_thickness; j++)
	{
		for (int i = 0; i < sim_params.xsz; i++)
		{
			Coordinate x = i;
			Coordinate y = y_max - j;

			refined_high_wall_codes[j * sim_params.xsz + i] = generate_morton_code(x, y);
		}
	}

	// refining the eastern wall
	for (int j = 0; j < refinement_thickness; j++)
	{
		for (int i = 0; i < sim_params.ysz; i++)
		{
			Coordinate x = x_max - j;
			Coordinate y = i;

			refined_high_wall_codes[num_refined_cells_x + j * sim_params.ysz + i] = generate_morton_code(x, y);
		}
	}

	HierarchyIndex starting_idx = get_lvl_idx(max_ref_lvl - 1);

	for (int i = 0; i < num_refined_cells; i++)
	{
		MortonCode child_idx = refined_high_wall_codes[i] / 4; // to get Morton code one level below

		h_preflagged_details[starting_idx + child_idx] = true;
	}

	delete[] refined_high_wall_codes;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../classes/SimulationParams.h"
#include "../classes/SolverParams.h"

#include "../zorder/generate_morton_code.cuh"
#include "../utilities/get_lvl_idx.cuh"

__host__
void refine_high_wall
(
	const SimulationParams& sim_params,
	const SolverParams&     solver_params,
	const int               max_ref_lvl,
	      bool*             h_preflagged_details
);
#include "regularisation.cuh"

template <bool SINGLE_BLOCK>
__global__
void regularisation
(
	bool*          d_sig_details,
	int            level,
	int            num_threads
)
{
	__shared__ bool shared_sig_details[THREADS_PER_BLOCK];
	
	DetailChildren child_details;

	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	if (SINGLE_BLOCK)
	{
		HierarchyIndex parent_idx;
		HierarchyIndex child_idx = curr_lvl_idx + t_idx;
		
		shared_sig_details[t_idx] = d_sig_details[child_idx];

		__syncthreads();
		
		for (int lvl = LVL_SINGLE_BLOCK - 1; lvl >= 0; lvl--)
		{
			HierarchyIndex curr_lvl_idx_block = get_lvl_idx(lvl);
			int            num_threads        = 1 << (2 * lvl);

			parent_idx = curr_lvl_idx_block + t_idx;

			if (t_idx < num_threads)
			{
				child_details = get_child_details
				(
					shared_sig_details,
					4 * t_idx
				);
			}

			__syncthreads();

			if (t_idx < num_threads)
			{
				if (child_details.has_sig_detail()) d_sig_details[parent_idx] = SIGNIFICANT;

				shared_sig_details[t_idx] = child_details.has_sig_detail();
			}

			__syncthreads();
		}
	}
	else
	{
		HierarchyIndex h_idx = curr_lvl_idx + idx;

		shared_sig_details[t_idx] = d_sig_details[h_idx];

		__syncthreads();
		
		if ( t_idx >= (THREADS_PER_BLOCK / 4) ) return;

		HierarchyIndex t_idx_shifted = 4 * t_idx;
				 h_idx         = prev_lvl_idx + t_idx + blockIdx.x * (THREADS_PER_BLOCK / 4);

		child_details = get_child_details
		(
			shared_sig_details,
			t_idx_shifted
		);

		if ( child_details.has_sig_detail() ) d_sig_details[h_idx] = SIGNIFICANT;
	}	
}

inline void dummy_template_instantiator
(
	bool*    d_sig_details,
	int      level,
	int      num_threads
)
{
	regularisation<true><<<1, 1>>>
	(
		d_sig_details, 
		level,
		num_threads
	);

	regularisation<false><<<1, 1>>>
	(
		d_sig_details,
		level,
		num_threads
	);
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../types/real.h"
#include "../classes/DetailChildren.h"
#include "../types/HierarchyIndex.h"

#include "get_child_details.cuh"
#include "../utilities/get_lvl_idx.cuh"

template <bool SINGLE_BLOCK>
__global__ void regularisation
(
	bool*    d_sig_details,
	int      level,
	int      num_threads
);
#include "regularisation_kernel.cuh"

template <bool SINGLE_BLOCK>
__global__
void regularisation_kernel
(
	bool*          d_sig_details,
	int            level,
	int            num_threads
)
{
	__shared__ bool shared_sig_details[THREADS_PER_BLOCK];
	
	DetailChildren child_details;

	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	if (SINGLE_BLOCK)
	{
		HierarchyIndex parent_idx;
		HierarchyIndex child_idx = curr_lvl_idx + t_idx;
		
		shared_sig_details[t_idx] = d_sig_details[child_idx];

		__syncthreads();
		
		for (int lvl = LVL_SINGLE_BLOCK - 1; lvl >= 0; lvl--)
		{
			HierarchyIndex curr_lvl_idx_block = get_lvl_idx(lvl);
			int            num_threads        = 1 << (2 * lvl);

			parent_idx = curr_lvl_idx_block + t_idx;

			if (t_idx < num_threads)
			{
				child_details = get_child_details
				(
					shared_sig_details,
					4 * t_idx
				);
			}

			__syncthreads();

			if (t_idx < num_threads)
			{
				if (child_details.has_sig_detail()) d_sig_details[parent_idx] = SIGNIFICANT;

				shared_sig_details[t_idx] = child_details.has_sig_detail();
			}

			__syncthreads();
		}
	}
	else
	{
		HierarchyIndex h_idx = curr_lvl_idx + idx;

		shared_sig_details[t_idx] = d_sig_details[h_idx];

		__syncthreads();
		
		if ( t_idx >= (THREADS_PER_BLOCK / 4) ) return;

		HierarchyIndex t_idx_shifted = 4 * t_idx;
				 h_idx         = prev_lvl_idx + t_idx + blockIdx.x * (THREADS_PER_BLOCK / 4);

		child_details = get_child_details
		(
			shared_sig_details,
			t_idx_shifted
		);

		if ( child_details.has_sig_detail() ) d_sig_details[h_idx] = SIGNIFICANT;
	}	
}

inline void dummy_template_instantiator
(
	bool*    d_sig_details,
	int      level,
	int      num_threads
)
{
	regularisation_kernel<true><<<1, 1>>>
	(
		d_sig_details, 
		level,
		num_threads
	);

	regularisation_kernel<false><<<1, 1>>>
	(
		d_sig_details,
		level,
		num_threads
	);
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../types/real.h"
#include "../classes/DetailChildren.h"
#include "../types/HierarchyIndex.h"

#include "get_child_details.cuh"
#include "../utilities/get_lvl_idx.cuh"

__global__
void regularisation_kernel
(
	bool*    d_sig_details,
	int      level,
	int      num_threads
);
#include "regularisation_kernel.cuh"

template <bool SINGLE_BLOCK>
__global__
void regularisation_kernel
(
	bool*          d_sig_details,
	int            level,
	int            num_threads
)
{
	__shared__ bool shared_sig_details[THREADS_PER_BLOCK];
	
	DetailChildren child_details;

	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	if (idx >= num_threads) return;

	HierarchyIndex prev_lvl_idx = get_lvl_idx(level - 1);
	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);
	HierarchyIndex next_lvl_idx = get_lvl_idx(level + 1);

	if (SINGLE_BLOCK)
	{
		HierarchyIndex parent_idx;
		HierarchyIndex child_idx = curr_lvl_idx + t_idx;
		
		shared_sig_details[t_idx] = d_sig_details[child_idx];

		__syncthreads();
		
		for (int lvl = LVL_SINGLE_BLOCK - 1; lvl >= 0; lvl--)
		{
			HierarchyIndex curr_lvl_idx_block = get_lvl_idx(lvl);
			int            num_threads        = 1 << (2 * lvl);

			parent_idx = curr_lvl_idx_block + t_idx;

			if (t_idx < num_threads)
			{
				child_details = get_child_details
				(
					shared_sig_details,
					4 * t_idx
				);
			}

			__syncthreads();

			if (t_idx < num_threads)
			{
				if (child_details.has_sig_detail()) d_sig_details[parent_idx] = SIGNIFICANT;

				shared_sig_details[t_idx] = child_details.has_sig_detail();
			}

			__syncthreads();
		}
	}
	else
	{
		HierarchyIndex h_idx = curr_lvl_idx + idx;

		shared_sig_details[t_idx] = d_sig_details[h_idx];

		__syncthreads();
		
		if ( t_idx >= (THREADS_PER_BLOCK / 4) ) return;

		HierarchyIndex t_idx_shifted = 4 * t_idx;
				 h_idx         = prev_lvl_idx + t_idx + blockIdx.x * (THREADS_PER_BLOCK / 4);

		child_details = get_child_details
		(
			shared_sig_details,
			t_idx_shifted
		);

		if ( child_details.has_sig_detail() ) d_sig_details[h_idx] = SIGNIFICANT;
	}	
}

inline void dummy_template_instantiator
(
	bool*    d_sig_details,
	int      level,
	int      num_threads
)
{
	regularisation_kernel<true><<<1, 1>>>
	(
		d_sig_details, 
		level,
		num_threads
	);

	regularisation_kernel<false><<<1, 1>>>
	(
		d_sig_details,
		level,
		num_threads
	);
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../types/real.h"
#include "../classes/DetailChildren.h"
#include "../types/HierarchyIndex.h"

#include "get_child_details.cuh"
#include "../utilities/get_lvl_idx.cuh"

template <bool SINGLE_BLOCK>
__global__ void regularisation_kernel
(
	bool*    d_sig_details,
	int      level,
	int      num_threads
);
#include "../mra/reinsert_assem_sol.cuh"

__global__
void reinsert_assem_sol
(
	AssembledSolution d_assem_sol,
	HierarchyIndex*   act_idcs,
	ScaleCoefficients d_scale_coeffs,
	SolverParams  solver_params
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= d_assem_sol.length) return;

	HierarchyIndex active_idx = act_idcs[idx];

	d_scale_coeffs.eta0[active_idx] = d_assem_sol.h0[idx] + d_assem_sol.z0[idx];
	d_scale_coeffs.qx0[active_idx]  = d_assem_sol.qx0[idx];
	d_scale_coeffs.qy0[active_idx]  = d_assem_sol.qy0[idx];
	
	if (solver_params.solver_type == MWDG2)
	{
		d_scale_coeffs.eta1x[active_idx] = d_assem_sol.h1x[idx] + d_assem_sol.z1x[idx];
		d_scale_coeffs.qx1x[active_idx]  = d_assem_sol.qx1x[idx];
		d_scale_coeffs.qy1x[active_idx]  = d_assem_sol.qy1x[idx];
		
		d_scale_coeffs.eta1y[active_idx] = d_assem_sol.h1y[idx] + d_assem_sol.z1y[idx];
		d_scale_coeffs.qx1y[active_idx]  = d_assem_sol.qx1y[idx];
		d_scale_coeffs.qy1y[active_idx]  = d_assem_sol.qy1y[idx];
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/ScaleCoefficients.h"
#include "../classes/AssembledSolution.h"
#include "../classes/SolverParams.h"

__global__
void reinsert_assem_sol
(
	AssembledSolution d_assem_sol,
	HierarchyIndex*   act_idcs, 
	ScaleCoefficients d_scale_coeffs,
	SolverParams  solver_params
);
#include "reinsert_point_srcs.cuh"

__global__
void reinsert_point_srcs
(
	ScaleCoefficients d_scale_coeffs,
	PointSources      point_sources,
	real              dt,
	real              dx_finest,
	int               max_ref_lvl
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= point_sources.num_srcs) return;

	HierarchyIndex h_idx = get_lvl_idx(max_ref_lvl) + point_sources.d_codes[idx];

	int src_type = point_sources.d_src_types[idx];

	if (src_type == HFIX || src_type == HVAR)
	{
		d_scale_coeffs.eta0[h_idx] = point_sources.d_srcs[idx];
	}
	else if (src_type == QFIX || src_type == QVAR)
	{
		d_scale_coeffs.eta0[h_idx] += point_sources.q_src(dt, dx_finest, idx);
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/ScaleCoefficients.h"
#include "../classes/PointSources.h"

#include "../utilities/get_lvl_idx.cuh"

__global__
void reinsert_point_srcs
(
	ScaleCoefficients d_scale_coeffs,
	PointSources      point_sources,
	real              dt,
	real              dx_finest,
	int               max_ref_lvl
);
#pragma once

#include "cuda_runtime.h"

#include "../classes/Detail.h"
#include "../classes/Details.h"
#include "../classes/ScaleChildren.h"

#include "encode_details.cuh"

__device__ __forceinline__
void store_details
(
	const DetailHW& detail, 
	const Details&  d_details, 
	const int&      h_idx
)
{
	d_details.eta0.alpha[h_idx] = detail.eta.alpha;
	d_details.eta0.beta[h_idx]  = detail.eta.beta;
	d_details.eta0.gamma[h_idx] = detail.eta.gamma;

	d_details.qx0.alpha[h_idx]  = detail.qx.alpha;
	d_details.qx0.beta[h_idx]   = detail.qx.beta;
	d_details.qx0.gamma[h_idx]  = detail.qx.gamma;
	
	d_details.qy0.alpha[h_idx]  = detail.qy.alpha;
	d_details.qy0.beta[h_idx]   = detail.qy.beta;
	d_details.qy0.gamma[h_idx]  = detail.qy.gamma;
	
}

__device__ __forceinline__
void store_details
(
	const DetailMW& detail, 
	const Details&  d_details, 
	const int&      h_idx
)
{
	d_details.eta0.alpha[h_idx] = detail.eta._0.alpha;
	d_details.eta0.beta[h_idx]  = detail.eta._0.beta;
	d_details.eta0.gamma[h_idx] = detail.eta._0.gamma;
	
	d_details.eta1x.alpha[h_idx] = detail.eta._1x.alpha;
	d_details.eta1x.beta[h_idx]  = detail.eta._1x.beta;
	d_details.eta1x.gamma[h_idx] = detail.eta._1x.gamma;
	
	d_details.eta1y.alpha[h_idx] = detail.eta._1y.alpha;
	d_details.eta1y.beta[h_idx]  = detail.eta._1y.beta;
	d_details.eta1y.gamma[h_idx] = detail.eta._1y.gamma;

	d_details.qx0.alpha[h_idx] = detail.qx._0.alpha;
	d_details.qx0.beta[h_idx]  = detail.qx._0.beta;
	d_details.qx0.gamma[h_idx] = detail.qx._0.gamma;
	
	d_details.qx1x.alpha[h_idx] = detail.qx._1x.alpha;
	d_details.qx1x.beta[h_idx]  = detail.qx._1x.beta;
	d_details.qx1x.gamma[h_idx] = detail.qx._1x.gamma;
	
	d_details.qx1y.alpha[h_idx] = detail.qx._1y.alpha;
	d_details.qx1y.beta[h_idx]  = detail.qx._1y.beta;
	d_details.qx1y.gamma[h_idx] = detail.qx._1y.gamma;

	d_details.qy0.alpha[h_idx] = detail.qy._0.alpha;
	d_details.qy0.beta[h_idx]  = detail.qy._0.beta;
	d_details.qy0.gamma[h_idx] = detail.qy._0.gamma;
	
	d_details.qy1x.alpha[h_idx] = detail.qy._1x.alpha;
	d_details.qy1x.beta[h_idx]  = detail.qy._1x.beta;
	d_details.qy1x.gamma[h_idx] = detail.qy._1x.gamma;

	d_details.qy1y.alpha[h_idx] = detail.qy._1y.alpha;
	d_details.qy1y.beta[h_idx]  = detail.qy._1y.beta;
	d_details.qy1y.gamma[h_idx] = detail.qy._1y.gamma;
	/*
	d_details.z0.alpha[h_idx] = detail.z._0.alpha;
	d_details.z0.beta[h_idx]  = detail.z._0.beta;
	d_details.z0.gamma[h_idx] = detail.z._0.gamma;
	
	d_details.z1x.alpha[h_idx] = detail.z._1x.alpha;
	d_details.z1x.beta[h_idx]  = detail.z._1x.beta;
	d_details.z1x.gamma[h_idx] = detail.z._1x.gamma;

	d_details.z1y.alpha[h_idx] = detail.z._1y.alpha;
	d_details.z1y.beta[h_idx]  = detail.z._1y.beta;
	d_details.z1y.gamma[h_idx] = detail.z._1y.gamma;
	*/
}

__device__ __forceinline__
void store_details
(
	const SubDetails&     _0,
	const SubDetails&     _1x,
	const SubDetails&     _1y,
	const SubDetailMW&    subdetail,
	const HierarchyIndex& parent_idx
)
{
	_0.alpha [parent_idx] = subdetail._0.alpha;
	_0.beta  [parent_idx] = subdetail._0.beta;
	_0.gamma [parent_idx] = subdetail._0.gamma;
	_1x.alpha[parent_idx] = subdetail._1x.alpha;
	_1x.beta [parent_idx] = subdetail._1x.beta;
	_1x.gamma[parent_idx] = subdetail._1x.gamma;
	_1y.alpha[parent_idx] = subdetail._1y.alpha;
	_1y.beta [parent_idx] = subdetail._1y.beta;
	_1y.gamma[parent_idx] = subdetail._1y.gamma;
}
#pragma once

#include "cuda_runtime.h"

#include <cstdio>

#include "../classes/ParentScaleCoeffs.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../classes/ScaleCoefficients.h"
#include "index_1D.h"

__device__ __forceinline__ void store_scale_coefficients
(
	const ParentScaleCoeffsHW& parent_coeffs, 
	const ScaleCoefficients&   d_scale_coeffs,
	const index_1D&            h_idx
)
{
	d_scale_coeffs.eta0[h_idx] = parent_coeffs.eta;
	d_scale_coeffs.qx0[h_idx]  = parent_coeffs.qx;
	d_scale_coeffs.qy0[h_idx]  = parent_coeffs.qy;
}

__device__ __forceinline__ void store_scale_coefficients
(
	const ParentScaleCoeffsMW& parent_coeffs,
	const ScaleCoefficients&   d_scale_coeffs,
	const index_1D& h_idx
)
{
	d_scale_coeffs.eta0[h_idx] = parent_coeffs._0.eta;
	d_scale_coeffs.qx0[h_idx]  = parent_coeffs._0.qx;
	d_scale_coeffs.qy0[h_idx]  = parent_coeffs._0.qy;
	
	d_scale_coeffs.eta1x[h_idx] = parent_coeffs._1x.eta;
	d_scale_coeffs.qx1x[h_idx]  = parent_coeffs._1x.qx;
	d_scale_coeffs.qy1x[h_idx]  = parent_coeffs._1x.qy;

	d_scale_coeffs.eta1y[h_idx] = parent_coeffs._1y.eta;
	d_scale_coeffs.qx1y[h_idx]  = parent_coeffs._1y.qx;
	d_scale_coeffs.qy1y[h_idx]  = parent_coeffs._1y.qy;
}

__device__ __forceinline__ void store_scale_coefficients
(
	const ChildScaleCoeffsHW& child_coeffs, 
	const ScaleCoefficients&  d_scale_coeffs,
	const index_1D&           h_idx
)
{
	d_scale_coeffs.eta0[h_idx + 0] = child_coeffs.eta.child_0;
	d_scale_coeffs.eta0[h_idx + 1] = child_coeffs.eta.child_1;
	d_scale_coeffs.eta0[h_idx + 2] = child_coeffs.eta.child_2;
	d_scale_coeffs.eta0[h_idx + 3] = child_coeffs.eta.child_3;

	d_scale_coeffs.qx0[h_idx + 0]  = child_coeffs.qx.child_0;
	d_scale_coeffs.qx0[h_idx + 1]  = child_coeffs.qx.child_1;
	d_scale_coeffs.qx0[h_idx + 2]  = child_coeffs.qx.child_2;
	d_scale_coeffs.qx0[h_idx + 3]  = child_coeffs.qx.child_3;

	d_scale_coeffs.qy0[h_idx + 0]  = child_coeffs.qy.child_0;
	d_scale_coeffs.qy0[h_idx + 1]  = child_coeffs.qy.child_1;
	d_scale_coeffs.qy0[h_idx + 2]  = child_coeffs.qy.child_2;
	d_scale_coeffs.qy0[h_idx + 3]  = child_coeffs.qy.child_3;

	/*d_scale_coeffs.z0[h_idx + 0]   = child_coeffs.z.child_0;
	d_scale_coeffs.z0[h_idx + 1]   = child_coeffs.z.child_1;
	d_scale_coeffs.z0[h_idx + 2]   = child_coeffs.z.child_2;
	d_scale_coeffs.z0[h_idx + 3]   = child_coeffs.z.child_3;*/
}
#pragma once

#include "cuda_runtime.h"

#include "../classes/ParentScaleCoeffs.h"
#include "../classes/ChildScaleCoeffs.h"
#include "../classes/ScaleCoefficients.h"
#include "../types/HierarchyIndex.h"

__device__ __forceinline__
void store_scale_coeffs
(
	const ParentScaleCoeffsHW& parent_coeffs, 
	const ScaleCoefficients&   d_scale_coeffs,
	const HierarchyIndex&      h_idx
)
{
	d_scale_coeffs.eta0[h_idx] = parent_coeffs.eta;
	d_scale_coeffs.qx0[h_idx]  = parent_coeffs.qx;
	d_scale_coeffs.qy0[h_idx]  = parent_coeffs.qy;
}

__device__ __forceinline__
void store_scale_coeffs
(
	const ParentScaleCoeffsMW& parent_coeffs,
	const ScaleCoefficients&   d_scale_coeffs,
	const HierarchyIndex&      h_idx
)
{
	d_scale_coeffs.eta0[h_idx] = parent_coeffs._0.eta;
	d_scale_coeffs.qx0[h_idx]  = parent_coeffs._0.qx;
	d_scale_coeffs.qy0[h_idx]  = parent_coeffs._0.qy;
	
	d_scale_coeffs.eta1x[h_idx] = parent_coeffs._1x.eta;
	d_scale_coeffs.qx1x[h_idx]  = parent_coeffs._1x.qx;
	d_scale_coeffs.qy1x[h_idx]  = parent_coeffs._1x.qy;

	d_scale_coeffs.eta1y[h_idx] = parent_coeffs._1y.eta;
	d_scale_coeffs.qx1y[h_idx]  = parent_coeffs._1y.qx;
	d_scale_coeffs.qy1y[h_idx]  = parent_coeffs._1y.qy;
}

__device__ __forceinline__
void store_scale_coeffs
(
	const ChildScaleCoeffsHW& child_coeffs, 
	const ScaleCoefficients&  d_scale_coeffs,
	const HierarchyIndex&     h_idx
)
{
	d_scale_coeffs.eta0[h_idx + 0] = child_coeffs.eta.child_0;
	d_scale_coeffs.eta0[h_idx + 1] = child_coeffs.eta.child_1;
	d_scale_coeffs.eta0[h_idx + 2] = child_coeffs.eta.child_2;
	d_scale_coeffs.eta0[h_idx + 3] = child_coeffs.eta.child_3;

	d_scale_coeffs.qx0[h_idx + 0]  = child_coeffs.qx.child_0;
	d_scale_coeffs.qx0[h_idx + 1]  = child_coeffs.qx.child_1;
	d_scale_coeffs.qx0[h_idx + 2]  = child_coeffs.qx.child_2;
	d_scale_coeffs.qx0[h_idx + 3]  = child_coeffs.qx.child_3;

	d_scale_coeffs.qy0[h_idx + 0]  = child_coeffs.qy.child_0;
	d_scale_coeffs.qy0[h_idx + 1]  = child_coeffs.qy.child_1;
	d_scale_coeffs.qy0[h_idx + 2]  = child_coeffs.qy.child_2;
	d_scale_coeffs.qy0[h_idx + 3]  = child_coeffs.qy.child_3;

	/*d_scale_coeffs.z0[h_idx + 0]   = child_coeffs.z.child_0;
	d_scale_coeffs.z0[h_idx + 1]   = child_coeffs.z.child_1;
	d_scale_coeffs.z0[h_idx + 2]   = child_coeffs.z.child_2;
	d_scale_coeffs.z0[h_idx + 3]   = child_coeffs.z.child_3;*/
}

__device__ __forceinline__
void store_scale_coeffs
(
	const ChildScaleCoeffsMW& child_coeffs, 
	const ScaleCoefficients&  d_scale_coeffs,
	const HierarchyIndex&     h_idx
)
{
	d_scale_coeffs.eta0[h_idx + 0] = child_coeffs.eta._0.child_0;
	d_scale_coeffs.eta0[h_idx + 1] = child_coeffs.eta._0.child_1;
	d_scale_coeffs.eta0[h_idx + 2] = child_coeffs.eta._0.child_2;
	d_scale_coeffs.eta0[h_idx + 3] = child_coeffs.eta._0.child_3;
	
	d_scale_coeffs.qx0[h_idx + 0] = child_coeffs.qx._0.child_0;
	d_scale_coeffs.qx0[h_idx + 1] = child_coeffs.qx._0.child_1;
	d_scale_coeffs.qx0[h_idx + 2] = child_coeffs.qx._0.child_2;
	d_scale_coeffs.qx0[h_idx + 3] = child_coeffs.qx._0.child_3;

	d_scale_coeffs.qy0[h_idx + 0] = child_coeffs.qy._0.child_0;
	d_scale_coeffs.qy0[h_idx + 1] = child_coeffs.qy._0.child_1;
	d_scale_coeffs.qy0[h_idx + 2] = child_coeffs.qy._0.child_2;
	d_scale_coeffs.qy0[h_idx + 3] = child_coeffs.qy._0.child_3;

	d_scale_coeffs.eta1x[h_idx + 0] = child_coeffs.eta._1x.child_0;
	d_scale_coeffs.eta1x[h_idx + 1] = child_coeffs.eta._1x.child_1;
	d_scale_coeffs.eta1x[h_idx + 2] = child_coeffs.eta._1x.child_2;
	d_scale_coeffs.eta1x[h_idx + 3] = child_coeffs.eta._1x.child_3;

	d_scale_coeffs.qx1x[h_idx + 0] = child_coeffs.qx._1x.child_0;
	d_scale_coeffs.qx1x[h_idx + 1] = child_coeffs.qx._1x.child_1;
	d_scale_coeffs.qx1x[h_idx + 2] = child_coeffs.qx._1x.child_2;
	d_scale_coeffs.qx1x[h_idx + 3] = child_coeffs.qx._1x.child_3;

	d_scale_coeffs.qy1x[h_idx + 0] = child_coeffs.qy._1x.child_0;
	d_scale_coeffs.qy1x[h_idx + 1] = child_coeffs.qy._1x.child_1;
	d_scale_coeffs.qy1x[h_idx + 2] = child_coeffs.qy._1x.child_2;
	d_scale_coeffs.qy1x[h_idx + 3] = child_coeffs.qy._1x.child_3;

	d_scale_coeffs.eta1y[h_idx + 0] = child_coeffs.eta._1y.child_0;
	d_scale_coeffs.eta1y[h_idx + 1] = child_coeffs.eta._1y.child_1;
	d_scale_coeffs.eta1y[h_idx + 2] = child_coeffs.eta._1y.child_2;
	d_scale_coeffs.eta1y[h_idx + 3] = child_coeffs.eta._1y.child_3;

	d_scale_coeffs.qx1y[h_idx + 0] = child_coeffs.qx._1y.child_0;
	d_scale_coeffs.qx1y[h_idx + 1] = child_coeffs.qx._1y.child_1;
	d_scale_coeffs.qx1y[h_idx + 2] = child_coeffs.qx._1y.child_2;
	d_scale_coeffs.qx1y[h_idx + 3] = child_coeffs.qx._1y.child_3;

	d_scale_coeffs.qy1y[h_idx + 0] = child_coeffs.qy._1y.child_0;
	d_scale_coeffs.qy1y[h_idx + 1] = child_coeffs.qy._1y.child_1;
	d_scale_coeffs.qy1y[h_idx + 2] = child_coeffs.qy._1y.child_2;
	d_scale_coeffs.qy1y[h_idx + 3] = child_coeffs.qy._1y.child_3;
}
#include "../mra/traverse_tree_of_sig_details.cuh"

__global__
void traverse_tree_of_sig_details
(
	bool*             d_sig_details,
	ScaleCoefficients d_scale_coeffs,
	AssembledSolution d_buf_assem_sol,
	int               num_threads,
	SolverParams      solver_params
)
{	
	__shared__ union
	{
		int            levels [4 * THREADS_PER_BLOCK];
		HierarchyIndex indices[4 * THREADS_PER_BLOCK];

	} shared;
	
	int            levels[4];
	HierarchyIndex indices[4];

	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	int block_store_step = 3 * blockIdx.x * THREADS_PER_BLOCK;

	if (idx >= num_threads) return;

	HierarchyIndex h_idx = 0;

	MortonCode curr_code = 0;
	MortonCode fine_code = 4 * idx;

	int level = 0;

	HierarchyIndex curr_lvl_idx = get_lvl_idx(level);

	bool keep_on_traversing = true;

	while (keep_on_traversing)
	{
		MortonCode curr_code = ( fine_code >> ( 2 * (solver_params.L - level) ) );

		curr_lvl_idx = get_lvl_idx(level);

		h_idx = curr_lvl_idx + curr_code;

		bool is_sig = d_sig_details[h_idx];

		if (!is_sig)
		{
			// recording z-order index and level
			for (int i = 0; i < 4; i++)
			{
				indices[i] = h_idx;
				levels[i]  = level;
			}

			keep_on_traversing = false;
		}
		else
		{
			level++;
			
			bool penultimate_level = (level == solver_params.L);

			if (!penultimate_level)
			{
				keep_on_traversing = true;
			}
			else
			{
				HierarchyIndex next_lvl_idx = get_lvl_idx(level);
				HierarchyIndex child_idx    = next_lvl_idx + 4 * curr_code;

				// recording z-order index and level
				for (int i = 0; i < 4; i++)
				{
					indices[i] = child_idx + i;
					levels[i]  = level;
				}

				keep_on_traversing = false;
			}
		}
	}
	
	// storing active indices
	for (int i = 0; i < 4; i++) shared.indices[4 * t_idx + i] = indices[i];
	__syncthreads();

	for (int i = 0; i < 4; i++) d_buf_assem_sol.act_idcs[idx + i * THREADS_PER_BLOCK + block_store_step] = shared.indices[t_idx + i * THREADS_PER_BLOCK];
	__syncthreads();

	// storing levels
	for (int i = 0; i < 4; i++) shared.levels[4 * t_idx + i] = levels[i];
	__syncthreads();

	for (int i = 0; i < 4; i++) d_buf_assem_sol.levels[idx + i * THREADS_PER_BLOCK + block_store_step] = shared.levels[t_idx + i * THREADS_PER_BLOCK];
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_store.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../utilities/get_lvl_idx.cuh"

#include "../types/HierarchyIndex.h"
#include "../types/MortonCode.h"
#include "../classes/AssembledSolution.h"
#include "../classes/SolverParams.h"
#include "../classes/ScaleCoefficients.h"

__global__
void traverse_tree_of_sig_details
(
	bool*             d_sig_details,
	ScaleCoefficients d_scale_coeffs,
	AssembledSolution d_buf_assem_sol,
	int               num_threads,
	SolverParams      solver_params
);
#include "zero_details.cuh"

__global__
void zero_details
(
	Details          d_details,
	real*            d_norm_details,
	int              num_details,
	SolverParams solver_params
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= num_details) return;

	d_details.eta0.alpha[idx] = C(0.0);
	d_details.eta0.beta[idx]  = C(0.0);
	d_details.eta0.gamma[idx] = C(0.0);

	d_details.qx0.alpha[idx]  = C(0.0);
	d_details.qx0.beta[idx]   = C(0.0);
	d_details.qx0.gamma[idx]  = C(0.0);

	d_details.qy0.alpha[idx]  = C(0.0);
	d_details.qy0.beta[idx]   = C(0.0);
	d_details.qy0.gamma[idx]  = C(0.0);

	if (solver_params.solver_type == MWDG2)
	{
		d_details.eta1x.alpha[idx] = C(0.0);
		d_details.eta1x.beta[idx]  = C(0.0);
		d_details.eta1x.gamma[idx] = C(0.0);

		d_details.qx1x.alpha[idx] = C(0.0);
		d_details.qx1x.beta[idx]  = C(0.0);
		d_details.qx1x.gamma[idx] = C(0.0);

		d_details.qy1x.alpha[idx] = C(0.0);
		d_details.qy1x.beta[idx]  = C(0.0);
		d_details.qy1x.gamma[idx] = C(0.0);

		d_details.eta1y.alpha[idx] = C(0.0);
		d_details.eta1y.beta[idx]  = C(0.0);
		d_details.eta1y.gamma[idx] = C(0.0);

		d_details.qx1y.alpha[idx] = C(0.0);
		d_details.qx1y.beta[idx]  = C(0.0);
		d_details.qx1y.gamma[idx] = C(0.0);

		d_details.qy1y.alpha[idx] = C(0.0);
		d_details.qy1y.beta[idx]  = C(0.0);
		d_details.qy1y.gamma[idx] = C(0.0);
	}

	d_norm_details[idx] = C(0.0);
}

#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/Details.h"
#include "../types/HierarchyIndex.h"
#include "../classes/SolverParams.h"

__global__
void zero_details
(
	Details          d_details,
	real*            d_norm_details,
	int              num_details,
	SolverParams solver_params
);
#include "add_ghost_cells.cuh"

__global__
void add_ghost_cells
(
	AssembledSolution d_assem_sol,
	Neighbours        d_neighbours,
	SolverParams      solver_params,
	SimulationParams  sim_params,
	Boundaries        boundaries,
	real              current_time,
	real              dt,
	real              dx_finest,
	int               test_case
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= d_assem_sol.length) return;

	int level = d_assem_sol.levels[idx];

	MortonCode code = d_assem_sol.act_idcs[idx] - get_lvl_idx(level);

	Coordinate x = compact(code);
	Coordinate y = compact(code >> 1);
	
	bool finest  = (level == solver_params.L);
	bool bound   = false;
	bool border  = false;
	bool finebdy = false;

	bool mwdg2 = (solver_params.solver_type == MWDG2);

	bool flow_EW = false;
	bool flow_NS = false;
	
	switch (test_case)
	{
	    case 1:    // wet 1D c property
	    case 3:    // wet/dry 1D c property
	    case 5:    // wet dam break
	    case 7:    // dry dam break
	    case 9:    // dry dam break with friction
	    case 11:   // wet building overtopping
	    case 13:   // dry building overtopping
	    case 15:   // triangular dam break
	    case 17:   // parabolic bowl
	    	flow_EW = true;
	    	break;
	    case 2: 
	    case 4: 
	    case 6: 
	    case 8: 
	    case 10:
	    case 12:
	    case 14:
	    case 16:
	    case 18:
	    	flow_NS = true;
	    	break;
	    default:
	    	break;
	}

	if (d_neighbours.north.act_idcs[idx] == -1)
	{
		d_neighbours.north.h0[idx]  = d_assem_sol.h0[idx];
		d_neighbours.north.qx0[idx] = d_assem_sol.qx0[idx];
		d_neighbours.north.qy0[idx] = (test_case == 0 || test_case == 20) ? C(0.0) : d_assem_sol.qy0[idx];
		d_neighbours.north.z0[idx]  = d_assem_sol.z0[idx];
		
		if (mwdg2)
		{
			if (test_case == 0)
			{
				d_neighbours.north.h1x[idx]  = C(0.0);
				d_neighbours.north.qx1x[idx] = C(0.0);
				d_neighbours.north.qy1x[idx] = C(0.0);
				d_neighbours.north.z1x[idx]  = C(0.0);
				
				d_neighbours.north.h1y[idx]  = C(0.0);
				d_neighbours.north.qx1y[idx] = C(0.0);
				d_neighbours.north.qy1y[idx] = C(0.0);
				d_neighbours.north.z1y[idx]  = C(0.0);
			}
			else
			{
				if ( flow_NS || (!flow_NS && !flow_EW) )
				{
					if (!flow_NS && !flow_EW)
					{
						d_assem_sol.h1y[idx]  = C(0.0);
						d_assem_sol.qx1y[idx] = C(0.0);
						d_assem_sol.qy1y[idx] = C(0.0);
						d_assem_sol.z1y[idx]  = C(0.0);
					}

					d_assem_sol.h1x[idx]  = C(0.0);
					d_assem_sol.qx1x[idx] = C(0.0);
					d_assem_sol.qy1x[idx] = C(0.0);
					d_assem_sol.z1x[idx]  = C(0.0);

					d_neighbours.north.h1x[idx]  = C(0.0);
					d_neighbours.north.qx1x[idx] = C(0.0);
					d_neighbours.north.qy1x[idx] = C(0.0);
					d_neighbours.north.z1x[idx]  = C(0.0);

					d_neighbours.north.h1y[idx]  = C(0.0);
					d_neighbours.north.qx1y[idx] = C(0.0);
					d_neighbours.north.qy1y[idx] = C(0.0);
					d_neighbours.north.z1y[idx]  = C(0.0);
				}

				if (flow_EW)
				{
					d_neighbours.north.h1x[idx]  = d_assem_sol.h1x[idx];
					d_neighbours.north.qx1x[idx] = d_assem_sol.qx1x[idx];
					d_neighbours.north.qy1x[idx] = d_assem_sol.qy1x[idx];
					d_neighbours.north.z1x[idx]  = d_assem_sol.z1x[idx];

					d_neighbours.north.h1y[idx]  = C(0.0);
					d_neighbours.north.qx1y[idx] = C(0.0);
					d_neighbours.north.qy1y[idx] = C(0.0);
					d_neighbours.north.z1y[idx]  = C(0.0);
				}
			}	
		}

		bound  = ( boundaries.north.bound(x) );
		border = ( y == sim_params.ysz - 1 );

		finebdy = (finest && bound && border);

		if (finebdy && test_case == 0)
		{
			if (boundaries.north.bdytype == FREE)
			{
				d_neighbours.north.h0[idx]  = pow( (d_assem_sol.qy0[idx] * d_assem_sol.qy0[idx]) / sim_params.g, C(1.0) / C(3.0) );
				d_neighbours.north.qx0[idx] = d_assem_sol.qx0[idx];
				d_neighbours.north.qy0[idx] = d_assem_sol.qy0[idx];
			}
			else if
			(
				boundaries.north.bdytype == HFIX
				|| 
				boundaries.north.bdytype == HVAR
			)
			{
				d_assem_sol.h0[idx]        = boundaries.north.inlet - d_assem_sol.z0[idx];
				d_neighbours.north.h0[idx] = d_assem_sol.h0[idx];
			}
			else if
			(
				boundaries.north.bdytype == QFIX
				|| 
				boundaries.north.bdytype == QVAR
			)
			{
				d_assem_sol.h0[idx]        = boundaries.north.q_src(dt, dx_finest);
				d_neighbours.north.h0[idx] = d_assem_sol.h0[idx];
			}
		}
	}

	if (d_neighbours.east.act_idcs[idx] == -1)
	{
		d_neighbours.east.h0[idx]  = d_assem_sol.h0[idx];
		d_neighbours.east.qx0[idx] = (test_case == 0 || test_case == 20) ? C(0.0) : d_assem_sol.qx0[idx];
		d_neighbours.east.qy0[idx] = d_assem_sol.qy0[idx];
		d_neighbours.east.z0[idx]  = d_assem_sol.z0[idx];
		
		if (mwdg2)
		{
			if (test_case == 0)
			{
				d_neighbours.east.h1x[idx]  = C(0.0);
				d_neighbours.east.qx1x[idx] = C(0.0);
				d_neighbours.east.qy1x[idx] = C(0.0);
				d_neighbours.east.z1x[idx]  = C(0.0);
				
				d_neighbours.east.h1y[idx]  = C(0.0);
				d_neighbours.east.qx1y[idx] = C(0.0);
				d_neighbours.east.qy1y[idx] = C(0.0);
				d_neighbours.east.z1y[idx]  = C(0.0);
			}
			else
			{
				if (flow_NS)
				{
					d_neighbours.east.h1y[idx]  = d_assem_sol.h1y[idx];
					d_neighbours.east.qx1y[idx] = d_assem_sol.qx1y[idx];
					d_neighbours.east.qy1y[idx] = d_assem_sol.qy1y[idx];
					d_neighbours.east.z1y[idx]  = d_assem_sol.z1y[idx];

					d_neighbours.east.h1x[idx]  = C(0.0);
					d_neighbours.east.qx1x[idx] = C(0.0);
					d_neighbours.east.qy1x[idx] = C(0.0);
					d_neighbours.east.z1x[idx]  = C(0.0);
				}

				if ( flow_EW || (!flow_NS && !flow_EW) )
				{
					if (!flow_NS && !flow_EW)
					{
						d_assem_sol.h1x[idx]  = C(0.0);
						d_assem_sol.qx1x[idx] = C(0.0);
						d_assem_sol.qy1x[idx] = C(0.0);
						d_assem_sol.z1x[idx]  = C(0.0);
					}
					
					d_assem_sol.h1y[idx]  = C(0.0);
					d_assem_sol.qx1y[idx] = C(0.0);
					d_assem_sol.qy1y[idx] = C(0.0);
					d_assem_sol.z1y[idx]  = C(0.0);

					d_neighbours.east.h1x[idx]  = C(0.0);
					d_neighbours.east.qx1x[idx] = C(0.0);
					d_neighbours.east.qy1x[idx] = C(0.0);
					d_neighbours.east.z1x[idx]  = C(0.0);

					d_neighbours.east.h1y[idx]  = C(0.0);
					d_neighbours.east.qx1y[idx] = C(0.0);
					d_neighbours.east.qy1y[idx] = C(0.0);
					d_neighbours.east.z1y[idx]  = C(0.0);
				}
			}	
		}

		bound  = ( boundaries.east.bound(y) );
		border = ( x == sim_params.xsz - 1 );

		finebdy = (finest && bound && border);

		if (finebdy && test_case == 0)
		{
			if (boundaries.east.bdytype == FREE)
			{
				d_neighbours.east.h0[idx]  = pow( (d_assem_sol.qx0[idx] * d_assem_sol.qx0[idx]) / sim_params.g, C(1.0) / C(3.0) );
				d_neighbours.east.qx0[idx] = d_assem_sol.qx0[idx];
				d_neighbours.east.qy0[idx] = d_assem_sol.qy0[idx];
			}
			else if
			(
				boundaries.east.bdytype == HFIX
				|| 
				boundaries.east.bdytype == HVAR
			)
			{
				d_assem_sol.h0[idx]       = boundaries.east.inlet - d_assem_sol.z0[idx];
				d_neighbours.east.h0[idx] = d_assem_sol.h0[idx];
			}
			else if
			(
				boundaries.east.bdytype == QFIX
				|| 
				boundaries.east.bdytype == QVAR
			)
			{
				d_assem_sol.h0[idx]       = boundaries.east.q_src(dt, dx_finest);
				d_neighbours.east.h0[idx] = d_assem_sol.h0[idx];
			}
		}
	}

	if (d_neighbours.south.act_idcs[idx] == -1)
	{
		d_neighbours.south.h0[idx]  = d_assem_sol.h0[idx];
		d_neighbours.south.qx0[idx] = d_assem_sol.qx0[idx];
		d_neighbours.south.qy0[idx] = (test_case == 0 || test_case == 20 || test_case == 16) ? C(0.0) : d_assem_sol.qy0[idx];
		d_neighbours.south.z0[idx]  = d_assem_sol.z0[idx];
		
		if (mwdg2)
		{
			if (test_case == 0)
			{
				d_neighbours.south.h1x[idx]  = C(0.0);
				d_neighbours.south.qx1x[idx] = C(0.0);
				d_neighbours.south.qy1x[idx] = C(0.0);
				d_neighbours.south.z1x[idx]  = C(0.0);
				
				d_neighbours.south.h1y[idx]  = C(0.0);
				d_neighbours.south.qx1y[idx] = C(0.0);
				d_neighbours.south.qy1y[idx] = C(0.0);
				d_neighbours.south.z1y[idx]  = C(0.0);
			}
			else
			{
				if ( flow_NS || (!flow_NS && !flow_EW) )
				{
					if (!flow_NS && !flow_EW)
					{
						d_assem_sol.h1y[idx]  = C(0.0);
						d_assem_sol.qx1y[idx] = C(0.0);
						d_assem_sol.qy1y[idx] = C(0.0);
						d_assem_sol.z1y[idx]  = C(0.0);
					}
					
					d_assem_sol.h1x[idx]  = C(0.0);
					d_assem_sol.qx1x[idx] = C(0.0);
					d_assem_sol.qy1x[idx] = C(0.0);
					d_assem_sol.z1x[idx]  = C(0.0);

					d_neighbours.south.h1x[idx]  = C(0.0);
					d_neighbours.south.qx1x[idx] = C(0.0);
					d_neighbours.south.qy1x[idx] = C(0.0);
					d_neighbours.south.z1x[idx]  = C(0.0);

					d_neighbours.south.h1y[idx]  = C(0.0);
					d_neighbours.south.qx1y[idx] = C(0.0);
					d_neighbours.south.qy1y[idx] = C(0.0);
					d_neighbours.south.z1y[idx]  = C(0.0);
				}

				if (flow_EW)
				{
					d_neighbours.south.h1x[idx]  = d_assem_sol.h1x[idx];
					d_neighbours.south.qx1x[idx] = d_assem_sol.qx1x[idx];
					d_neighbours.south.qy1x[idx] = d_assem_sol.qy1x[idx];
					d_neighbours.south.z1x[idx]  = d_assem_sol.z1x[idx];
					
					d_neighbours.south.h1y[idx]  = C(0.0);
					d_neighbours.south.qx1y[idx] = C(0.0);
					d_neighbours.south.qy1y[idx] = C(0.0);
					d_neighbours.south.z1y[idx]  = C(0.0);
				}
			}	
		}

		bound  = ( boundaries.south.bound(x) );
		border = ( y == 0 );

		finebdy = (finest && bound && border);

		if (finebdy && test_case == 0)
		{
			if (boundaries.south.bdytype == FREE)
			{
				d_neighbours.south.h0[idx]  = pow( (d_assem_sol.qy0[idx] * d_assem_sol.qy0[idx]) / sim_params.g, C(1.0) / C(3.0) );
				d_neighbours.south.qx0[idx] = d_assem_sol.qx0[idx];
				d_neighbours.south.qy0[idx] = d_assem_sol.qy0[idx];
			}
			else if
			(
				boundaries.south.bdytype == HFIX
				|| 
				boundaries.south.bdytype == HVAR
			)
			{
				d_assem_sol.h0[idx]        = boundaries.south.inlet - d_assem_sol.z0[idx];
				d_neighbours.south.h0[idx] = d_assem_sol.h0[idx];
			}
			else if
			(
				boundaries.south.bdytype == QFIX
				|| 
				boundaries.south.bdytype == QVAR
			)
			{
				d_assem_sol.h0[idx]        = boundaries.south.q_src(dt, dx_finest);
				d_neighbours.south.h0[idx] = d_assem_sol.h0[idx];
			}
		}
	}

	if (d_neighbours.west.act_idcs[idx] == -1)
	{
		d_neighbours.west.h0[idx]  = d_assem_sol.h0[idx];
		d_neighbours.west.qx0[idx] = (test_case == 0 || test_case == 20 || test_case == 15) ? C(0.0) : d_assem_sol.qx0[idx];
		d_neighbours.west.qy0[idx] = d_assem_sol.qy0[idx];
		d_neighbours.west.z0[idx]  = d_assem_sol.z0[idx];
		
		if (mwdg2)
		{
			if (test_case == 0)
			{
				d_neighbours.west.h1x[idx]  = C(0.0);
				d_neighbours.west.qx1x[idx] = C(0.0);
				d_neighbours.west.qy1x[idx] = C(0.0);
				d_neighbours.west.z1x[idx]  = C(0.0);
				
				d_neighbours.west.h1y[idx]  = C(0.0);
				d_neighbours.west.qx1y[idx] = C(0.0);
				d_neighbours.west.qy1y[idx] = C(0.0);
				d_neighbours.west.z1y[idx]  = C(0.0);
			}
			else
			{
				if (flow_NS)
				{
					d_neighbours.west.h1y[idx]  = d_assem_sol.h1y[idx];
					d_neighbours.west.qx1y[idx] = d_assem_sol.qx1y[idx];
					d_neighbours.west.qy1y[idx] = d_assem_sol.qy1y[idx];
					d_neighbours.west.z1y[idx]  = d_assem_sol.z1y[idx];

					d_neighbours.west.h1x[idx]  = C(0.0);
					d_neighbours.west.qx1x[idx] = C(0.0);
					d_neighbours.west.qy1x[idx] = C(0.0);
					d_neighbours.west.z1x[idx]  = C(0.0);
				}

				if ( flow_EW || (!flow_NS && !flow_EW) )
				{
					if (!flow_NS && !flow_EW)
					{
						d_assem_sol.h1x[idx]  = C(0.0);
						d_assem_sol.qx1x[idx] = C(0.0);
						d_assem_sol.qy1x[idx] = C(0.0);
						d_assem_sol.z1x[idx]  = C(0.0);
					}

					d_assem_sol.h1y[idx]  = C(0.0);
					d_assem_sol.qx1y[idx] = C(0.0);
					d_assem_sol.qy1y[idx] = C(0.0);
					d_assem_sol.z1y[idx]  = C(0.0);

					d_neighbours.west.h1x[idx]  = C(0.0);
					d_neighbours.west.qx1x[idx] = C(0.0);
					d_neighbours.west.qy1x[idx] = C(0.0);
					d_neighbours.west.z1x[idx]  = C(0.0);

					d_neighbours.west.h1y[idx]  = C(0.0);
					d_neighbours.west.qx1y[idx] = C(0.0);
					d_neighbours.west.qy1y[idx] = C(0.0);
					d_neighbours.west.z1y[idx]  = C(0.0);
				}
			}	
		}
		
		bound  = ( boundaries.west.bound(y) );
		border = ( x == 0 );

		finebdy = (finest && bound && border);

		if (finebdy && test_case == 0)
		{
			if (boundaries.west.bdytype == FREE)
			{
				d_neighbours.west.h0[idx]  = pow( (d_assem_sol.qx0[idx] * d_assem_sol.qx0[idx]) / sim_params.g, C(1.0) / C(3.0) );
				d_neighbours.west.qx0[idx] = d_assem_sol.qx0[idx]; 
				d_neighbours.west.qy0[idx] = d_assem_sol.qy0[idx];
			}
			else if
			(
				boundaries.west.bdytype == HFIX
				|| 
				boundaries.west.bdytype == HVAR
			)
			{
				if (sim_params.is_monai)
				{
					real hp  = d_assem_sol.h0[idx];
					real qxp = d_assem_sol.qx0[idx];
					real up  = (hp > solver_params.tol_h) ? qxp / hp : C(0.0);

					real hb = C(0.13535);
					real ub = C(0.0);

					twodoubles outputs = non_reflective_wave
					(
						boundaries.west.inlet, 
						dt, 
						dx_finest, 
						hp, up, hb, ub, 
						sim_params.g
					);

					d_neighbours.west.h0[idx]  = outputs.hb - d_assem_sol.z0[idx];
					d_neighbours.west.qx0[idx] = outputs.hb * outputs.ub;
				}
				else if (sim_params.is_oregon)
				{
				    d_neighbours.west.h0[idx] = d_assem_sol.h0[idx];
					
					// wavemaker speed based on bc2amr.f from https://zenodo.org/record/1419317
					real s = C(0.6) * exp( -C(0.25) * ( current_time - C(14.75) ) * ( current_time - C(14.75) ) );
					
					real v0 = (d_assem_sol.h0[idx] > solver_params.tol_h) ? d_assem_sol.qx0[idx] / d_assem_sol.h0[idx] : C(0.0);
					
					d_neighbours.west.qx0[idx] = ( (C(2.0) * s - v0) * d_neighbours.west.h0[idx] );
				}
				else
				{
					d_assem_sol.h0[idx]       = boundaries.west.inlet - d_assem_sol.z0[idx];
				    d_neighbours.west.h0[idx] = d_assem_sol.h0[idx];
				}
			}
			else if
			(
				boundaries.west.bdytype == QFIX
				|| 
				boundaries.west.bdytype == QVAR
			)
			{
				d_assem_sol.h0[idx]       = boundaries.west.q_src(dt, dx_finest);
				d_neighbours.west.h0[idx] = d_assem_sol.h0[idx];
			}
		}
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/Neighbours.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"
#include "../classes/Boundaries.h"

#include "../utilities/get_lvl_idx.cuh"
#include "../zorder/compact.cuh"
#include "../operators/non_reflective_wave.cuh"

__global__
void add_ghost_cells
(
	AssembledSolution d_assem_sol,
	Neighbours        d_neighbours,
	SolverParams      solver_params,
	SimulationParams  sim_params,
	Boundaries        boundaries,
	real              current_time,
	real              dt,
	real              dx_finest,
	int               test_case
);
target_sources(
	    gpu-mwdg2
		PRIVATE
		add_ghost_cells.cu
		compaction.cu
		find_neighbours.cu
		get_compaction_flags.cu
		load_soln_and_nghbr_coeffs.cu
	)
#include "compaction.cuh"

__host__
void compaction
(
	AssembledSolution& d_buf_assem_sol, 
	AssembledSolution& d_assem_sol, 
	Neighbours&        d_buf_neighbours, 
	Neighbours&        d_neighbours, 
	CompactionFlags&   d_compaction_flags,
	int                num_finest_elems,
	const SolverParams& solver_params
)
{
	void*  d_temp_storage = NULL;
	size_t temp_storage_bytes = 0;

	int* d_assem_sol_len = (int*)malloc_device( sizeof(int) );
	int* h_sol_len = new int;

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_assem_sol.z0, 
		d_compaction_flags.north_east, 
		d_assem_sol.z0, 
		d_assem_sol_len, 
		num_finest_elems
	) );

	d_temp_storage = malloc_device(temp_storage_bytes);

	/*CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_assem_sol.h0, 
		d_compaction_flags.north_east, 
		d_assem_sol.h0, 
		d_assem_sol_len, 
		num_finest_elems
	) );

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_assem_sol.qx0, 
		d_compaction_flags.north_east, 
		d_assem_sol.qx0, 
		d_assem_sol_len, 
		num_finest_elems
	) );

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_assem_sol.qy0, 
		d_compaction_flags.north_east, 
		d_assem_sol.qy0, 
		d_assem_sol_len, 
		num_finest_elems
	) );

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_assem_sol.z0, 
		d_compaction_flags.north_east, 
		d_assem_sol.z0, 
		d_assem_sol_len, 
		num_finest_elems
	) );*/

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_assem_sol.act_idcs, 
		d_compaction_flags.north_east, 
		d_assem_sol.act_idcs, 
		d_assem_sol_len, 
		num_finest_elems
	) );

	copy_cuda
	(
		h_sol_len, 
		d_assem_sol_len, 
		sizeof(int)
	);
	
	d_assem_sol.length = *h_sol_len;
	
	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_assem_sol.levels, 
		d_compaction_flags.north_east, 
		d_assem_sol.levels,
		d_assem_sol_len, 
		num_finest_elems
	) );

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_neighbours.north.act_idcs, 
		d_compaction_flags.north_east, 
		d_neighbours.north.act_idcs,
		d_assem_sol_len, 
		num_finest_elems
	) );

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_neighbours.east.act_idcs,
		d_compaction_flags.north_east, 
		d_neighbours.east.act_idcs,
		d_assem_sol_len, 
		num_finest_elems
	) );

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_neighbours.south.act_idcs,
		d_compaction_flags.south_west, 
		d_neighbours.south.act_idcs,
		d_assem_sol_len, 
		num_finest_elems
	) );

	CHECK_CUDA_ERROR( cub::DeviceSelect::Flagged
	(
		d_temp_storage, 
		temp_storage_bytes, 
		d_buf_neighbours.west.act_idcs,
		d_compaction_flags.south_west, 
		d_neighbours.west.act_idcs,
		d_assem_sol_len, 
		num_finest_elems
	) );

	if (solver_params.solver_type == MWDG2)
	{
		CHECK_CUDA_ERROR(cub::DeviceSelect::Flagged
		(
			d_temp_storage,
			temp_storage_bytes,
			d_buf_neighbours.north.levels,
			d_compaction_flags.north_east,
			d_neighbours.north.levels,
			d_assem_sol_len,
			num_finest_elems
		));

		CHECK_CUDA_ERROR(cub::DeviceSelect::Flagged
		(
			d_temp_storage,
			temp_storage_bytes,
			d_buf_neighbours.east.levels,
			d_compaction_flags.north_east,
			d_neighbours.east.levels,
			d_assem_sol_len,
			num_finest_elems
		));

		CHECK_CUDA_ERROR(cub::DeviceSelect::Flagged
		(
			d_temp_storage,
			temp_storage_bytes,
			d_buf_neighbours.south.levels,
			d_compaction_flags.south_west,
			d_neighbours.south.levels,
			d_assem_sol_len,
			num_finest_elems
		));

		CHECK_CUDA_ERROR(cub::DeviceSelect::Flagged
		(
			d_temp_storage,
			temp_storage_bytes,
			d_buf_neighbours.west.levels,
			d_compaction_flags.south_west,
			d_neighbours.west.levels,
			d_assem_sol_len,
			num_finest_elems
		));
	}

	free_device(d_temp_storage);
	free_device(d_assem_sol_len);
	delete      h_sol_len;
}
#pragma once

#include "cub/device/device_select.cuh"

#include "../utilities/cuda_utils.cuh"

#include "../classes/AssembledSolution.h"
#include "../classes/Neighbours.h"
#include "../classes/CompactionFlags.h"
#include "../classes/SolverParams.h"

__host__
void compaction
(
	AssembledSolution& d_buf_assem_sol, 
	AssembledSolution& d_assem_sol, 
	Neighbours&        d_buf_neighbours, 
	Neighbours&        d_neighbours, 
	CompactionFlags&   d_compaction_flags,
	int                num_finest_elems,
	const SolverParams& solver_params
);
#include "find_neighbours.cuh"

__global__
void find_neighbours
(
    AssembledSolution    d_assem_sol,
    Neighbours           d_neighbours,
    SimulationParams sim_params,
    int                  mesh_dim
)
{
    HierarchyIndex t_idx = threadIdx.x;
    HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

    Coordinate x = idx % mesh_dim;
    Coordinate y = idx / mesh_dim;

    HierarchyIndex north;
    HierarchyIndex east;
    HierarchyIndex south;
    HierarchyIndex west;

    HierarchyIndex active_idx_local;
    HierarchyIndex active_idx_north;
    HierarchyIndex active_idx_east;
    HierarchyIndex active_idx_south;
    HierarchyIndex active_idx_west;

    int lvl_local = d_assem_sol.levels[idx];
    int lvl_north;
    int lvl_east;
    int lvl_south;
    int lvl_west;

    HierarchyIndex lvl_idx_local;
    HierarchyIndex lvl_idx_north;
    HierarchyIndex lvl_idx_east;
    HierarchyIndex lvl_idx_south;
    HierarchyIndex lvl_idx_west;

    MortonCode code_north;
    MortonCode code_east;
    MortonCode code_south;
    MortonCode code_west;

    int lvl_diff_north;
    int lvl_diff_east;
    int lvl_diff_south;
    int lvl_diff_west;

    bool northern = ( y == (mesh_dim - 1) || y == (sim_params.ysz - 1) );
    bool eastern  = ( x == (mesh_dim - 1) || x == (sim_params.xsz - 1) );
    bool southern = ( y == 0 );
    bool western  = ( x == 0 );

    bool at_border = (northern || eastern || southern || western);

    if (!at_border)
    {
        north = idx + mesh_dim;
        east  = idx + 1;
        south = idx - mesh_dim;
        west  = idx - 1;

        active_idx_local = d_assem_sol.act_idcs[idx];
        active_idx_north = d_assem_sol.act_idcs[north];
        active_idx_east  = d_assem_sol.act_idcs[east];
        active_idx_south = d_assem_sol.act_idcs[south];
        active_idx_west  = d_assem_sol.act_idcs[west];

        lvl_north = d_assem_sol.levels[north];
        lvl_east  = d_assem_sol.levels[east];
        lvl_south = d_assem_sol.levels[south];
        lvl_west  = d_assem_sol.levels[west];

        lvl_idx_local = get_lvl_idx(lvl_local);
        lvl_idx_north = get_lvl_idx(lvl_north);
        lvl_idx_east  = get_lvl_idx(lvl_east);
        lvl_idx_south = get_lvl_idx(lvl_south);
        lvl_idx_west  = get_lvl_idx(lvl_west);

        code_north = active_idx_north - lvl_idx_north;
        code_east  = active_idx_east  - lvl_idx_east;
        code_south = active_idx_south - lvl_idx_south;
        code_west  = active_idx_west  - lvl_idx_west;

        if (
            lvl_north == 3 &&
            lvl_east == 5 &&
            lvl_south == 4 &&
            lvl_west == 5
            )
        {
            printf("active_idx_north: %d\n", active_idx_north);
            printf("active_idx_east : %d\n", active_idx_east);
            printf("active_idx_south: %d\n", active_idx_south);
            printf("active_idx_west : %d\n", active_idx_west);
        }

        // lvl_idx_east - lvl_idx_local is positive only if
        // eastern neighbour is finer, which is the only time
        // we want to shift; idx should stay the same otherwise
        lvl_diff_north = max(0, lvl_north - lvl_local);
        lvl_diff_east  = max(0, lvl_east  - lvl_local);
        lvl_diff_south = max(0, lvl_south - lvl_local);
        lvl_diff_west  = max(0, lvl_west  - lvl_local);

        // for the case where the eastern neighbour is coarser
        // lvl_idx_local would evidently be finer and hence bigger
        // we would not use this hence min to select lvl_idx_east
        // for other cases, we would always use lvl_idx_local
        // where e.g. eastern neighbour is finer or same resolution
        d_neighbours.north.act_idcs[idx] = min(lvl_idx_local, lvl_idx_north) + ( code_north >> (2 * lvl_diff_north) );
        d_neighbours.east.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_east)  + ( code_east  >> (2 * lvl_diff_east) );
        d_neighbours.south.act_idcs[idx] = min(lvl_idx_local, lvl_idx_south) + ( code_south >> (2 * lvl_diff_south) );
        d_neighbours.west.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_west)  + ( code_west  >> (2 * lvl_diff_west) );

        d_neighbours.north.levels[idx] = min(lvl_local, lvl_north);
        d_neighbours.east.levels[idx]  = min(lvl_local, lvl_east);
        d_neighbours.south.levels[idx] = min(lvl_local, lvl_south);
        d_neighbours.west.levels[idx]  = min(lvl_local, lvl_west);

        /*n_idx = min(lvl_idx_local, lvl_idx_north) + code_north >> (2 * lvl_diff_north);
        e_idx = min(lvl_idx_local, lvl_idx_east) + ( code_east >> (2 * lvl_diff_east) );
        s_idx = min(lvl_idx_local, lvl_idx_south) + code_south >> (2 * lvl_diff_south);
        w_idx = min(lvl_idx_local, lvl_idx_west) + code_west >> (2 * lvl_diff_west);

        d_neighbours.north.levels[idx] = get_level(n_idx);
        d_neighbours.east.levels[idx] = get_level(e_idx);
        d_neighbours.south.levels[idx] = get_level(s_idx);
        d_neighbours.west.levels[idx] = get_level(w_idx);*/
    }
    else
    {        
        int h_dir = (western)  ? WEST  : (eastern)  ? EAST  : 0;
        int v_dir = (southern) ? SOUTH : (northern) ? NORTH : 0;

        int position = v_dir | h_dir;

        // switch logic explained in Directions enum, Directions.h
        switch (position)
        {
        case NORTH:  // north
            d_neighbours.north.act_idcs[idx] = -1;
            d_neighbours.north.levels[idx] = lvl_local;

            east  = idx + 1;
            south = idx - mesh_dim;
            west  = idx - 1;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_east  = d_assem_sol.act_idcs[east];
            active_idx_south = d_assem_sol.act_idcs[south];
            active_idx_west  = d_assem_sol.act_idcs[west];

            lvl_east  = d_assem_sol.levels[east];
            lvl_south = d_assem_sol.levels[south];
            lvl_west  = d_assem_sol.levels[west];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_east  = get_lvl_idx(lvl_east);
            lvl_idx_south = get_lvl_idx(lvl_south);
            lvl_idx_west  = get_lvl_idx(lvl_west);

            code_east  = active_idx_east  - lvl_idx_east;
            code_south = active_idx_south - lvl_idx_south;
            code_west  = active_idx_west  - lvl_idx_west;

            lvl_diff_east  = max(0, lvl_east  - lvl_local);
            lvl_diff_south = max(0, lvl_south - lvl_local);
            lvl_diff_west  = max(0, lvl_west  - lvl_local);

            d_neighbours.east.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_east)  + ( code_east  >> (2 * lvl_diff_east) ) ;
            d_neighbours.south.act_idcs[idx] = min(lvl_idx_local, lvl_idx_south) + ( code_south >> (2 * lvl_diff_south) );
            d_neighbours.west.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_west)  + ( code_west  >> (2 * lvl_diff_west) );

            d_neighbours.east.levels[idx]  = min(lvl_local, lvl_east);
            d_neighbours.south.levels[idx] = min(lvl_local, lvl_south);
            d_neighbours.west.levels[idx]  = min(lvl_local, lvl_west);

            break;
        case EAST:  // east
            d_neighbours.east.act_idcs[idx] = -1;
            d_neighbours.east.levels[idx] = lvl_local;

            north = idx + mesh_dim;
            south = idx - mesh_dim;
            west  = idx - 1;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_north = d_assem_sol.act_idcs[north];
            active_idx_south = d_assem_sol.act_idcs[south];
            active_idx_west  = d_assem_sol.act_idcs[west];
    
            lvl_north = d_assem_sol.levels[north];
            lvl_south = d_assem_sol.levels[south];
            lvl_west  = d_assem_sol.levels[west];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_north = get_lvl_idx(lvl_north);
            lvl_idx_south = get_lvl_idx(lvl_south);
            lvl_idx_west  = get_lvl_idx(lvl_west);

            code_north = active_idx_north - lvl_idx_north;
            code_south = active_idx_south - lvl_idx_south;
            code_west  = active_idx_west  - lvl_idx_west;

            lvl_diff_north = max(0, lvl_north - lvl_local);
            lvl_diff_south = max(0, lvl_south - lvl_local);
            lvl_diff_west  = max(0, lvl_west  - lvl_local);

            d_neighbours.north.act_idcs[idx] = min(lvl_idx_local, lvl_idx_north) + ( code_north >> (2 * lvl_diff_north) );
            d_neighbours.south.act_idcs[idx] = min(lvl_idx_local, lvl_idx_south) + ( code_south >> (2 * lvl_diff_south) );
            d_neighbours.west.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_west)  + ( code_west  >> (2 * lvl_diff_west) );

            d_neighbours.north.levels[idx] = min(lvl_local, lvl_north);
            d_neighbours.south.levels[idx] = min(lvl_local, lvl_south);
            d_neighbours.west.levels[idx]  = min(lvl_local, lvl_west);

            break;
        case SOUTH:  // south
            d_neighbours.south.act_idcs[idx] = -1;
            d_neighbours.south.levels[idx] = lvl_local;

            north = idx + mesh_dim;
            east  = idx + 1;
            west  = idx - 1;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_north = d_assem_sol.act_idcs[north];
            active_idx_east  = d_assem_sol.act_idcs[east];
            active_idx_west  = d_assem_sol.act_idcs[west];

            lvl_north = d_assem_sol.levels[north];
            lvl_east  = d_assem_sol.levels[east];
            lvl_west  = d_assem_sol.levels[west];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_north = get_lvl_idx(lvl_north);
            lvl_idx_east  = get_lvl_idx(lvl_east);
            lvl_idx_west  = get_lvl_idx(lvl_west);

            code_north = active_idx_north - lvl_idx_north;
            code_east  = active_idx_east  - lvl_idx_east;
            code_west  = active_idx_west  - lvl_idx_west;

            lvl_diff_north = max(0, lvl_north - lvl_local);
            lvl_diff_east  = max(0, lvl_east  - lvl_local);
            lvl_diff_west  = max(0, lvl_west  - lvl_local);

            d_neighbours.north.act_idcs[idx] = min(lvl_idx_local, lvl_idx_north) + ( code_north >> (2 * lvl_diff_north) );
            d_neighbours.east.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_east)  + ( code_east  >> (2 * lvl_diff_east) );
            d_neighbours.west.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_west)  + ( code_west  >> (2 * lvl_diff_west) );

            d_neighbours.north.levels[idx] = min(lvl_local, lvl_north);
            d_neighbours.east.levels[idx]  = min(lvl_local, lvl_east);
            d_neighbours.west.levels[idx]  = min(lvl_local, lvl_west);

            break;
        case WEST:  // west
            d_neighbours.west.act_idcs[idx] = -1;
            d_neighbours.west.levels[idx] = lvl_local;

            north = idx + mesh_dim;
            east  = idx + 1;
            south = idx - mesh_dim;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_north = d_assem_sol.act_idcs[north];
            active_idx_east  = d_assem_sol.act_idcs[east];
            active_idx_south = d_assem_sol.act_idcs[south];

            lvl_north = d_assem_sol.levels[north];
            lvl_east  = d_assem_sol.levels[east];
            lvl_south = d_assem_sol.levels[south];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_north = get_lvl_idx(lvl_north);
            lvl_idx_east  = get_lvl_idx(lvl_east);
            lvl_idx_south = get_lvl_idx(lvl_south);

            code_north = active_idx_north - lvl_idx_north;
            code_east  = active_idx_east  - lvl_idx_east;
            code_south = active_idx_south - lvl_idx_south;

            lvl_diff_north = max(0, lvl_north - lvl_local);
            lvl_diff_east  = max(0, lvl_east  - lvl_local);
            lvl_diff_south = max(0, lvl_south - lvl_local);

            d_neighbours.north.act_idcs[idx] = min(lvl_idx_local, lvl_idx_north) + ( code_north >> (2 * lvl_diff_north) );
            d_neighbours.east.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_east)  + ( code_east  >> (2 * lvl_diff_east) );
            d_neighbours.south.act_idcs[idx] = min(lvl_idx_local, lvl_idx_south) + ( code_south >> (2 * lvl_diff_south) );

            d_neighbours.north.levels[idx] = min(lvl_local, lvl_north);
            d_neighbours.east.levels[idx]  = min(lvl_local, lvl_east);
            d_neighbours.south.levels[idx] = min(lvl_local, lvl_south);

            break;
        case NORTH | EAST:  // northeast
            d_neighbours.north.act_idcs[idx] = -1;
            d_neighbours.east.act_idcs[idx] = -1;

            d_neighbours.north.levels[idx] = lvl_local;
            d_neighbours.east.levels[idx] = lvl_local;

            south = idx - mesh_dim;
            west  = idx - 1;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_south = d_assem_sol.act_idcs[south];
            active_idx_west  = d_assem_sol.act_idcs[west];

    
            lvl_south = d_assem_sol.levels[south];
            lvl_west  = d_assem_sol.levels[west];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_south = get_lvl_idx(lvl_south);
            lvl_idx_west  = get_lvl_idx(lvl_west);

            code_south = active_idx_south - lvl_idx_south;
            code_west  = active_idx_west  - lvl_idx_west;

            lvl_diff_south = max(0, lvl_south - lvl_local);
            lvl_diff_west  = max(0, lvl_west  - lvl_local);

            d_neighbours.south.act_idcs[idx] = min(lvl_idx_local, lvl_idx_south) + ( code_south >> (2 * lvl_diff_south) );
            d_neighbours.west.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_west)  + ( code_west  >> (2 * lvl_diff_west) );

            d_neighbours.south.levels[idx] = min(lvl_local, lvl_south);
            d_neighbours.west.levels[idx]  = min(lvl_local, lvl_west);

            break;
        case NORTH | WEST:  // northwest
            d_neighbours.north.act_idcs[idx] = -1;
            d_neighbours.west.act_idcs[idx] = -1;

            d_neighbours.north.levels[idx] = lvl_local;
            d_neighbours.west.levels[idx] = lvl_local;

            east  = idx + 1;
            south = idx - mesh_dim;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_east  = d_assem_sol.act_idcs[east];
            active_idx_south = d_assem_sol.act_idcs[south];

    
            lvl_east  = d_assem_sol.levels[east];
            lvl_south = d_assem_sol.levels[south];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_east  = get_lvl_idx(lvl_east);
            lvl_idx_south = get_lvl_idx(lvl_south);

            code_east  = active_idx_east  - lvl_idx_east;
            code_south = active_idx_south - lvl_idx_south;

            lvl_diff_east  = max(0, lvl_east  - lvl_local);
            lvl_diff_south = max(0, lvl_south - lvl_local);

            d_neighbours.east.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_east)  + ( code_east  >> (2 * lvl_diff_east) );
            d_neighbours.south.act_idcs[idx] = min(lvl_idx_local, lvl_idx_south) + ( code_south >> (2 * lvl_diff_south) );

            d_neighbours.east.levels[idx]  = min(lvl_local, lvl_east);
            d_neighbours.south.levels[idx] = min(lvl_local, lvl_south);

            break;
        case SOUTH | EAST:  // southeast
            d_neighbours.south.act_idcs[idx] = -1;
            d_neighbours.east.act_idcs[idx] = -1;

            d_neighbours.south.levels[idx] = lvl_local;
            d_neighbours.east.levels[idx] = lvl_local;

            north = idx + mesh_dim;
            west  = idx - 1;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_north = d_assem_sol.act_idcs[north];
            active_idx_west  = d_assem_sol.act_idcs[west];

    
            lvl_north = d_assem_sol.levels[north];
            lvl_west  = d_assem_sol.levels[west];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_north = get_lvl_idx(lvl_north);
            lvl_idx_west  = get_lvl_idx(lvl_west);

            code_north = active_idx_north - lvl_idx_north;
            code_west  = active_idx_west  - lvl_idx_west;

            lvl_diff_north = max(0, lvl_north - lvl_local);
            lvl_diff_west  = max(0, lvl_west  - lvl_local);

            d_neighbours.north.act_idcs[idx] = min(lvl_idx_local, lvl_idx_north) + ( code_north >> (2 * lvl_diff_north) );
            d_neighbours.west.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_west)  + ( code_west  >> (2 * lvl_diff_west) );

            d_neighbours.north.levels[idx] = min(lvl_local, lvl_north);
            d_neighbours.west.levels[idx]  = min(lvl_local, lvl_west);

            break;
        case SOUTH | WEST: // southwest
            d_neighbours.south.act_idcs[idx] = -1;
            d_neighbours.west.act_idcs[idx] = -1;

            d_neighbours.south.levels[idx] = lvl_local;
            d_neighbours.west.levels[idx] = lvl_local;

            north = idx + mesh_dim;
            east  = idx + 1;

            active_idx_local = d_assem_sol.act_idcs[idx];
            active_idx_north = d_assem_sol.act_idcs[north];
            active_idx_east  = d_assem_sol.act_idcs[east];

    
            lvl_north = d_assem_sol.levels[north];
            lvl_east  = d_assem_sol.levels[east];

            lvl_idx_local = get_lvl_idx(lvl_local);
            lvl_idx_north = get_lvl_idx(lvl_north);
            lvl_idx_east  = get_lvl_idx(lvl_east);

            code_north = active_idx_north - lvl_idx_north;
            code_east  = active_idx_east  - lvl_idx_east;

            lvl_diff_north = max(0, lvl_north - lvl_local);
            lvl_diff_east  = max(0, lvl_east  - lvl_local);

            d_neighbours.north.act_idcs[idx] = min(lvl_idx_local, lvl_idx_north) + ( code_north >> (2 * lvl_diff_north) );
            d_neighbours.east.act_idcs[idx]  = min(lvl_idx_local, lvl_idx_east)  + ( code_east  >> (2 * lvl_diff_east) );

            d_neighbours.north.levels[idx] = min(lvl_local, lvl_north);
            d_neighbours.east.levels[idx]  = min(lvl_local, lvl_east);
            break;
        default:
            printf("ERROR: none of the directions were encountered. Thread: %d.\n", idx);
            return;
        }
    }
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/Neighbours.h"
#include "../types/Coordinate.h"
#include "../types/Directions.h"
#include "../types/MortonCode.h"
#include "../classes/SimulationParams.h"

#include "../utilities/get_lvl_idx.cuh"

__global__
void find_neighbours
(
    AssembledSolution    d_assem_ol,
    Neighbours           d_neighbours,
    SimulationParams sim_params,
    int                  mesh_dim
);
#include "get_compaction_flags.cuh"

__global__
void get_compaction_flags
(
	AssembledSolution d_assem_sol,
	CompactionFlags   d_compaction_flags,
	int               num_finest_elems
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= num_finest_elems) return;

	HierarchyIndex current = d_assem_sol.act_idcs[idx];

	if ( idx < (num_finest_elems - 1) )
	{
		HierarchyIndex right = d_assem_sol.act_idcs[idx + 1];

		d_compaction_flags.north_east[idx] = !(current == right);
	}
	else
	{
		d_compaction_flags.north_east[idx] = 1;
	}

	if (idx > 0)
	{
		HierarchyIndex left = d_assem_sol.act_idcs[idx - 1];

		d_compaction_flags.south_west[idx] = !(current == left);
	}
	else
	{
		d_compaction_flags.south_west[idx] = 1;
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_load.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../types/HierarchyIndex.h"
#include "../classes/CompactionFlags.h"
#include "../classes/AssembledSolution.h"

__global__
void get_compaction_flags
(
	AssembledSolution d_assem_sol,
	CompactionFlags   d_compaction_flags,
	int               num_finest_elems
);
#include "load_soln_and_nghbr_coeffs.cuh"

__global__
void load_soln_and_nghbr_coeffs
(
	Neighbours        d_neighbours,
	ScaleCoefficients d_scale_coeffs,
	AssembledSolution d_assem_sol,
	SolverParams  solver_params
)
{
	HierarchyIndex idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx >= d_assem_sol.length) return;

	HierarchyIndex soln  = d_assem_sol.act_idcs[idx];
	HierarchyIndex north = d_neighbours.north.act_idcs[idx];
	HierarchyIndex east  = d_neighbours.east.act_idcs[idx];
	HierarchyIndex south = d_neighbours.south.act_idcs[idx];
	HierarchyIndex west  = d_neighbours.west.act_idcs[idx];

	north = (north == -1) ? 0 : north;
	east  = (east  == -1) ? 0 : east;
	south = (south == -1) ? 0 : south;
	west  = (west  == -1) ? 0 : west;

	d_assem_sol.h0[idx]  = d_scale_coeffs.eta0[soln] - d_scale_coeffs.z0[soln];
	d_assem_sol.qx0[idx] = d_scale_coeffs.qx0[soln];
	d_assem_sol.qy0[idx] = d_scale_coeffs.qy0[soln];
	d_assem_sol.z0[idx]  = d_scale_coeffs.z0[soln];

	d_neighbours.north.h0[idx]  = d_scale_coeffs.eta0[north] - d_scale_coeffs.z0[north];
	d_neighbours.north.qx0[idx] = d_scale_coeffs.qx0[north];
	d_neighbours.north.qy0[idx] = d_scale_coeffs.qy0[north];
	d_neighbours.north.z0[idx]  = d_scale_coeffs.z0[north];

	d_neighbours.east.h0[idx]  = d_scale_coeffs.eta0[east] - d_scale_coeffs.z0[east];
	d_neighbours.east.qx0[idx] = d_scale_coeffs.qx0[east];
	d_neighbours.east.qy0[idx] = d_scale_coeffs.qy0[east];
	d_neighbours.east.z0[idx]  = d_scale_coeffs.z0[east];

	d_neighbours.south.h0[idx]  = d_scale_coeffs.eta0[south] - d_scale_coeffs.z0[south];
	d_neighbours.south.qx0[idx] = d_scale_coeffs.qx0[south];
	d_neighbours.south.qy0[idx] = d_scale_coeffs.qy0[south];
	d_neighbours.south.z0[idx]  = d_scale_coeffs.z0[south];

	d_neighbours.west.h0[idx]  = d_scale_coeffs.eta0[west] - d_scale_coeffs.z0[west];
	d_neighbours.west.qx0[idx] = d_scale_coeffs.qx0[west];
	d_neighbours.west.qy0[idx] = d_scale_coeffs.qy0[west];
	d_neighbours.west.z0[idx]  = d_scale_coeffs.z0[west];

	if (solver_params.solver_type == MWDG2)
	{
		d_assem_sol.h1x[idx]  = d_scale_coeffs.eta1x[soln] - d_scale_coeffs.z1x[soln];
		d_assem_sol.qx1x[idx] = d_scale_coeffs.qx1x[soln];
		d_assem_sol.qy1x[idx] = d_scale_coeffs.qy1x[soln];
		d_assem_sol.z1x[idx]  = d_scale_coeffs.z1x[soln];

		d_neighbours.north.h1x[idx]  = d_scale_coeffs.eta1x[north] - d_scale_coeffs.z1x[north];
		d_neighbours.north.qx1x[idx] = d_scale_coeffs.qx1x[north];
		d_neighbours.north.qy1x[idx] = d_scale_coeffs.qy1x[north];
		d_neighbours.north.z1x[idx]  = d_scale_coeffs.z1x[north];

		d_neighbours.east.h1x[idx]  = d_scale_coeffs.eta1x[east] - d_scale_coeffs.z1x[east];
		d_neighbours.east.qx1x[idx] = d_scale_coeffs.qx1x[east];
		d_neighbours.east.qy1x[idx] = d_scale_coeffs.qy1x[east];
		d_neighbours.east.z1x[idx]  = d_scale_coeffs.z1x[east];

		d_neighbours.south.h1x[idx]  = d_scale_coeffs.eta1x[south] - d_scale_coeffs.z1x[south];
		d_neighbours.south.qx1x[idx] = d_scale_coeffs.qx1x[south];
		d_neighbours.south.qy1x[idx] = d_scale_coeffs.qy1x[south];
		d_neighbours.south.z1x[idx]  = d_scale_coeffs.z1x[south];

		d_neighbours.west.h1x[idx]  = d_scale_coeffs.eta1x[west] - d_scale_coeffs.z1x[west];
		d_neighbours.west.qx1x[idx] = d_scale_coeffs.qx1x[west];
		d_neighbours.west.qy1x[idx] = d_scale_coeffs.qy1x[west];
		d_neighbours.west.z1x[idx]  = d_scale_coeffs.z1x[west];

		d_assem_sol.h1y[idx]  = d_scale_coeffs.eta1y[soln] - d_scale_coeffs.z1y[soln];
		d_assem_sol.qx1y[idx] = d_scale_coeffs.qx1y[soln];
		d_assem_sol.qy1y[idx] = d_scale_coeffs.qy1y[soln];
		d_assem_sol.z1y[idx]  = d_scale_coeffs.z1y[soln];

		d_neighbours.north.h1y[idx]  = d_scale_coeffs.eta1y[north] - d_scale_coeffs.z1y[north];
		d_neighbours.north.qx1y[idx] = d_scale_coeffs.qx1y[north];
		d_neighbours.north.qy1y[idx] = d_scale_coeffs.qy1y[north];
		d_neighbours.north.z1y[idx]  = d_scale_coeffs.z1y[north];

		d_neighbours.east.h1y[idx]  = d_scale_coeffs.eta1y[east] - d_scale_coeffs.z1y[east];
		d_neighbours.east.qx1y[idx] = d_scale_coeffs.qx1y[east];
		d_neighbours.east.qy1y[idx] = d_scale_coeffs.qy1y[east];
		d_neighbours.east.z1y[idx]  = d_scale_coeffs.z1y[east];

		d_neighbours.south.h1y[idx]  = d_scale_coeffs.eta1y[south] - d_scale_coeffs.z1y[south];
		d_neighbours.south.qx1y[idx] = d_scale_coeffs.qx1y[south];
		d_neighbours.south.qy1y[idx] = d_scale_coeffs.qy1y[south];
		d_neighbours.south.z1y[idx]  = d_scale_coeffs.z1y[south];

		d_neighbours.west.h1y[idx]  = d_scale_coeffs.eta1y[west] - d_scale_coeffs.z1y[west];
		d_neighbours.west.qx1y[idx] = d_scale_coeffs.qx1y[west];
		d_neighbours.west.qy1y[idx] = d_scale_coeffs.qy1y[west];
		d_neighbours.west.z1y[idx]  = d_scale_coeffs.z1y[west];
	}
}
#pragma once

#include "device_launch_parameters.h"

#include "cub/block/block_radix_sort.cuh"

#include "../classes/Neighbours.h"
#include "../classes/ScaleCoefficients.h"
#include "../classes/AssembledSolution.h"
#include "../classes/SolverParams.h"

__global__
void load_soln_and_nghbr_coeffs
(
	Neighbours        d_neighbours,
	ScaleCoefficients d_scale_coeffs,
	AssembledSolution d_assem_sol,
	SolverParams  solver_params
);
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

__device__ __forceinline__
void apply_friction
(
	const real& h,
	const real& tol_h,
	const real& tol_s,
	real&       qx,
	real&       qy,
	const real& n,
	const real& g,
	const real& dt
)
{
	bool below_depth = (h < tol_h);
	
	if (below_depth)
	{
		qx = C(0.0);
		qy = C(0.0);

		return;
	}
	
	real ux = qx / h;
	real uy = qy / h;

	if (abs(ux) < tol_s && abs(uy) < tol_s)
	{
		qx = C(0.0);
		qy = C(0.0);

		return;
	}

	real Cf = g * n * n / pow( h, C(1.0) / C(3.0) );

	real speed = sqrt(ux * ux + uy * uy);

	real Sf_x = -Cf * ux * speed;
	real Sf_y = -Cf * uy * speed;

	real D_x = C(1.0) + dt * Cf / h * (C(2.0) * ux * ux + uy * uy) / speed;
	real D_y = C(1.0) + dt * Cf / h * (C(2.0) * uy * uy + ux * ux) / speed;

	qx += dt * Sf_x / D_x;
	qy += dt * Sf_y / D_y;
}
target_sources(
	    gpu-mwdg2
		PRIVATE
		copy_to_buf_assem_sol.cu
		dg2_update.cu
		friction_implicit.cu
		fv1_update.cu
		get_dt_CFL.cu
		limit_slopes.cu
	)
#include "copy_to_buf_assem_sol.cuh"

__host__
void copy_to_buf_assem_sol
(
	const AssembledSolution& d_assem_sol,
	AssembledSolution&       d_buf_assem_sol
)
{
	size_t bytes_real     = d_assem_sol.length * sizeof(real);
	size_t bytes_int      = d_assem_sol.length * sizeof(int);
	size_t bytes_hier_idx = d_assem_sol.length * sizeof(HierarchyIndex);
	
	copy_cuda( d_buf_assem_sol.h0,        d_assem_sol.h0,        bytes_real );
	copy_cuda( d_buf_assem_sol.h1x,       d_assem_sol.h1x,       bytes_real );
	copy_cuda( d_buf_assem_sol.h1y,       d_assem_sol.h1y,       bytes_real );
	copy_cuda( d_buf_assem_sol.qx0,       d_assem_sol.qx0,       bytes_real );
	copy_cuda( d_buf_assem_sol.qx1x,      d_assem_sol.qx1x,      bytes_real );
	copy_cuda( d_buf_assem_sol.qx1y,      d_assem_sol.qx1y,      bytes_real );
	copy_cuda( d_buf_assem_sol.qy0,       d_assem_sol.qy0,       bytes_real );
	copy_cuda( d_buf_assem_sol.qy1x,      d_assem_sol.qy1x,      bytes_real );
	copy_cuda( d_buf_assem_sol.qy1y,      d_assem_sol.qy1y,      bytes_real );
	copy_cuda( d_buf_assem_sol.z0,        d_assem_sol.z0,        bytes_real );
	copy_cuda( d_buf_assem_sol.z1x,       d_assem_sol.z1x,       bytes_real );
	copy_cuda( d_buf_assem_sol.z1y,       d_assem_sol.z1y,       bytes_real );
	copy_cuda( d_buf_assem_sol.levels,    d_assem_sol.levels,    bytes_int );
	copy_cuda( d_buf_assem_sol.act_idcs,  d_assem_sol.act_idcs,  bytes_hier_idx );
			
	d_buf_assem_sol.length = d_assem_sol.length;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "../classes/AssembledSolution.h"

__host__
void copy_to_buf_assem_sol
(
	const AssembledSolution& d_assem_sol,
	AssembledSolution&       d_buf_assem_sol
);
#include "dg2_update.cuh"

__global__
void dg2_update
(
    Neighbours        d_neighbours,
    AssembledSolution d_assem_sol_load,
    AssembledSolution d_assem_sol_store,
    SolverParams      solver_params,
    SimulationParams  sim_params,
    real              dx_finest,
    real              dy_finest,
    real              dt,
    int               test_case,
    real*             d_dt_CFL,
    bool              rkdg2
)
{
    typedef cub::BlockScan<int, THREADS_PER_BLOCK> block_scan;

    __shared__ union
    {
        typename block_scan::TempStorage temp_storage;
        HierarchyIndex indices[THREADS_PER_BLOCK];

    } shared;

    int t_idx = threadIdx.x;
    int idx   = blockIdx.x * blockDim.x + t_idx;
    
    int is_wet = 0;

    int thread_prefix_sum = 0;

    int num_wet = 0;

    if (idx < d_assem_sol_load.length)
    {
        real z   = d_assem_sol_load.z0[idx];
        real h   = d_assem_sol_load.h0[idx];
        real h_n = d_neighbours.north.h0[idx];
        real h_e = d_neighbours.east.h0[idx];
        real h_s = d_neighbours.south.h0[idx];
        real h_w = d_neighbours.west.h0[idx];

        bool highwall = ( ( fabs( z - solver_params.wall_height ) < C(1e-10) ) && (test_case == 0) );

        is_wet =
        (
            (
                h   >= solver_params.tol_h ||
                h_n >= solver_params.tol_h ||
                h_e >= solver_params.tol_h ||
                h_s >= solver_params.tol_h ||
                h_w >= solver_params.tol_h
            )
            &&
            !highwall
        );

        d_dt_CFL[idx] = solver_params.initial_tstep;
    }

    block_scan(shared.temp_storage).ExclusiveSum
    (
        is_wet,
        thread_prefix_sum,
        num_wet
    );

    __syncthreads();

    if (is_wet) shared.indices[thread_prefix_sum] = idx;

    __syncthreads();

    if (t_idx >= num_wet) return;

    idx = shared.indices[t_idx];

    int level = d_assem_sol_load.levels[idx];
    
    real dx_loc = dx_finest * ( 1 << (solver_params.L - level) );
    real dy_loc = dy_finest * ( 1 << (solver_params.L - level) );
    
    HierarchyIndex h_idx   = d_assem_sol_load.act_idcs[idx];
    
    real x = get_x_coord(h_idx, level, solver_params.L, dx_finest);
    real y = get_y_coord(h_idx, level, solver_params.L, dy_finest);
    
    if ( (x >= sim_params.xsz * dx_finest) || (y >= sim_params.ysz * dy_finest) ) return;
    
    int level_n = d_neighbours.north.levels[idx];
    int level_e = d_neighbours.east.levels[idx];
    int level_s = d_neighbours.south.levels[idx];
    int level_w = d_neighbours.west.levels[idx];

    HierarchyIndex h_idx_n = d_neighbours.north.act_idcs[idx];
    HierarchyIndex h_idx_e = d_neighbours.east.act_idcs[idx];
    HierarchyIndex h_idx_s = d_neighbours.south.act_idcs[idx];
    HierarchyIndex h_idx_w = d_neighbours.west.act_idcs[idx];

    // between local && east,  x, y unit is (1.0, 0.5)
    // between local && west,  x, y unit is (0.0, 0.5)
    // between local && north, x, y unit is (0.5, 1.0)
    // between local && south, x, y unit is (0.5, 0.0)
    
    LegendreBasis basis_n = get_leg_basis(h_idx, h_idx_n, level_n, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, NORTH);
    LegendreBasis basis_e = get_leg_basis(h_idx, h_idx_e, level_e, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, EAST);
    LegendreBasis basis_s = get_leg_basis(h_idx, h_idx_s, level_s, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, SOUTH);
    LegendreBasis basis_w = get_leg_basis(h_idx, h_idx_w, level_w, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, WEST);
    
    LegendreBasis basis_n_loc = { C(1.0), C(0.0), sqrt( C(3.0) ) } ;
    LegendreBasis basis_e_loc = { C(1.0), sqrt( C(3.0) ), C(0.0) } ;
    LegendreBasis basis_s_loc = { C(1.0), C(0.0), -sqrt( C(3.0) ) };
    LegendreBasis basis_w_loc = { C(1.0), -sqrt( C(3.0) ), C(0.0) };
    
    FlowCoeffs coeffs =
    {
        {
            d_assem_sol_load.h0[idx],
            d_assem_sol_load.h1x[idx],
            d_assem_sol_load.h1y[idx],
        },
        {
            d_assem_sol_load.qx0[idx],
            d_assem_sol_load.qx1x[idx],
            d_assem_sol_load.qx1y[idx],
        },
        {
            d_assem_sol_load.qy0[idx],
            d_assem_sol_load.qy1x[idx],
            d_assem_sol_load.qy1y[idx],
        }
    };
    
    FlowCoeffs coeffs_n =
    {
        {
            d_neighbours.north.h0[idx],
            d_neighbours.north.h1x[idx],
            d_neighbours.north.h1y[idx],
        },
        {
            d_neighbours.north.qx0[idx],
            d_neighbours.north.qx1x[idx],
            d_neighbours.north.qx1y[idx],
        },
        {
            d_neighbours.north.qy0[idx],
            d_neighbours.north.qy1x[idx],
            d_neighbours.north.qy1y[idx],
        }
    };
    
    FlowCoeffs coeffs_e =
    {
        {
            d_neighbours.east.h0[idx],
            d_neighbours.east.h1x[idx],
            d_neighbours.east.h1y[idx],
        },
        {
            d_neighbours.east.qx0[idx],
            d_neighbours.east.qx1x[idx],
            d_neighbours.east.qx1y[idx],
        },
        {
            d_neighbours.east.qy0[idx],
            d_neighbours.east.qy1x[idx],
            d_neighbours.east.qy1y[idx],
        }
    };
    
    FlowCoeffs coeffs_s =
    {
        {
            d_neighbours.south.h0[idx],
            d_neighbours.south.h1x[idx],
            d_neighbours.south.h1y[idx],
        },
        {
            d_neighbours.south.qx0[idx],
            d_neighbours.south.qx1x[idx],
            d_neighbours.south.qx1y[idx],
        },
        {
            d_neighbours.south.qy0[idx],
            d_neighbours.south.qy1x[idx],
            d_neighbours.south.qy1y[idx],
        }
    };
    
    FlowCoeffs coeffs_w =
    {
        {
            d_neighbours.west.h0[idx],
            d_neighbours.west.h1x[idx],
            d_neighbours.west.h1y[idx],
        },
        {
            d_neighbours.west.qx0[idx],
            d_neighbours.west.qx1x[idx],
            d_neighbours.west.qx1y[idx],
        },
        {
            d_neighbours.west.qy0[idx],
            d_neighbours.west.qy1x[idx],
            d_neighbours.west.qy1y[idx],
        }
    };

    PlanarCoefficients z_planar   = { d_assem_sol_load.z0[idx],   d_assem_sol_load.z1x[idx],   d_assem_sol_load.z1y[idx] };
    PlanarCoefficients z_planar_n = { d_neighbours.north.z0[idx], d_neighbours.north.z1x[idx], d_neighbours.north.z1y[idx] };
    PlanarCoefficients z_planar_e = { d_neighbours.east.z0[idx],  d_neighbours.east.z1x[idx],  d_neighbours.east.z1y[idx] };
    PlanarCoefficients z_planar_s = { d_neighbours.south.z0[idx], d_neighbours.south.z1x[idx], d_neighbours.south.z1y[idx] };
    PlanarCoefficients z_planar_w = { d_neighbours.west.z0[idx],  d_neighbours.west.z1x[idx],  d_neighbours.west.z1y[idx] };

    // LFVs from neighbour cells
    real z_n_pos = eval_loc_face_val_dg2(z_planar_n, basis_n);
    real z_e_pos = eval_loc_face_val_dg2(z_planar_e, basis_e);
    real z_s_neg = eval_loc_face_val_dg2(z_planar_s, basis_s);
    real z_w_neg = eval_loc_face_val_dg2(z_planar_w, basis_w);

    // LFVs of local cell
    real z_n_neg = eval_loc_face_val_dg2(z_planar, basis_n_loc);
    real z_e_neg = eval_loc_face_val_dg2(z_planar, basis_e_loc);
    real z_s_pos = eval_loc_face_val_dg2(z_planar, basis_s_loc);
    real z_w_pos = eval_loc_face_val_dg2(z_planar, basis_w_loc);

    real z_inter_n = max(z_n_neg, z_n_pos);
    real z_inter_e = max(z_e_neg, z_e_pos);
    real z_inter_s = max(z_s_neg, z_s_pos);
    real z_inter_w = max(z_w_neg, z_w_pos);
    
    // LFVs from neighbour cells
    FlowVector Ustar_n_pos = coeffs_n.local_face_val(basis_n).get_star(z_n_pos, z_inter_n, solver_params.tol_h);
    FlowVector Ustar_e_pos = coeffs_e.local_face_val(basis_e).get_star(z_e_pos, z_inter_e, solver_params.tol_h);
    FlowVector Ustar_s_neg = coeffs_s.local_face_val(basis_s).get_star(z_s_neg, z_inter_s, solver_params.tol_h);
    FlowVector Ustar_w_neg = coeffs_w.local_face_val(basis_w).get_star(z_w_neg, z_inter_w, solver_params.tol_h);

    // LFVs of local cell
    FlowVector Ustar_n_neg = coeffs.local_face_val(basis_n_loc).get_star(z_n_neg, z_inter_n, solver_params.tol_h);
    FlowVector Ustar_e_neg = coeffs.local_face_val(basis_e_loc).get_star(z_e_neg, z_inter_e, solver_params.tol_h);
    FlowVector Ustar_s_pos = coeffs.local_face_val(basis_s_loc).get_star(z_s_pos, z_inter_s, solver_params.tol_h);
    FlowVector Ustar_w_pos = coeffs.local_face_val(basis_w_loc).get_star(z_w_pos, z_inter_w, solver_params.tol_h);

    FlowVector F_n = flux_HLL_y(Ustar_n_neg, Ustar_n_pos, solver_params, sim_params);
    FlowVector F_e = flux_HLL_x(Ustar_e_neg, Ustar_e_pos, solver_params, sim_params);
    FlowVector F_s = flux_HLL_y(Ustar_s_neg, Ustar_s_pos, solver_params, sim_params);
    FlowVector F_w = flux_HLL_x(Ustar_w_neg, Ustar_w_pos, solver_params, sim_params);
    
    FlowVector U0x_star = (Ustar_e_neg + Ustar_w_pos) /   C(2.0);
    FlowVector U1x_star = (Ustar_e_neg - Ustar_w_pos) / ( C(2.0) * sqrt( C(3.0) ) );

    FlowCoeffs Lx = {};

    Lx.set_0(-C(1.0) * (F_e - F_w) / dx_loc);

    Lx.set_1x
    (
        -sqrt( C(3.0) ) / dx_loc *
        (
            F_e + F_w
            - (U0x_star - U1x_star).phys_flux_x(solver_params.tol_h, sim_params.g)
            - (U0x_star + U1x_star).phys_flux_x(solver_params.tol_h, sim_params.g)
        )
    );

    Lx += get_bed_src_x
    (
        coeffs.local_face_val(basis_e_loc).h + z_e_neg,
        coeffs.local_face_val(basis_w_loc).h + z_w_pos,
        z_inter_e,
        z_inter_w,
        U0x_star.h,
        U1x_star.h,
        sim_params.g,
        dx_loc,
        coeffs,
        idx
    );

    FlowVector U0y_star = (Ustar_n_neg + Ustar_s_pos) /   C(2.0);
    FlowVector U1y_star = (Ustar_n_neg - Ustar_s_pos) / ( C(2.0) * sqrt(C(3.0) ) );

    FlowCoeffs Ly = {};

    Ly.set_0(-C(1.0) * (F_n - F_s) / dy_loc);

    Ly.set_1y
    (
        -sqrt( C(3.0) ) / dy_loc *
        (
            F_s + F_n
            - (U0y_star - U1y_star).phys_flux_y(solver_params.tol_h, sim_params.g)
            - (U0y_star + U1y_star).phys_flux_y(solver_params.tol_h, sim_params.g)
        )
    );
    
    Ly += get_bed_src_y
    (
        coeffs.local_face_val(basis_n_loc).h + z_n_neg,
        coeffs.local_face_val(basis_s_loc).h + z_s_pos,
        z_inter_n,
        z_inter_s,
        U0y_star.h,
        U1y_star.h,
        sim_params.g,
        dy_loc,
        coeffs
    );

    coeffs += dt * (Lx + Ly);

    real& h0   = d_assem_sol_store.h0[idx]  ;
    real& h1x  = d_assem_sol_store.h1x[idx] ;
    real& h1y  = d_assem_sol_store.h1y[idx] ;
    real& qx0  = d_assem_sol_store.qx0[idx] ;
    real& qx1x = d_assem_sol_store.qx1x[idx];
    real& qx1y = d_assem_sol_store.qx1y[idx];
    real& qy0  = d_assem_sol_store.qy0[idx] ;
    real& qy1x = d_assem_sol_store.qy1x[idx];
    real& qy1y = d_assem_sol_store.qy1y[idx];

    h0   = (rkdg2) ? C(0.5) * (coeffs.h._0   + h0  ) : coeffs.h._0  ;
    h1x  = (rkdg2) ? C(0.5) * (coeffs.h._1x  + h1x ) : coeffs.h._1x ;
    h1y  = (rkdg2) ? C(0.5) * (coeffs.h._1y  + h1y ) : coeffs.h._1y ;
    qx0  = (rkdg2) ? C(0.5) * (coeffs.qx._0  + qx0 ) : coeffs.qx._0 ;
    qx1x = (rkdg2) ? C(0.5) * (coeffs.qx._1x + qx1x) : coeffs.qx._1x;
    qx1y = (rkdg2) ? C(0.5) * (coeffs.qx._1y + qx1y) : coeffs.qx._1y;
    qy0  = (rkdg2) ? C(0.5) * (coeffs.qy._0  + qy0 ) : coeffs.qy._0 ;
    qy1x = (rkdg2) ? C(0.5) * (coeffs.qy._1x + qy1x) : coeffs.qy._1x;
    qy1y = (rkdg2) ? C(0.5) * (coeffs.qy._1y + qy1y) : coeffs.qy._1y;
    
    const bool below_depth = (h0 < solver_params.tol_h);

    if (below_depth)
    {
        qx0  = C(0.0);
        qx1x = C(0.0);
        qx1y = C(0.0);
        
        qy0  = C(0.0);
        qy1x = C(0.0);
        qy1y = C(0.0);
    }

    if (!below_depth)
    {
        real ux = qx0 / h0;
        real uy = qy0 / h0;
        
        real dt_x = solver_params.CFL * dx_loc / ( abs(ux) + sqrt(sim_params.g * h0) );
        real dt_y = solver_params.CFL * dy_loc / ( abs(uy) + sqrt(sim_params.g * h0) );

        d_dt_CFL[idx] = min(dt_x, dt_y);
    }
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../types/MortonCode.h"
#include "../classes/Neighbours.h"
#include "../classes/FlowCoeffs.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"
#include "../classes/FlowVector.h"

#include "get_leg_basis.cuh"
#include "get_bed_src.cuh"
#include "flux_HLL.cuh"

__global__
void dg2_update
(
    Neighbours        d_neighbours,
    AssembledSolution d_assem_sol_load,
    AssembledSolution d_assem_sol_store,
    SolverParams      solver_params,
    SimulationParams  sim_params,
    real              dx_finest,
    real              dy_finest,
    real              dt,
    int               test_case,
    real*             d_dt_CFL,
    bool              rkdg2
);
#pragma once

#include "../classes/FlowVector.h"
#include "../classes/PlanarCoefficients.h"
#include "../classes/LegendreBasis.h"

__host__ __device__ __forceinline__
real eval_loc_face_val_dg2
(
	const PlanarCoefficients& s,
	const LegendreBasis&      basis
)
{
	return s._0 * basis._0 + s._1x * basis._1x + s._1y * basis._1y;
}
#pragma once

#include "cuda_runtime.h"

#include "../classes/FlowVector.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"

__device__ __forceinline__
FlowVector flux_HLL_x
(
	const FlowVector&           U_neg,
	const FlowVector&           U_pos,
	const SolverParams&     solver_params,
	const SimulationParams& sim_params
)
{
	if (U_neg.h < solver_params.tol_h && U_pos.h < solver_params.tol_h) return FlowVector();

	const real h_neg = (U_neg.h < solver_params.tol_h) ? C(0.0) : U_neg.h;
	const real u_neg = (U_neg.h < solver_params.tol_h) ? C(0.0) : U_neg.qx / U_neg.h;
	const real v_neg = (U_neg.h < solver_params.tol_h) ? C(0.0) : U_neg.qy / U_neg.h;
	
	const real h_pos = (U_pos.h < solver_params.tol_h) ? C(0.0) : U_pos.h;
	const real u_pos = (U_pos.h < solver_params.tol_h) ? C(0.0) : U_pos.qx / U_pos.h;
	const real v_pos = (U_pos.h < solver_params.tol_h) ? C(0.0) : U_pos.qy / U_pos.h;
	
	const real a_neg = sqrt(sim_params.g * h_neg);
	const real a_pos = sqrt(sim_params.g * h_pos);
	
	const real h_star = 
		( C(0.5) * (a_neg + a_pos) + C(0.25) * (u_neg - u_pos) ) * ( C(0.5) * (a_neg + a_pos) + C(0.25) * (u_neg - u_pos) )
		/
		sim_params.g;

	const real u_star = C(0.5) * (u_neg + u_pos) + a_neg - a_pos;
	
	const real a_star = sqrt(sim_params.g * h_star);
	
	const real s_neg = (h_neg < solver_params.tol_h) ? u_pos - C(2.0) * a_pos : min(u_neg - a_neg, u_star - a_star);
	const real s_pos = (h_pos < solver_params.tol_h) ? u_neg + C(2.0) * a_neg : max(u_pos + a_pos, u_star + a_star);
	
	const FlowVector F_neg =
	{
		U_neg.qx,
		u_neg * U_neg.qx + C(0.5) * sim_params.g * h_neg * h_neg,
		U_neg.qy * u_neg
	};

	const FlowVector F_pos =
	{
		U_pos.qx,
		u_pos * U_pos.qx + C(0.5) * sim_params.g * h_pos * h_pos,
		U_pos.qy * u_pos
	};

	if ( s_neg >= C(0.0) )
	{
		return F_neg;
	}
	else if ( s_neg < C(0.0) && s_pos >= C(0.0) )
	{
		FlowVector F = {};

		F.h =
			( s_pos * F_neg.h - s_neg * F_pos.h + s_neg * s_pos * (h_pos - h_neg) )
			/
			(s_pos - s_neg);

		F.qx =
			( s_pos * F_neg.qx - s_neg * F_pos.qx + s_neg * s_pos * (U_pos.qx - U_neg.qx) )
			/
			(s_pos - s_neg);

		const real s_mid =
			( s_neg * h_pos * (u_pos - s_pos) - s_pos * h_neg * (u_neg - s_neg) )
			/
			( h_pos * (u_pos - s_pos) - h_neg * (u_neg - s_neg) );

		F.qy = ( s_neg < C(0.0) && s_mid >= C(0.0) ) ? F.h * v_neg : F.h * v_pos;
			
		return F;
	}
	else
	{
		return F_pos;
	}
}

__device__ __forceinline__
FlowVector flux_HLL_y
(
	const FlowVector&           U_neg,
	const FlowVector&           U_pos,
	const SolverParams&     solver_params,
	const SimulationParams& sim_params
)
{
	FlowVector U_neg_rotated = { U_neg.h, U_neg.qy, -U_neg.qx };
	FlowVector U_pos_rotated = { U_pos.h, U_pos.qy, -U_pos.qx };

	FlowVector F_rotated = flux_HLL_x
	(
		U_neg_rotated, 
		U_pos_rotated, 
		solver_params, 
		sim_params
	);

	return { F_rotated.h, -F_rotated.qy, F_rotated.qx };
}
#include "friction_implicit.cuh"

__global__
void friction_implicit
(
	AssembledSolution    d_assem_sol,
	Neighbours           d_neighbours,
	SolverParams     solver_params,
	SimulationParams sim_params,
	real                 dt
)
{
	typedef cub::BlockScan<int, THREADS_PER_BLOCK> block_scan;

	__shared__ union
	{
		typename block_scan::TempStorage temp_storage;
		HierarchyIndex indices[THREADS_PER_BLOCK];

	} shared;
	
	HierarchyIndex t_idx = threadIdx.x;
	HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;

	int above_thresh = 0;

	int thread_prefix_sum = 0;

	int num_fric = 0;

	if (idx < d_assem_sol.length)
	{
		real  h  = d_assem_sol.h0[idx];
		real& qx = d_assem_sol.qx0[idx];
		real& qy = d_assem_sol.qy0[idx];

		int below_depth = (h < solver_params.tol_h);
		
		real ux = (below_depth) ? C(0.0) : qx / h;
		real uy = (below_depth) ? C(0.0) : qy / h;

		int below_speed = (abs(ux) < solver_params.tol_s && abs(uy) < solver_params.tol_s);

		if (below_depth || below_speed)
		{
			qx = C(0.0);
			qy = C(0.0);
		}

		above_thresh = !(below_depth || below_speed);
	}

	block_scan(shared.temp_storage).ExclusiveSum
	(
		above_thresh,
		thread_prefix_sum,
		num_fric
	);

	__syncthreads();

	if (above_thresh) shared.indices[thread_prefix_sum] = idx;

	__syncthreads();

	if (t_idx >= num_fric) return;

	idx = shared.indices[t_idx];

	real n = sim_params.manning;

	real  h   = d_assem_sol.h0[idx];
	real  h_n = d_neighbours.north.h0[idx];
	real  h_e = d_neighbours.east.h0[idx];
	real  h_s = d_neighbours.south.h0[idx];
	real  h_w = d_neighbours.west.h0[idx];

	real& qx   = d_assem_sol.qx0[idx];
	real& qx_n = d_neighbours.north.qx0[idx];
	real& qx_e = d_neighbours.east.qx0[idx];
	real& qx_s = d_neighbours.south.qx0[idx];
	real& qx_w = d_neighbours.west.qx0[idx];

	real& qy   = d_assem_sol.qy0[idx];
	real& qy_n = d_neighbours.north.qy0[idx];
	real& qy_e = d_neighbours.east.qy0[idx];
	real& qy_s = d_neighbours.south.qy0[idx];
	real& qy_w = d_neighbours.west.qy0[idx];
	
	const real tol_h = solver_params.tol_h;
	const real tol_s = solver_params.tol_s;

	if (solver_params.solver_type == HWFV1)
	{
		apply_friction(h,   tol_h, tol_s, qx,   qy,   sim_params.manning, sim_params.g, dt);
		apply_friction(h_n, tol_h, tol_s, qx_n, qy_n, sim_params.manning, sim_params.g, dt);
		apply_friction(h_e, tol_h, tol_s, qx_e, qy_e, sim_params.manning, sim_params.g, dt);
		apply_friction(h_s, tol_h, tol_s, qx_s, qy_s, sim_params.manning, sim_params.g, dt);
		apply_friction(h_w, tol_h, tol_s, qx_w, qy_w, sim_params.manning, sim_params.g, dt);
	}
	else if (solver_params.solver_type == MWDG2)
	{
		real  h1x   = d_assem_sol.h1x[idx];
		real  h1x_n = d_neighbours.north.h1x[idx];
		real  h1x_e = d_neighbours.east.h1x[idx];
		real  h1x_s = d_neighbours.south.h1x[idx];
		real  h1x_w = d_neighbours.west.h1x[idx];

		real& qx1x   = d_assem_sol.qx1x[idx];
		real& qx1x_n = d_neighbours.north.qx1x[idx];
		real& qx1x_e = d_neighbours.east.qx1x[idx];
		real& qx1x_s = d_neighbours.south.qx1x[idx];
		real& qx1x_w = d_neighbours.west.qx1x[idx];

		real& qy1x   = d_assem_sol.qy1x[idx];
		real& qy1x_n = d_neighbours.north.qy1x[idx];
		real& qy1x_e = d_neighbours.east.qy1x[idx];
		real& qy1x_s = d_neighbours.south.qy1x[idx];
		real& qy1x_w = d_neighbours.west.qy1x[idx];

		real  h1y   = d_assem_sol.h1y[idx];
		real  h1y_n = d_neighbours.north.h1y[idx];
		real  h1y_e = d_neighbours.east.h1y[idx];
		real  h1y_s = d_neighbours.south.h1y[idx];
		real  h1y_w = d_neighbours.west.h1y[idx];

		real& qx1y   = d_assem_sol.qx1y[idx];
		real& qx1y_n = d_neighbours.north.qx1y[idx];
		real& qx1y_e = d_neighbours.east.qx1y[idx];
		real& qx1y_s = d_neighbours.south.qx1y[idx];
		real& qx1y_w = d_neighbours.west.qx1y[idx];

		real& qy1y   = d_assem_sol.qy1y[idx];
		real& qy1y_n = d_neighbours.north.qy1y[idx];
		real& qy1y_e = d_neighbours.east.qy1y[idx];
		real& qy1y_s = d_neighbours.south.qy1y[idx];
		real& qy1y_w = d_neighbours.west.qy1y[idx];

		real h_gauss_lower_x   = h   - h1x;
		real h_gauss_lower_x_n = h_n - h1x_n;
		real h_gauss_lower_x_e = h_e - h1x_e;
		real h_gauss_lower_x_s = h_s - h1x_s;
		real h_gauss_lower_x_w = h_w - h1x_w;
		
		real h_gauss_upper_x   = h   + h1x;
		real h_gauss_upper_x_n = h_n + h1x_n;
		real h_gauss_upper_x_e = h_e + h1x_e;
		real h_gauss_upper_x_s = h_s + h1x_s;
		real h_gauss_upper_x_w = h_w + h1x_w;
		
		real h_gauss_lower_y   = h   - h1y;
		real h_gauss_lower_y_n = h_n - h1y_n;
		real h_gauss_lower_y_e = h_e - h1y_e;
		real h_gauss_lower_y_s = h_s - h1y_s;
		real h_gauss_lower_y_w = h_w - h1y_w;
		
		real h_gauss_upper_y   = h   + h1y;
		real h_gauss_upper_y_n = h_n + h1y_n;
		real h_gauss_upper_y_e = h_e + h1y_e;
		real h_gauss_upper_y_s = h_s + h1y_s;
		real h_gauss_upper_y_w = h_w + h1y_w;
		
		real qx_gauss_lower_x   = qx   - qx1x;
		real qx_gauss_lower_x_n = qx_n - qx1x_n;
		real qx_gauss_lower_x_e = qx_e - qx1x_e;
		real qx_gauss_lower_x_s = qx_s - qx1x_s;
		real qx_gauss_lower_x_w = qx_w - qx1x_w;
		
		real qx_gauss_upper_x   = qx   + qx1x;
		real qx_gauss_upper_x_n = qx_n + qx1x_n;
		real qx_gauss_upper_x_e = qx_e + qx1x_e;
		real qx_gauss_upper_x_s = qx_s + qx1x_s;
		real qx_gauss_upper_x_w = qx_w + qx1x_w;
		
		real qx_gauss_lower_y   = qx   - qx1y;
		real qx_gauss_lower_y_n = qx_n - qx1y_n;
		real qx_gauss_lower_y_e = qx_e - qx1y_e;
		real qx_gauss_lower_y_s = qx_s - qx1y_s;
		real qx_gauss_lower_y_w = qx_w - qx1y_w;
		
		real qx_gauss_upper_y   = qx   + qx1y;
		real qx_gauss_upper_y_n = qx_n + qx1y_n;
		real qx_gauss_upper_y_e = qx_e + qx1y_e;
		real qx_gauss_upper_y_s = qx_s + qx1y_s;
		real qx_gauss_upper_y_w = qx_w + qx1y_w;
		
		real qy_gauss_lower_x   = qy   - qy1x;
		real qy_gauss_lower_x_n = qy_n - qy1x_n;
		real qy_gauss_lower_x_e = qy_e - qy1x_e;
		real qy_gauss_lower_x_s = qy_s - qy1x_s;
		real qy_gauss_lower_x_w = qy_w - qy1x_w;
		
		real qy_gauss_upper_x   = qy   + qy1x;
		real qy_gauss_upper_x_n = qy_n + qy1x_n;
		real qy_gauss_upper_x_e = qy_e + qy1x_e;
		real qy_gauss_upper_x_s = qy_s + qy1x_s;
		real qy_gauss_upper_x_w = qy_w + qy1x_w;
		
		real qy_gauss_lower_y   = qy   - qy1y;
		real qy_gauss_lower_y_n = qy_n - qy1y_n;
		real qy_gauss_lower_y_e = qy_e - qy1y_e;
		real qy_gauss_lower_y_s = qy_s - qy1y_s;
		real qy_gauss_lower_y_w = qy_w - qy1y_w;
		
		real qy_gauss_upper_y   = qy   + qy1y;
		real qy_gauss_upper_y_n = qy_n + qy1y_n;
		real qy_gauss_upper_y_e = qy_e + qy1y_e;
		real qy_gauss_upper_y_s = qy_s + qy1y_s;
		real qy_gauss_upper_y_w = qy_w + qy1y_w;

		apply_friction(h,   tol_h, tol_s, qx,   qy,   sim_params.manning, sim_params.g, dt);
		apply_friction(h_n, tol_h, tol_s, qx_n, qy_n, sim_params.manning, sim_params.g, dt);
		apply_friction(h_e, tol_h, tol_s, qx_e, qy_e, sim_params.manning, sim_params.g, dt);
		apply_friction(h_s, tol_h, tol_s, qx_s, qy_s, sim_params.manning, sim_params.g, dt);
		apply_friction(h_w, tol_h, tol_s, qx_w, qy_w, sim_params.manning, sim_params.g, dt); 
		
		apply_friction(h_gauss_lower_x,   tol_h, tol_s, qx_gauss_lower_x,   qy_gauss_lower_x,   n, sim_params.g, dt);
		apply_friction(h_gauss_lower_x_n, tol_h, tol_s, qx_gauss_lower_x_n, qy_gauss_lower_x_n, n, sim_params.g, dt);
		apply_friction(h_gauss_lower_x_e, tol_h, tol_s, qx_gauss_lower_x_e, qy_gauss_lower_x_e, n, sim_params.g, dt);
		apply_friction(h_gauss_lower_x_s, tol_h, tol_s, qx_gauss_lower_x_s, qy_gauss_lower_x_s, n, sim_params.g, dt);
		apply_friction(h_gauss_lower_x_w, tol_h, tol_s, qx_gauss_lower_x_w, qy_gauss_lower_x_w, n, sim_params.g, dt);
		
		apply_friction(h_gauss_upper_x,   tol_h, tol_s, qx_gauss_upper_x,   qy_gauss_upper_x,   n, sim_params.g, dt);
		apply_friction(h_gauss_upper_x_n, tol_h, tol_s, qx_gauss_upper_x_n, qy_gauss_upper_x_n, n, sim_params.g, dt);
		apply_friction(h_gauss_upper_x_e, tol_h, tol_s, qx_gauss_upper_x_e, qy_gauss_upper_x_e, n, sim_params.g, dt);
		apply_friction(h_gauss_upper_x_s, tol_h, tol_s, qx_gauss_upper_x_s, qy_gauss_upper_x_s, n, sim_params.g, dt);
		apply_friction(h_gauss_upper_x_w, tol_h, tol_s, qx_gauss_upper_x_w, qy_gauss_upper_x_w, n, sim_params.g, dt);
		
		apply_friction(h_gauss_lower_y,   tol_h, tol_s, qx_gauss_lower_y,   qy_gauss_lower_y,   n, sim_params.g, dt);
		apply_friction(h_gauss_lower_y_n, tol_h, tol_s, qx_gauss_lower_y_n, qy_gauss_lower_y_n, n, sim_params.g, dt);
		apply_friction(h_gauss_lower_y_e, tol_h, tol_s, qx_gauss_lower_y_e, qy_gauss_lower_y_e, n, sim_params.g, dt);
		apply_friction(h_gauss_lower_y_s, tol_h, tol_s, qx_gauss_lower_y_s, qy_gauss_lower_y_s, n, sim_params.g, dt);
		apply_friction(h_gauss_lower_y_w, tol_h, tol_s, qx_gauss_lower_y_w, qy_gauss_lower_y_w, n, sim_params.g, dt);
		
		apply_friction(h_gauss_upper_y,   tol_h, tol_s, qx_gauss_upper_y,   qy_gauss_upper_y,   n, sim_params.g, dt);
		apply_friction(h_gauss_upper_y_n, tol_h, tol_s, qx_gauss_upper_y_n, qy_gauss_upper_y_n, n, sim_params.g, dt);
		apply_friction(h_gauss_upper_y_e, tol_h, tol_s, qx_gauss_upper_y_e, qy_gauss_upper_y_e, n, sim_params.g, dt);
		apply_friction(h_gauss_upper_y_s, tol_h, tol_s, qx_gauss_upper_y_s, qy_gauss_upper_y_s, n, sim_params.g, dt);
		apply_friction(h_gauss_upper_y_w, tol_h, tol_s, qx_gauss_upper_y_w, qy_gauss_upper_y_w, n, sim_params.g, dt);

		qx1x   = C(0.5) * (qx_gauss_upper_x   - qx_gauss_lower_x);
		qx1x_n = C(0.5) * (qx_gauss_upper_x_n - qx_gauss_lower_x_n);
		qx1x_e = C(0.5) * (qx_gauss_upper_x_e - qx_gauss_lower_x_e);
		qx1x_s = C(0.5) * (qx_gauss_upper_x_s - qx_gauss_lower_x_s);
		qx1x_w = C(0.5) * (qx_gauss_upper_x_w - qx_gauss_lower_x_w);
		
		qx1y   = C(0.5) * (qx_gauss_upper_y   - qx_gauss_lower_y);
		qx1y_n = C(0.5) * (qx_gauss_upper_y_n - qx_gauss_lower_y_n);
		qx1y_e = C(0.5) * (qx_gauss_upper_y_e - qx_gauss_lower_y_e);
		qx1y_s = C(0.5) * (qx_gauss_upper_y_s - qx_gauss_lower_y_s);
		qx1y_w = C(0.5) * (qx_gauss_upper_y_w - qx_gauss_lower_y_w);
		
		qy1x   = C(0.5) * (qy_gauss_upper_x   - qy_gauss_lower_x);
		qy1x_n = C(0.5) * (qy_gauss_upper_x_n - qy_gauss_lower_x_n);
		qy1x_e = C(0.5) * (qy_gauss_upper_x_e - qy_gauss_lower_x_e);
		qy1x_s = C(0.5) * (qy_gauss_upper_x_s - qy_gauss_lower_x_s);
		qy1x_w = C(0.5) * (qy_gauss_upper_x_w - qy_gauss_lower_x_w);

		qy1y   = C(0.5) * (qy_gauss_upper_y   - qy_gauss_lower_y);
		qy1y_n = C(0.5) * (qy_gauss_upper_y_n - qy_gauss_lower_y_n);
		qy1y_e = C(0.5) * (qy_gauss_upper_y_e - qy_gauss_lower_y_e);
		qy1y_s = C(0.5) * (qy_gauss_upper_y_s - qy_gauss_lower_y_s);
		qy1y_w = C(0.5) * (qy_gauss_upper_y_w - qy_gauss_lower_y_w);
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../classes/Neighbours.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"

#include "apply_friction.cuh"
#include "../zorder/generate_morton_code.cuh"

__global__
void friction_implicit
(
	AssembledSolution    d_assem_sol,
	Neighbours           d_neighbours,
	SolverParams     solver_params, 
	SimulationParams sim_params,
	real                 dt
);
#include "fv1_update.cuh"

__global__
void fv1_update
(
    Neighbours           d_neighbours,
    AssembledSolution    d_assem_sol,
    SolverParams     solver_params,
    SimulationParams sim_params,
    real                 dx_finest,
    real                 dy_finest,
    real                 dt,
    real*                d_dt_CFL
)
{
    typedef cub::BlockScan<int, THREADS_PER_BLOCK> block_scan;

    __shared__ union
    {
        typename block_scan::TempStorage temp_storage;
        HierarchyIndex indices[THREADS_PER_BLOCK];

    } shared;

    HierarchyIndex t_idx = threadIdx.x;
    HierarchyIndex idx   = blockIdx.x * blockDim.x + t_idx;
    
    int is_wet = 0;

    int thread_prefix_sum = 0;

    int num_wet = 0;

    if (idx < d_assem_sol.length)
    {
        real h   = d_assem_sol.h0[idx];
        real h_n = d_neighbours.north.h0[idx];
        real h_e = d_neighbours.east.h0[idx];
        real h_s = d_neighbours.south.h0[idx];
        real h_w = d_neighbours.west.h0[idx];

        is_wet =
        (
            h   >= solver_params.tol_h ||
            h_n >= solver_params.tol_h ||
            h_e >= solver_params.tol_h ||
            h_s >= solver_params.tol_h ||
            h_w >= solver_params.tol_h
        );

        d_dt_CFL[idx] = solver_params.initial_tstep;
    }

    block_scan(shared.temp_storage).ExclusiveSum
    (
        is_wet,
        thread_prefix_sum,
        num_wet
    );

    __syncthreads();

    if (is_wet) shared.indices[thread_prefix_sum] = idx;

    __syncthreads();

    if (t_idx >= num_wet) return;

    idx = shared.indices[t_idx];
    
    int level = d_assem_sol.levels[idx];

    real dx_loc = dx_finest * ( 1 << (solver_params.L - level) );
    real dy_loc = dy_finest * ( 1 << (solver_params.L - level) );

    real z  = d_assem_sol.z0[idx];
    real h  = d_assem_sol.h0[idx];
    real qx = d_assem_sol.qx0[idx];
    real qy = d_assem_sol.qy0[idx];

    real eta_n_neg = h + z;
    real eta_e_neg = h + z;
    real eta_s_pos = h + z;
    real eta_w_pos = h + z;

    real z_n = d_neighbours.north.z0[idx];
    real z_e = d_neighbours.east.z0[idx];
    real z_s = d_neighbours.south.z0[idx];
    real z_w = d_neighbours.west.z0[idx];

    real z_n_intermediate = max(z, z_n);
    real z_e_intermediate = max(z, z_e);
    real z_s_intermediate = max(z, z_s);
    real z_w_intermediate = max(z, z_w);
    
    FlowVector U_loc = 
    {
        h,
        qx,
        qy
    };
    
    FlowVector U_n_pos =
    {
        d_neighbours.north.h0[idx],
        d_neighbours.north.qx0[idx],
        d_neighbours.north.qy0[idx]
    };
    
    FlowVector U_e_pos =
    {
        d_neighbours.east.h0[idx],
        d_neighbours.east.qx0[idx],
        d_neighbours.east.qy0[idx]
    };
    
    FlowVector U_s_neg =
    {
        d_neighbours.south.h0[idx],
        d_neighbours.south.qx0[idx],
        d_neighbours.south.qy0[idx]
    };
    
    FlowVector U_w_neg =
    {
        d_neighbours.west.h0[idx],
        d_neighbours.west.qx0[idx],
        d_neighbours.west.qy0[idx]
    };

    // northern flux
    FlowVector U_n_neg      = U_loc;
    FlowVector U_star_n_neg = U_n_neg.get_star(z,   z_n_intermediate, solver_params.tol_h);
    FlowVector U_star_n_pos = U_n_pos.get_star(z_n, z_n_intermediate, solver_params.tol_h);
    
    FlowVector F_n = flux_HLL_y
    (
        U_star_n_neg, 
        U_star_n_pos, 
        solver_params, 
        sim_params
    );
    
    // eastern flux
    FlowVector U_e_neg      = U_loc;
    FlowVector U_star_e_neg = U_e_neg.get_star(z,   z_e_intermediate, solver_params.tol_h);
    FlowVector U_star_e_pos = U_e_pos.get_star(z_e, z_e_intermediate, solver_params.tol_h);

    FlowVector F_e = flux_HLL_x
    (
        U_star_e_neg, 
        U_star_e_pos, 
        solver_params, 
        sim_params
    );

    // southern flux
    FlowVector U_star_s_neg = U_s_neg.get_star(z_s, z_s_intermediate, solver_params.tol_h);
    FlowVector U_s_pos      = U_loc;
    FlowVector U_star_s_pos = U_s_pos.get_star(z,   z_s_intermediate, solver_params.tol_h);

    FlowVector F_s = flux_HLL_y
    (
        U_star_s_neg, 
        U_star_s_pos, 
        solver_params, 
        sim_params
    );
    
    // western flux
    FlowVector U_star_w_neg = U_w_neg.get_star(z_w, z_w_intermediate, solver_params.tol_h);
    FlowVector U_w_pos      = U_loc;
    FlowVector U_star_w_pos = U_w_pos.get_star(z,   z_w_intermediate, solver_params.tol_h);

    FlowVector F_w = flux_HLL_x
    (
        U_star_w_neg, 
        U_star_w_pos, 
        solver_params, 
        sim_params
    );

    real bed_src_x = get_bed_src_x
    (
        z_w_intermediate, 
        z_e_intermediate, 
        U_star_w_pos.h, 
        U_star_e_neg.h, 
        eta_w_pos, 
        eta_e_neg, 
        sim_params.g, 
        dx_loc,
        idx
    );

    real bed_src_y = get_bed_src_y
    (
        z_s_intermediate, 
        z_n_intermediate, 
        U_star_s_pos.h, 
        U_star_n_neg.h, 
        eta_s_pos, 
        eta_n_neg,
        sim_params.g, 
        dy_loc
    );
    
    // x dir update
    h  = h  - dt * (F_e.h - F_w.h) / dx_loc;
    qx = qx - dt * ( (F_e.qx - F_w.qx) / dx_loc + bed_src_x );
    qy = qy - dt * (F_e.qy - F_w.qy) / dx_loc;

    // y dir update
    h  = h  - dt * (F_n.h - F_s.h) / dy_loc;
    qx = qx - dt * (F_n.qx - F_s.qx) / dy_loc;  
    qy = qy - dt * ( (F_n.qy - F_s.qy) / dy_loc + bed_src_y );

    bool below_depth = (h < solver_params.tol_h);
    bool below_disch = (abs(qx) < solver_params.tol_q && abs(qy) < solver_params.tol_q);

    bool below_thres = (below_depth || below_disch);

    if (below_thres)
    {
        qx = C(0.0);
        qy = C(0.0);
    }
    
    if (!below_depth)
    {
        real ux = qx / h;
        real uy = qy / h; 
        
        real dt_x = solver_params.CFL * dx_loc / ( abs(ux) + sqrt(sim_params.g * h) );
        real dt_y = solver_params.CFL * dy_loc / ( abs(uy) + sqrt(sim_params.g * h) );

        d_dt_CFL[idx] = min(dt_x, dt_y);
    }
    
    d_assem_sol.h0 [idx] = h;
    d_assem_sol.qx0[idx] = qx;
    d_assem_sol.qy0[idx] = qy;
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "cub/block/block_scan.cuh"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include "../classes/Neighbours.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"
#include "../classes/FlowVector.h"

#include "flux_HLL.cuh"
#include "get_bed_src.cuh"

__global__
void fv1_update
(
    Neighbours        d_neighbours,
    AssembledSolution d_assem_sol,
    SolverParams      solver_params,
    SimulationParams  sim_params,
    real              dx_finest,
    real              dy_finest,
    real              dt,
    real*             d_dt_CFL
);

#pragma once

#include "cuda_runtime.h"

#include "../classes/FlowCoeffs.h"

__device__ __forceinline__
real get_bed_src_x
(
	const real& z_w_intermediate,
	const real& z_e_intermediate,
	const real& h_star_w_pos,
	const real& h_star_e_neg,
	const real& eta_w_pos,
	const real& eta_e_neg,
	const real& g,
	const real& dx_loc,
	int idx
)
{
	real z_star_w = z_w_intermediate - max( C(0.0), -(eta_w_pos - z_w_intermediate) );
	real z_star_e = z_e_intermediate - max( C(0.0), -(eta_e_neg - z_e_intermediate) );

	return g * C(0.5) * (h_star_w_pos + h_star_e_neg) * (z_star_e - z_star_w) / dx_loc;
}

__device__ __forceinline__
real get_bed_src_y
(
	const real& z_s_intermediate,
	const real& z_n_intermediate,
	const real& h_star_s_pos,
	const real& h_star_n_neg,
	const real& eta_s_pos,
	const real& eta_n_neg,
	const real& g,
	const real& dy_loc
)
{
	real z_star_s = z_s_intermediate - max( C(0.0), -(eta_s_pos - z_s_intermediate) );
	real z_star_n = z_n_intermediate - max( C(0.0), -(eta_n_neg - z_n_intermediate) );

	return g * C(0.5) * (h_star_s_pos + h_star_n_neg) * (z_star_n - z_star_s) / dy_loc;
}

__device__ __forceinline__
FlowCoeffs get_bed_src_x
(
	const real& eta_e_neg,
	const real& eta_w_pos,
	const real& z_inter_e,
	const real& z_inter_w,
	const real& h0x_star,
	const real& h1x_star,
	const real& g,
	const real& dx_loc,
	const FlowCoeffs& coeffs,
	int idx
)
{
	real z_star_e = z_inter_e - max( C(0.0), -(eta_e_neg - z_inter_e) );
	real z_star_w = z_inter_w - max( C(0.0), -(eta_w_pos - z_inter_w) );

	real z1x_star = (z_star_e - z_star_w) / (C(2.0) * sqrt(C(3.0)));

	FlowCoeffs Sbx = {};

	Sbx.qx._0  = -C(2.0) * sqrt(C(3.0)) * g * h0x_star * z1x_star / dx_loc;
	Sbx.qx._1x = -C(2.0) * sqrt(C(3.0)) * g * h1x_star * z1x_star / dx_loc;
	
	return Sbx;
}

__device__ __forceinline__
FlowCoeffs get_bed_src_y
(
	const real& eta_n_neg,
	const real& eta_s_pos,
	const real& z_inter_n,
	const real& z_inter_s,
	const real& h0y_star,
	const real& h1y_star,
	const real& g,
	const real& dy_loc,
	const FlowCoeffs& coeffs
)
{
	real z_star_n = z_inter_n - max( C(0.0), -(eta_n_neg - z_inter_n) );
	real z_star_s = z_inter_s - max( C(0.0), -(eta_s_pos - z_inter_s) );

	real z1y_star = (z_star_n - z_star_s) / ( C(2.0) * sqrt( C(3.0) ) );

	FlowCoeffs Sby = {};

	Sby.qy._0  = -C(2.0) * sqrt( C(3.0) ) * g * h0y_star * z1y_star / dy_loc;
	Sby.qy._1y = -C(2.0) * sqrt( C(3.0) ) * g * h1y_star * z1y_star / dy_loc;

	return Sby;
}
#include "get_dt_CFL.cuh"

__host__
real get_dt_CFL
(
	real*&     d_dt_CFL,
	const int& sol_len
)
{
	real* h_min_out = new real;
	real* d_min_out = (real*)malloc_device(sizeof(real));

	void*  d_temp_storage = NULL;
	size_t temp_storage  = 0;

	CHECK_CUDA_ERROR( cub::DeviceReduce::Min
	(
		d_temp_storage,
		temp_storage,
		d_dt_CFL,
		d_min_out,
		sol_len
	) );

	d_temp_storage = malloc_device(temp_storage);

	CHECK_CUDA_ERROR( cub::DeviceReduce::Min
	(
		d_temp_storage,
		temp_storage,
		d_dt_CFL,
		d_min_out,
		sol_len
	) );

	copy_cuda
	(
		h_min_out, 
		d_min_out, 
		sizeof(real)
	);

	real dt_min = *h_min_out;

	free_device(d_min_out);
	free_device(d_temp_storage);
	delete h_min_out;

	return dt_min;
}
#pragma once 

#include "cub/device/device_reduce.cuh"

#include "../utilities/cuda_utils.cuh"

#include "../types/real.h"

__host__
real get_dt_CFL
(
	real*&     d_dt_CFL, 
	const int& sol_len
);
#pragma once

#include "cuda_runtime.h"

#include "../classes/LegendreBasis.h"

#include "get_x_face_coord.cuh"
#include "get_y_face_coord.cuh"
#include "get_x_face_unit.cuh"
#include "get_y_face_unit.cuh"

__device__ __forceinline__
LegendreBasis get_leg_basis
(
	const HierarchyIndex& h_idx,
	const HierarchyIndex& h_idx_nghbr,
	const int&            level_nghbr,
	const int&            max_ref_lvl,
	const real&           x,
	const real&           y,
	const real&           dx_loc,
	const real&           dy_loc,
	const real&           dx_finest,
	const real&           dy_finest,
	const int&            direction
)
{
	real x_face = get_x_face_coord(x, dx_loc, direction);
	real y_face = get_y_face_coord(y, dy_loc, direction);

	real x_face_unit = get_x_face_unit(h_idx, h_idx_nghbr, level_nghbr, max_ref_lvl, x_face, dx_finest, direction);
	real y_face_unit = get_y_face_unit(h_idx, h_idx_nghbr, level_nghbr, max_ref_lvl, y_face, dy_finest, direction);

	return
	{
		C(1.0),
		sqrt( C(3.0) ) * ( C(2.0) * x_face_unit - C(1.0) ),
		sqrt( C(3.0) ) * ( C(2.0) * y_face_unit - C(1.0) )
	};
}
#pragma once

#include "../classes/Slopes.h"
#include "../classes/PlanarCoefficients.h"
#include "../classes/SolverParams.h"

#include "../operators/eval_loc_face_val_dg2.cuh"
#include "minmod.cuh"

__device__ __forceinline__
Slopes get_limited_slopes
(
	const PlanarCoefficients& u,
	const PlanarCoefficients& u_n,
	const PlanarCoefficients& u_e,
	const PlanarCoefficients& u_s,
	const PlanarCoefficients& u_w,
	const LegendreBasis&      basis_n,
	const LegendreBasis&      basis_e,
	const LegendreBasis&      basis_s,
	const LegendreBasis&      basis_w,
	const real&               dx_finest,
	const real&               dy_finest,
	const real&               tol_Krivo
)
{
	// ------- //
	// STEP 3b //
	// ------- //
	const real u_n_pos = eval_loc_face_val_dg2(u_n, basis_n);
	const real u_e_pos = eval_loc_face_val_dg2(u_e, basis_e);
	const real u_s_neg = eval_loc_face_val_dg2(u_s, basis_s);
	const real u_w_neg = eval_loc_face_val_dg2(u_w, basis_w);

	const real u_n_neg = eval_loc_face_val_dg2(u, { C(1.0), C(0.0), sqrt( C(3.0) ) } );
	const real u_e_neg = eval_loc_face_val_dg2(u, { C(1.0), sqrt( C(3.0) ), C(0.0) } );
	const real u_s_pos = eval_loc_face_val_dg2(u, { C(1.0), C(0.0), -sqrt( C(3.0) ) });
	const real u_w_pos = eval_loc_face_val_dg2(u, { C(1.0), -sqrt( C(3.0) ), C(0.0) });

	// ------- //
	// STEP 3c //
	// ------- //
	const real jump_n = abs(u_n_pos - u_n_neg);
	const real jump_e = abs(u_e_pos - u_e_neg);
	const real jump_s = abs(u_s_pos - u_s_neg);
	const real jump_w = abs(u_w_pos - u_w_neg);

	// ------ //
	// STEP 4 //
	// ------ //
	const real norm_x = max( abs(u._0 - u._1x), abs(u._0 + u._1x) );
	const real norm_y = max( abs(u._0 - u._1y), abs(u._0 + u._1y) );

	// ------ //
	// STEP 5 //
	// ------ //
	const real DS_e = ( norm_x > C(1e-12) ) ? jump_e / (C(0.5) * dx_finest * norm_x) : C(0.0);
	const real DS_w = ( norm_x > C(1e-12) ) ? jump_w / (C(0.5) * dx_finest * norm_x) : C(0.0);
					    				  
	const real DS_n = ( norm_y > C(1e-12) ) ? jump_n / (C(0.5) * dy_finest * norm_y) : C(0.0);
	const real DS_s = ( norm_y > C(1e-12) ) ? jump_s / (C(0.5) * dy_finest * norm_y) : C(0.0);

	const real u1x_limited = (max(DS_e, DS_w) < tol_Krivo) ? u._1x : minmod
	(
		u._1x,
		(u._0 - u_w._0) / sqrt( C(3.0) ),
		(u_e._0 - u._0) / sqrt( C(3.0) )
	);

	const real u1y_limited = (max(DS_n, DS_s) < tol_Krivo) ? u._1y : minmod
	(
		u._1y,
		(u._0 - u_s._0),
		(u_n._0 - u._0)
	);

	return { u1x_limited, u1y_limited };
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"
#include "../types/Directions.h"

__device__ __forceinline__
real get_x_face_coord
(
	const real& x,
	const real& dx_loc,
	const int&  direction
)
{
	real x_face = C(0.0);
	
	switch (direction)
	{
		case NORTH:
		case SOUTH:
			x_face = x - dx_loc / C(2.0) + C(0.5) * dx_loc;
			break;
		case EAST:
			x_face = x - dx_loc / C(2.0) + C(1.0) * dx_loc;
			break;
		case WEST:
			x_face = x - dx_loc / C(2.0) + C(0.0) * dx_loc;
			break;
		default:
			break;
	}
	
	return x_face;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"
#include "../types/HierarchyIndex.h"

#include "../zorder/get_x_coord.cuh"

__device__ __forceinline__
real get_x_face_unit
(
	const HierarchyIndex& h_idx,
	const HierarchyIndex& h_idx_nghbr,
	const int&            level_nghbr,
	const int&            max_ref_lvl,
	const real&           x_face, 
	const real&           dx_finest, 
	const int&            direction
)
{
	if (h_idx_nghbr == -1)
	{
		real x_face_unit = C(0.0);

		switch (direction)
		{
			case NORTH:
			case SOUTH:
				x_face_unit = C(0.5);
				break;
			case EAST:
				x_face_unit = C(0.0);
				break;
			case WEST:
				x_face_unit = C(1.0);
				break;
			default:
				break;
		}

		return x_face_unit;
	}
	
	real dx_loc_nghbr = dx_finest * ( 1 << (max_ref_lvl - level_nghbr) );

	real x_nghbr = get_x_coord(h_idx_nghbr, level_nghbr, max_ref_lvl, dx_finest);

	return ( x_face - ( x_nghbr - dx_loc_nghbr / C(2.0) ) ) / dx_loc_nghbr;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"
#include "../types/Directions.h"

__device__ __forceinline__
real get_y_face_coord
(
	const real& y,
	const real& dy_loc,
	const int&  direction
)
{
	real y_face = C(0.0);
	
	switch (direction)
	{
		case NORTH:
			y_face = y - dy_loc / C(2.0) + C(1.0) * dy_loc;
			break;
		case EAST:
		case WEST:
			y_face = y - dy_loc / C(2.0) + C(0.5) * dy_loc;
			break;
		case SOUTH:
			y_face = y - dy_loc / C(2.0) + C(0.0) * dy_loc;
			break;
		default:
			break;
	}
	
	return y_face;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"
#include "../types/HierarchyIndex.h"

#include "../zorder/get_y_coord.cuh"

__device__ __forceinline__
real get_y_face_unit
(
	const HierarchyIndex& h_idx,
	const HierarchyIndex& h_idx_nghbr,
	const int&            level_nghbr,
	const int&            max_ref_lvl,
	const real&           y_face, 
	const real&           dy_finest, 
	const int&            direction
)
{
	if (h_idx_nghbr == -1)
	{
		real y_face_unit = C(0.0);

		switch (direction)
		{
			case NORTH:
				y_face_unit = C(0.0);
				break;
			case EAST:
			case WEST:
				y_face_unit = C(0.5);
				break;
			case SOUTH:
				y_face_unit = C(1.0);
				break;
			default:
				break;
		}

		return y_face_unit;
	}
	
	real dy_loc_nghbr = dy_finest * ( 1 << (max_ref_lvl - level_nghbr) );

	real y_nghbr = get_y_coord(h_idx_nghbr, level_nghbr, max_ref_lvl, dy_finest);

	return ( y_face - ( y_nghbr - dy_loc_nghbr / C(2.0) ) ) / dy_loc_nghbr;
}
#include "limit_slopes.cuh"

__global__
void limit_slopes
(
    AssembledSolution d_assem_sol,
    Neighbours        d_neighbours,
    SimulationParams  sim_params,
    SolverParams      solver_params,
    real              dx_finest,
    real              dy_finest,
    real              max_h
)
{
	
    int t_idx = threadIdx.x;
    int idx   = blockIdx.x * blockDim.x + t_idx;
    
    if (idx < d_assem_sol.length)
    {
        int level = d_assem_sol.levels[idx];

        if (level == solver_params.L)
        {
            real dx_loc = dx_finest * ( 1 << (solver_params.L - level) );
            real dy_loc = dy_finest * ( 1 << (solver_params.L - level) );

            HierarchyIndex h_idx = d_assem_sol.act_idcs[idx];

            real x = get_x_coord(h_idx, level, solver_params.L, dx_finest);
            real y = get_y_coord(h_idx, level, solver_params.L, dy_finest);

            if ((x >= sim_params.xsz * dx_finest) || (y >= sim_params.ysz * dy_finest)) return;
            
            // ------ //
            // STEP 2 //
            // ------ //
            FlowCoeffs coeffs =
            {
                {
                    d_assem_sol.h0[idx],
                    d_assem_sol.h1x[idx],
                    d_assem_sol.h1y[idx],
                },
                {
                    d_assem_sol.qx0[idx],
                    d_assem_sol.qx1x[idx],
                    d_assem_sol.qx1y[idx],
                },
                {
                    d_assem_sol.qy0[idx],
                    d_assem_sol.qy1x[idx],
                    d_assem_sol.qy1y[idx],
                }
            };

            FlowCoeffs coeffs_n =
            {
                {
                    d_neighbours.north.h0[idx],
                    d_neighbours.north.h1x[idx],
                    d_neighbours.north.h1y[idx],
                },
                {
                    d_neighbours.north.qx0[idx],
                    d_neighbours.north.qx1x[idx],
                    d_neighbours.north.qx1y[idx],
                },
                {
                    d_neighbours.north.qy0[idx],
                    d_neighbours.north.qy1x[idx],
                    d_neighbours.north.qy1y[idx],
                }
            };

            FlowCoeffs coeffs_e =
            {
                {
                    d_neighbours.east.h0[idx],
                    d_neighbours.east.h1x[idx],
                    d_neighbours.east.h1y[idx],
                },
                {
                    d_neighbours.east.qx0[idx],
                    d_neighbours.east.qx1x[idx],
                    d_neighbours.east.qx1y[idx],
                },
                {
                    d_neighbours.east.qy0[idx],
                    d_neighbours.east.qy1x[idx],
                    d_neighbours.east.qy1y[idx],
                }
            };

            FlowCoeffs coeffs_s =
            {
                {
                    d_neighbours.south.h0[idx],
                    d_neighbours.south.h1x[idx],
                    d_neighbours.south.h1y[idx],
                },
                {
                    d_neighbours.south.qx0[idx],
                    d_neighbours.south.qx1x[idx],
                    d_neighbours.south.qx1y[idx],
                },
                {
                    d_neighbours.south.qy0[idx],
                    d_neighbours.south.qy1x[idx],
                    d_neighbours.south.qy1y[idx],
                }
            };

            FlowCoeffs coeffs_w =
            {
                {
                    d_neighbours.west.h0[idx],
                    d_neighbours.west.h1x[idx],
                    d_neighbours.west.h1y[idx],
                },
                {
                    d_neighbours.west.qx0[idx],
                    d_neighbours.west.qx1x[idx],
                    d_neighbours.west.qx1y[idx],
                },
                {
                    d_neighbours.west.qy0[idx],
                    d_neighbours.west.qy1x[idx],
                    d_neighbours.west.qy1y[idx],
                }
            };

            const PlanarCoefficients z   = { d_assem_sol.z0[idx],   d_assem_sol.z1x[idx],   d_assem_sol.z1y[idx] };
            const PlanarCoefficients z_n = { d_neighbours.north.z0[idx], d_neighbours.north.z1x[idx], d_neighbours.north.z1y[idx] };
            const PlanarCoefficients z_e = { d_neighbours.east.z0[idx],  d_neighbours.east.z1x[idx],  d_neighbours.east.z1y[idx] };
            const PlanarCoefficients z_s = { d_neighbours.south.z0[idx], d_neighbours.south.z1x[idx], d_neighbours.south.z1y[idx] };
            const PlanarCoefficients z_w = { d_neighbours.west.z0[idx],  d_neighbours.west.z1x[idx],  d_neighbours.west.z1y[idx] };

            const PlanarCoefficients eta   = z   + coeffs.h;
            const PlanarCoefficients eta_n = z_n + coeffs_n.h;
            const PlanarCoefficients eta_e = z_e + coeffs_e.h;
            const PlanarCoefficients eta_s = z_s + coeffs_s.h;
            const PlanarCoefficients eta_w = z_w + coeffs_w.h;

            int level_n = d_neighbours.north.levels[idx];
            int level_e = d_neighbours.east.levels[idx];
            int level_s = d_neighbours.south.levels[idx];
            int level_w = d_neighbours.west.levels[idx];

            HierarchyIndex h_idx_n = d_neighbours.north.act_idcs[idx];
            HierarchyIndex h_idx_e = d_neighbours.east.act_idcs[idx];
            HierarchyIndex h_idx_s = d_neighbours.south.act_idcs[idx];
            HierarchyIndex h_idx_w = d_neighbours.west.act_idcs[idx];

            // between local && east,  x, y unit is (1.0, 0.5)
            // between local && west,  x, y unit is (0.0, 0.5)
            // between local && north, x, y unit is (0.5, 1.0)
            // between local && south, x, y unit is (0.5, 0.0)

            // ------- //
            // STEP 3a //
            // ------- //
            LegendreBasis basis_n = get_leg_basis(h_idx, h_idx_n, level_n, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, NORTH);
            LegendreBasis basis_e = get_leg_basis(h_idx, h_idx_e, level_e, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, EAST);
            LegendreBasis basis_s = get_leg_basis(h_idx, h_idx_s, level_s, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, SOUTH);
            LegendreBasis basis_w = get_leg_basis(h_idx, h_idx_w, level_w, solver_params.L, x, y, dx_loc, dy_loc, dx_finest, dy_finest, WEST);
            
            Slopes eta_limited = get_limited_slopes
            (
                eta,
                eta_n,
                eta_e,
                eta_s,
                eta_w,
                basis_n,
                basis_e,
                basis_s,
                basis_w,
                dx_finest,
                dy_finest,
                solver_params.tol_Krivo
            );

            Slopes qx_limited = get_limited_slopes
            (
                coeffs.qx,
                coeffs_n.qx,
                coeffs_e.qx,
                coeffs_s.qx,
                coeffs_w.qx,
                basis_n,
                basis_e,
                basis_s,
                basis_w,
                dx_finest,
                dy_finest,
                solver_params.tol_Krivo
            );

            Slopes qy_limited = get_limited_slopes
            (
                coeffs.qy,
                coeffs_n.qy,
                coeffs_e.qy,
                coeffs_s.qy,
                coeffs_w.qy,
                basis_n,
                basis_e,
                basis_s,
                basis_w,
                dx_finest,
                dy_finest,
                solver_params.tol_Krivo
            );

            const bool above_h_min_limiter_x = ( C(0.05) * max_h < min( coeffs.h._0, min(coeffs_e.h._0, coeffs_w.h._0) ) );
            const bool above_h_min_limiter_y = ( C(0.05) * max_h < min( coeffs.h._0, min(coeffs_n.h._0, coeffs_s.h._0) ) );

            real& h1x = d_assem_sol.h1x[idx];
            real& h1y = d_assem_sol.h1y[idx];
            
            real& qx1x = d_assem_sol.qx1x[idx];
            real& qx1y = d_assem_sol.qx1y[idx];
            
            real& qy1x = d_assem_sol.qy1x[idx];
            real& qy1y = d_assem_sol.qy1y[idx];

            h1x = (above_h_min_limiter_x) ? eta_limited._1x - z._1x : h1x;
            h1y = (above_h_min_limiter_y) ? eta_limited._1y - z._1y : h1y;
            
            qx1x = (above_h_min_limiter_x) ? qx_limited._1x : qx1x;
            qx1y = (above_h_min_limiter_y) ? qx_limited._1y : qx1y;
            
            qy1x = (above_h_min_limiter_x) ? qy_limited._1x : qy1x;
            qy1y = (above_h_min_limiter_y) ? qy_limited._1y : qy1y;
        }
    }
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/Neighbours.h"
#include "../classes/SolverParams.h"
#include "../classes/SimulationParams.h"
#include "../classes/LegendreBasis.h"
#include "../classes/FlowCoeffs.h"

#include "get_limited_slopes.cuh"
#include "get_leg_basis.cuh"

__global__
void limit_slopes
(
    AssembledSolution d_assem_sol,
    Neighbours        d_neighbours,
    SimulationParams  sim_params,
    SolverParams      solver_params,
    real              dx_finest,
    real              dy_finest,
    real              max_h
);
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

__device__ __forceinline__
real minmod
(
    const real& a,
    const real& b,
    const real& c
)
{
    if ( ( a * b > C(0.0) ) && ( a * c > C(0.0) ) )
    {
        const real sign_a = ( a > C(0.0) ) - ( a < C(0.0) );

        return min( abs(a), min( abs(b), abs(c) ) ) * sign_a;
    }
    else
    {
        return C(0.0);
    }
}
#pragma once

#include "cuda_runtime.h"

#include <cstdio>

#include "../types/real.h"

typedef struct twodoubles
{
	real hb, ub;

} twodoubles;

__device__ __forceinline__
twodoubles non_reflective_wave
(
	real h_inlet,
	real dt,
	real dxl,
	real hp,
	real up,
	real hb,
	real ub,
	real g
)
{
	int k = 0, max_k = 100, cond = 0;

	real Delta = C(1e-6), xa = -dxl / C(2.0), p0 = dxl / C(2.0), p1 = p0 - dxl / C(2.0), dp = C(0.0), relerr = C(0.0), f1 = C(0.0);

	real f0 = (p0 - xa) + dt * ((ub - (p0 - xa) / dxl * (ub - up)) - sqrt(g * (hb - (p0 - xa) / dxl * (hb - hp))));

	while ( (k <= max_k) && cond == 0 )
	{
		real df = C(1.0) + dt * ( (up - ub) / dxl - C(0.5) * pow((g * (hb - (p0 - xa) / dxl * (hb - hp))), C(-0.5)) * (g * (hp - hb) / dxl));

		if ( abs(df) <= C(0.0) )
		{
			printf("Convergence is doubtful because division by zero was encountered.\n");

			cond = 1;

			dp = p1 - p0;
			p1 = p0;
		}
		else
		{
			dp = f0 / df;
			p1 = p0 - dp;
		}

		f1     = (p1 - xa) + dt * ((ub - (p1 - xa) / dxl * (ub - up)) - sqrt(g * (hb - (p1 - xa) / dxl * (hb - hp))));
		relerr = abs(dp) / ( abs(p1) + C(0.0) );

		if (relerr < Delta)
		{
			cond = 2;

			//printf("The approximation p is within the desired tolerance.\n");
		}

		if (abs(f1) < Delta)
		{
			cond = 3;

			//printf("The computed function value fp is within the desired tolerance.\n");
		}

		if ( (relerr <= Delta) && (abs(f1) < Delta) )
		{
			cond = 4;

			//printf("The approximation p and the function value fp are both within the desired tolerance.\n");
		}

		p0 = p1;
		f0 = f1;
		k++;
	}

	real hr = hb - (hb - hp) * (p1 - xa) / dxl;
	real ur = ub - (ub - up) * (p1 - xa) / dxl;
	real cr = sqrt(g * hr);

	real beta_minus = ur - C(2.0) * cr;
	real beta_plus  = C(2.0) * sqrt(g * (h_inlet + C(0.13535))) + h_inlet * sqrt(g / C(0.13535));
	
	// this is "hb" in MKS Fortran code 
	real h_out = C(1.0) / C(16.0) / g * (beta_plus - beta_minus) * (beta_plus - beta_minus);
	real u_out = C(0.5) * (beta_plus + beta_minus);

	return { h_out, u_out };
}
#include "append_reals_to_file.cuh"

__host__
void append_reals_to_file
(
	const char* filename,
	const char* dirroot,
	real*       d_results,
	const int&  array_length,
	const bool  first_t_step
)
{
	// allocating host array to copy_cuda device array to 
	real* h_results = new real[array_length];

	size_t bytes = array_length * sizeof(real);

	copy_cuda
	(
		h_results,
		d_results,
		bytes
	);

	FILE* fp;

	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%s%s", dirroot, filename, ".csv");

	fp = (first_t_step) ? fopen(fullpath, "w") : fopen(fullpath, "a");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file : %s", filename);
		exit(-1);
	}

	for (int i = 0; i < array_length; i++)
	{
		fprintf(fp, "%" NUM_FIG NUM_FRMT ",", h_results[i]);
	}
	
	fprintf(fp, "\n");

	fclose(fp);

	delete[] h_results;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include <cstdio>
#include <cstring>

#include "../types/real.h"


__host__
void append_reals_to_file
(
	const char* filename,
	const char* dirroot,
	real*       d_results,
	const int&  array_length,
	const bool  first_t_step
);
target_sources(
	    gpu-mwdg2
		PRIVATE
		append_reals_to_file.cu
		project_assem_sol.cu
		write_bool_to_file.cu
		write_c_prop_data.cu
		write_cumulative_data.cpp
		write_stage_point_data.cu
		write_int_to_file.cu
		write_mesh_info.cpp
		write_raster_file.cu
		write_reals_to_file.cu
		write_hierarchy_array_real.cu
		write_hierarchy_array_bool.cu
		write_all_raster_maps.cu
		write_all_raster_maps_dg2.cu
		write_all_raster_maps_fv1.cu
		write_soln_vtk.cu
	)
#include "project_assem_sol.cuh"

__host__
void project_assem_sol
(
	const int&               mesh_dim,
	bool*&                   d_sig_details,
	const ScaleCoefficients& d_scale_coeffs,
	AssembledSolution        d_buf_assem_sol,
	const SolverParams&      solver_params,
	MortonCode*              d_rev_z_order,
	MortonCode*              d_indices,
	AssembledSolution        d_assem_sol,
	AssembledSolution        d_plot_assem_sol
)
{
	int num_blocks_sol = get_num_blocks(d_assem_sol.length, THREADS_PER_BLOCK);

	reinsert_assem_sol<<<num_blocks_sol, THREADS_PER_BLOCK>>>
	(
		d_assem_sol,
		d_assem_sol.act_idcs,
		d_scale_coeffs,
		solver_params
	);

	int num_finest_elems      = mesh_dim * mesh_dim;
	int num_threads_traversal = num_finest_elems / 4;
	int num_blocks_traversal  = get_num_blocks(num_threads_traversal, THREADS_PER_BLOCK);
	
	d_plot_assem_sol.length = num_finest_elems;

	traverse_tree_of_sig_details<<<num_blocks_traversal, THREADS_PER_BLOCK>>>
	(
		d_sig_details, 
		d_scale_coeffs,
		d_buf_assem_sol,
		num_threads_traversal,
		solver_params
	);

	load_soln_coeffs<<<get_num_blocks(num_finest_elems, THREADS_PER_BLOCK), THREADS_PER_BLOCK>>>
	(
		d_buf_assem_sol,
		d_scale_coeffs,
		num_finest_elems
	);

	rev_z_order_assem_sol
	(
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol,
		d_plot_assem_sol,
		num_finest_elems
	);
}

__global__
void load_soln_coeffs
(
	AssembledSolution d_assem_sol,
	ScaleCoefficients d_scale_coeffs,
	int               num_finest_elems
)
{
	int idx = blockDim.x * blockIdx.x + threadIdx.x;

	if (idx >= num_finest_elems) return;

	HierarchyIndex act_idx = d_assem_sol.act_idcs[idx];

	d_assem_sol.h0[idx]  = d_scale_coeffs.eta0[act_idx] - d_scale_coeffs.z0[act_idx];
	d_assem_sol.qx0[idx] = d_scale_coeffs.qx0[act_idx];
	d_assem_sol.qy0[idx] = d_scale_coeffs.qy0[act_idx];
	d_assem_sol.z0[idx]  = d_scale_coeffs.z0[act_idx];
}
#pragma once

#include "../utilities/get_num_blocks.h"

#include "../mra/reinsert_assem_sol.cuh"
#include "../mra/traverse_tree_of_sig_details.cuh"
#include "../zorder/rev_z_order_assem_sol.cuh"
#include "write_reals_to_file.cuh"
#include "write_int_to_file.cuh"

__global__
void load_soln_coeffs
(
	AssembledSolution d_assem_sol,
	ScaleCoefficients d_scale_coeffs,
	int               num_finest_elems
);

__host__
void project_assem_sol
(
	const int&               mesh_dim,
	bool*&                   d_sig_details,
	const ScaleCoefficients& d_scale_coeffs,
	AssembledSolution        d_buf_assem_sol,
	const SolverParams&  solver_params,
	MortonCode*              d_rev_z_order,
	MortonCode*              d_indices,
	AssembledSolution        d_assem_sol,
	AssembledSolution        d_plot_assem_sol
);
#include "write_all_raster_maps.cuh"

void write_all_raster_maps
(
    const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint,
	const bool&              first_t_step
)
{
	printf("Writing raster maps.\n");

	if (solver_params.solver_type == HWFV1)
	{
		write_all_raster_maps_fv1
		(
			plot_params,
			d_assem_sol,
			dx_finest,
			dy_finest,
			sim_params,
			solver_params,
			saveint,
			first_t_step
		);
	}
	else if (solver_params.solver_type == MWDG2)
	{
		write_all_raster_maps_dg2
		(
			plot_params,
			d_assem_sol,
			dx_finest,
			dy_finest,
			sim_params,
			solver_params,
			saveint,
			first_t_step
		);
	}
}
#pragma once

#include "write_all_raster_maps_fv1.cuh"
#include "write_all_raster_maps_dg2.cuh"

void write_all_raster_maps
(
    const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint,
	const bool&              first_t_step
);
#include "write_all_raster_maps_dg2.cuh"

void write_all_raster_maps_dg2
(
    const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint,
	const bool&              first_t_step
)
{
    const int mesh_dim = 1 << (solver_params.L);

	const int num_finest_cells = mesh_dim * mesh_dim;

	real* h    = new real[num_finest_cells];
	real* qx   = new real[num_finest_cells];
	real* qy   = new real[num_finest_cells];
	real* vx   = new real[num_finest_cells];
	real* vy   = new real[num_finest_cells];
	real* z    = new real[num_finest_cells];
	real* eta  = new real[num_finest_cells];

	real*           h0       = new real[d_assem_sol.length];
	real*           h1x      = new real[d_assem_sol.length];
	real*           h1y      = new real[d_assem_sol.length];
	real*           qx0      = new real[d_assem_sol.length];
	real*           qx1x     = new real[d_assem_sol.length];
	real*           qx1y     = new real[d_assem_sol.length];
	real*           qy0      = new real[d_assem_sol.length];
	real*           qy1x     = new real[d_assem_sol.length];
	real*           qy1y     = new real[d_assem_sol.length];
	real*           z0       = new real[d_assem_sol.length];
	real*           z1x      = new real[d_assem_sol.length];
	real*           z1y      = new real[d_assem_sol.length];
	HierarchyIndex* act_idcs = new HierarchyIndex[d_assem_sol.length];
	int*            levels   = new int[d_assem_sol.length];

	size_t bytes_flow     = d_assem_sol.length * sizeof(real);
	size_t bytes_act_idcs = d_assem_sol.length * sizeof(HierarchyIndex);
	size_t bytes_levels   = d_assem_sol.length * sizeof(int);
	
	copy_cuda(h0,       d_assem_sol.h0,       bytes_flow);
	copy_cuda(h1x,      d_assem_sol.h1x,      bytes_flow);
	copy_cuda(h1y,      d_assem_sol.h1y,      bytes_flow);
	copy_cuda(qx0,      d_assem_sol.qx0,      bytes_flow);
	copy_cuda(qx1x,     d_assem_sol.qx1x,     bytes_flow);
	copy_cuda(qx1y,     d_assem_sol.qx1y,     bytes_flow);
	copy_cuda(qy0,      d_assem_sol.qy0,      bytes_flow);
	copy_cuda(qy1x,     d_assem_sol.qy1x,     bytes_flow);
	copy_cuda(qy1y,     d_assem_sol.qy1y,     bytes_flow);
	copy_cuda(z0,       d_assem_sol.z0,       bytes_flow);
	copy_cuda(z1x,      d_assem_sol.z1x,      bytes_flow);
	copy_cuda(z1y,      d_assem_sol.z1y,      bytes_flow);
	copy_cuda(act_idcs, d_assem_sol.act_idcs, bytes_act_idcs);
	copy_cuda(levels,   d_assem_sol.levels,   bytes_levels);

	for (int element = 0; element < d_assem_sol.length; element++)
	{
		int level = levels[element];

		MortonCode code = act_idcs[element] - get_lvl_idx(level);

		code <<= 2 * (solver_params.L - level);

		Coordinate i = get_i_index(code);
		Coordinate j = get_j_index(code);

		int side_len = 1 << (solver_params.L - level);

		real dx_unit = C(1.0) / side_len;

		FlowCoeffs coeffs =
		{
			{
				h0[element],
				h1x[element],
				h1y[element]
			},
			{
				qx0[element],
				qx1x[element],
				qx1y[element]
			},
			{
				qy0[element],
				qy1x[element],
				qy1y[element]
			}
		};

		PlanarCoefficients z_planar =
		{
			z0[element],
			z1x[element],
			z1y[element]
		};

		for (int j_loc = 0; j_loc < side_len; j_loc++)
		{
			real y_unit = j_loc * dx_unit + dx_unit / C(2.0);

			for (int i_loc = 0; i_loc < side_len; i_loc++)
			{
				real x_unit = i_loc * dx_unit + dx_unit / C(2.0);
				
				LegendreBasis leg_basis =
				{
					C(1.0),
					sqrt( C(3.0) ) * ( C(2.0) * x_unit - C(1.0) ),
					sqrt( C(3.0) ) * ( C(2.0) * y_unit - C(1.0) )
				};

				real h_loc_face_val = eval_loc_face_val_dg2(coeffs.h, leg_basis);
				real z_loc_face_val = eval_loc_face_val_dg2(z_planar, leg_basis);

				int idx = (mesh_dim) * (j + j_loc) + (i + i_loc);

				h[idx]   = h_loc_face_val;
				z[idx]   = z_loc_face_val;
				eta[idx] = h_loc_face_val + z_loc_face_val;

				// only compute velocity or discharge if voutput/qoutput params are included
				if (plot_params.voutput || plot_params.qoutput)
				{
					real qx_loc_face_val = eval_loc_face_val_dg2(coeffs.qx, leg_basis);
					real qy_loc_face_val = eval_loc_face_val_dg2(coeffs.qy, leg_basis);
					
					if (plot_params.qoutput)
					{
						qx[idx] = qx_loc_face_val;
						qy[idx] = qy_loc_face_val;
					}
					
					if (plot_params.voutput)
					{
						vx[idx] = (h_loc_face_val > solver_params.tol_h) ? qx_loc_face_val / h_loc_face_val : C(0.0);
						vy[idx] = (h_loc_face_val > solver_params.tol_h) ? qy_loc_face_val / h_loc_face_val : C(0.0);
					}
				}
			}
		}
	}

	if (!plot_params.elevoff)
	{
		write_raster_file
		(
			plot_params,
			"elev",
			eta,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (!plot_params.depthoff)
	{
		write_raster_file
		(
			plot_params,
			"wd",
			h,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (plot_params.qoutput)
	{
		write_raster_file
		(
			plot_params,
			"qx",
			qx,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);

		write_raster_file
		(
			plot_params,
			"qy",
			qy,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (plot_params.voutput)
	{
		write_raster_file
		(
			plot_params,
			"vx",
			vx,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);

		write_raster_file
		(
			plot_params,
			"vy",
			vy,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (first_t_step)
	{
		write_raster_file
		(
			plot_params,
			"dem",
			z,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	delete[] h;
	delete[] qx;
	delete[] qy;
	delete[] vx;
	delete[] vy;
	delete[] z;
	delete[] eta;

	delete[] h0;
	delete[] h1x;
	delete[] h1y;
	delete[] qx0;
	delete[] qx1x;
	delete[] qx1y;
	delete[] qy0;
	delete[] qy1x;
	delete[] qy1y;
	delete[] z0;
	delete[] z1x;
	delete[] z1y;
	delete[] act_idcs;
	delete[] levels;
}
#pragma once

#include <cstdio>
#include <cstdlib>

#include "../utilities/cuda_utils.cuh"

#include "../classes/FlowCoeffs.h"
#include "../classes/Points.h"
#include "../classes/AssembledSolution.h"
#include "../classes/SimulationParams.h"
#include "../classes/SolverParams.h"
#include "../classes/SaveInterval.h"
#include "../classes/FinestGrid.h"

#include "write_raster_file.cuh"
#include "../zorder/get_i_index.cuh"
#include "../zorder/get_j_index.cuh"
#include "../utilities/get_lvl_idx.cuh"

void write_all_raster_maps_dg2
(
    const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint,
	const bool&              first_t_step
);
#include "write_all_raster_maps_fv1.cuh"

void write_all_raster_maps_fv1
(
    const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint,
	const bool&              first_t_step
)
{
    const int mesh_dim = 1 << (solver_params.L);

	const int num_finest_cells = mesh_dim * mesh_dim;

	real* h    = new real[num_finest_cells];
	real* qx   = new real[num_finest_cells];
	real* qy   = new real[num_finest_cells];
	real* vx   = new real[num_finest_cells];
	real* vy   = new real[num_finest_cells];
	real* z    = new real[num_finest_cells];
	real* eta  = new real[num_finest_cells];

	real*           h0       = new real[d_assem_sol.length];
	real*           qx0      = new real[d_assem_sol.length];
	real*           qy0      = new real[d_assem_sol.length];
	real*           z0       = new real[d_assem_sol.length];
	HierarchyIndex* act_idcs = new HierarchyIndex[d_assem_sol.length];
	int*            levels   = new int[d_assem_sol.length];

	size_t bytes_flow     = d_assem_sol.length * sizeof(real);
	size_t bytes_act_idcs = d_assem_sol.length * sizeof(HierarchyIndex);
	size_t bytes_levels   = d_assem_sol.length * sizeof(int);
	
	copy_cuda(h0,       d_assem_sol.h0,       bytes_flow);
	copy_cuda(qx0,      d_assem_sol.qx0,      bytes_flow);
	copy_cuda(qy0,      d_assem_sol.qy0,      bytes_flow);
	copy_cuda(z0,       d_assem_sol.z0,       bytes_flow);
	copy_cuda(act_idcs, d_assem_sol.act_idcs, bytes_act_idcs);
	copy_cuda(levels,   d_assem_sol.levels,   bytes_levels);

	for (int element = 0; element < d_assem_sol.length; element++)
	{
		int level = levels[element];

		MortonCode code = act_idcs[element] - get_lvl_idx(level);

		code <<= 2 * (solver_params.L - level);

		Coordinate i = get_i_index(code);
		Coordinate j = get_j_index(code);

		int side_len = 1 << (solver_params.L - level);

		for (int j_loc = 0; j_loc < side_len; j_loc++)
		{
			for (int i_loc = 0; i_loc < side_len; i_loc++)
			{
				int idx = (mesh_dim) * (j + j_loc) + (i + i_loc);

				h[idx]    = h0 [element];
				z[idx]    = z0 [element];
				eta[idx]  = h0[element] + z0 [element];

				// only compute velocity or discharge if voutput/qoutput params are included
				if (plot_params.voutput || plot_params.qoutput)
				{
					if (plot_params.qoutput)
					{
						qx[idx] = qx0[element];
						qy[idx] = qy0[element];
					}
					
					if (plot_params.voutput)
					{
						vx[idx] = (h0[element] > solver_params.tol_h) ? qx0[element] / h0[element] : C(0.0);
						vy[idx] = (h0[element] > solver_params.tol_h) ? qy0[element] / h0[element] : C(0.0);
					}
				}
			}
		}
	}

	if (!plot_params.elevoff)
	{
		write_raster_file
		(
			plot_params,
			"elev",
			eta,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (!plot_params.depthoff)
	{
		write_raster_file
		(
			plot_params,
			"wd",
			h,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (plot_params.qoutput)
	{
		write_raster_file
		(
			plot_params,
			"qx",
			qx,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);

		write_raster_file
		(
			plot_params,
			"qy",
			qy,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (plot_params.voutput)
	{
		write_raster_file
		(
			plot_params,
			"vx",
			vx,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);

		write_raster_file
		(
			plot_params,
			"vy",
			vy,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	if (first_t_step)
	{
		write_raster_file
		(
			plot_params,
			"dem",
			z,
			sim_params,
			saveint,
			dx_finest,
			mesh_dim
		);
	}

	delete[] h;
	delete[] qx;
	delete[] qy;
	delete[] vx;
	delete[] vy;
	delete[] z;
	delete[] eta;

	delete[] h0;
	delete[] qx0;
	delete[] qy0;
	delete[] z0;
	delete[] act_idcs;
	delete[] levels;
}
#pragma once

#include <cstdio>
#include <cstdlib>

#include "../utilities/cuda_utils.cuh"

#include "../classes/Points.h"
#include "../classes/AssembledSolution.h"
#include "../classes/PlottingParams.h"
#include "../classes/SimulationParams.h"
#include "../classes/SolverParams.h"
#include "../classes/SaveInterval.h"
#include "../classes/FinestGrid.h"

#include "write_raster_file.cuh"
#include "../zorder/get_i_index.cuh"
#include "../zorder/get_j_index.cuh"
#include "../utilities/get_lvl_idx.cuh"

void write_all_raster_maps_fv1
(
    const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint,
	const bool&              first_t_step
);
#include "write_bool_to_file.cuh"

__host__
void write_bool_to_file
(
	const char* filename,
	const char* dirroot,
	bool*       d_results,
	const int   array_length
)
{
	// allocating host array to copy_cuda device array to 
	bool* h_results = new bool[array_length];

	size_t bytes = array_length * sizeof(bool);

	copy_cuda
	(
		h_results,
		d_results,
		bytes
	);

	FILE* fp;

	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%s%s", dirroot, filename, ".csv");
	
	fp = fopen(fullpath, "w");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file: %s", filename);
		exit(-1);
	}

	fprintf(fp, "results\n");

	for (int i = 0; i < array_length; i++)
	{
		fprintf(fp, "%d\n", h_results[i]);
	}

	fclose(fp);

	delete[] h_results;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include <cstdio>
#include <cstring>

__host__
void write_bool_to_file
(
	const char* filename,
	const char* dirroot,
	bool*       d_results,
	const int   array_length
);
#include "write_cumulative_data.h"

void write_cumulative_data
(
	const clock_t           start,
	const real&             current_time,
	const real&             time_mra,
	const real&             time_solver,
	const real&             dt,
	const int&              num_cells,
	const SimulationParams& sim_params,
	const PlottingParams&   plot_params,
	const bool              first_t_step
)
{
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", plot_params.dirroot, '/', plot_params.resroot, ".cumu");
	
	FILE* cumulative_input = fopen(fullpath, (first_t_step) ? "w" : "a");

	if (NULL == cumulative_input)
	{
		fprintf(stderr, "Error in opening cumulative simulation data file.");
		exit(-1);
	}

	if (first_t_step) fprintf(cumulative_input, "simtime,runtime_mra,runtime_solver,runtime_total,dt,reduction\n");

	const clock_t end = clock();

	const real compression = ( C(100.0) - C(100.0) * num_cells / (sim_params.xsz * sim_params.ysz) ) / C(100.0);

	fprintf
	(
		cumulative_input,
		 "%" NUM_FRMT
		",%" NUM_FRMT
		",%" NUM_FRMT
		",%" NUM_FRMT
		",%" NUM_FRMT
		",%" NUM_FRMT
		"\n",
		current_time,
		time_mra,
		time_solver,
		time_mra + time_solver,
		dt,
		compression
	);

	fclose(cumulative_input);
}
#pragma once

#include "../utilities/BLOCK_VAR_MACROS.cuh"

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <time.h>

#include "../classes/SimulationParams.h"
#include "../classes/PlottingParams.h"

void write_cumulative_data
(
	const clock_t           start,
	const real&             current_time,
	const real&             time_mra,
	const real&             time_solver,
	const real&             dt,
	const int&              num_cells,
	const SimulationParams& sim_params,
	const PlottingParams&   plot_params,
	const bool              first_t_step
);
#include "write_c_prop_data.cuh"

__host__
void write_c_prop_data
(
	const PlottingParams&    plot_params,
	const clock_t&           start,
	const SolverParams&      solver_params,
	const SimulationParams&  sim_params,
	const AssembledSolution& d_assem_sol,
	const real&              current_time,
	const real&              time_mra,
	const real&              time_solver,
	const real&              dt,
	const int&               num_cells,
	const bool&              first_t_step
)
{
	write_cumulative_data
	(
		start,
		current_time,
		time_mra,
		time_solver,
		dt,
		num_cells,
		sim_params,
		plot_params,
		first_t_step
	);

	append_reals_to_file
	(
		"qx0-c-prop",
		plot_params.dirroot,
		d_assem_sol.qx0,
		d_assem_sol.length,
		first_t_step
	);

	append_reals_to_file
	(
		"qy0-c-prop",
		plot_params.dirroot,
		d_assem_sol.qy0,
		d_assem_sol.length,
		first_t_step
	);

	if (solver_params.solver_type == MWDG2)
	{
		append_reals_to_file
		(
			"qx1x-c-prop",
			plot_params.dirroot,
			d_assem_sol.qx1x,
			d_assem_sol.length,
			first_t_step
		);

		append_reals_to_file
		(
			"qx1y-c-prop",
			plot_params.dirroot,
			d_assem_sol.qx1y,
			d_assem_sol.length,
			first_t_step
		);

		append_reals_to_file
		(
			"qy1x-c-prop",
			plot_params.dirroot,
			d_assem_sol.qy1x,
			d_assem_sol.length,
			first_t_step
		);
		append_reals_to_file
		(
			"qy1y-c-prop",
			plot_params.dirroot,
			d_assem_sol.qy1y,
			d_assem_sol.length,
			first_t_step
		);
	}
}
#pragma once

#include "../classes/SolverParams.h"
#include "../classes/PlottingParams.h"
#include "../classes/AssembledSolution.h"

#include "write_cumulative_data.h"

#include "append_reals_to_file.cuh"

__host__
void write_c_prop_data
(
	const PlottingParams&    plot_params,
	const clock_t&           start,
	const SolverParams&      solver_params,
	const SimulationParams&  sim_params,
	const AssembledSolution& d_assem_sol,
	const real&              current_time,
	const real&              time_mra,
	const real&              time_solver,
	const real&              dt,
	const int&               num_cells,
	const bool&              first_t_step
);
#include "write_hierarchy_array_bool.cuh"

__host__
void write_hierarchy_array_bool
(
	const char* dirroot,
	const char* filename,
	bool*       d_hierarchy,
	const int&  levels
)
{
	const int num_all_elems = get_lvl_idx(levels + 1);
	
	// allocating host array to copy_cuda device array to 
	bool* h_hierarchy = new bool[num_all_elems] ;

	size_t bytes = num_all_elems * sizeof(bool);

	copy_cuda
	(
		h_hierarchy,
		d_hierarchy,
		bytes
	);

	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", dirroot, '/', filename, ".txt");

	FILE* fp = fopen(fullpath, "w");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening %s for writing hierarchy to file", filename);
		exit(-1);
	}

	for (int level = 0; level <= levels; level++)
	{
		const int start = get_lvl_idx(level);
		const int end   = get_lvl_idx(level+1);

		for (int i = start; i < end; i++)
		{
			fprintf(fp, "%d ", h_hierarchy[i]);
		}

		fprintf(fp, "\n");
	}

	fclose(fp);

	delete[] h_hierarchy;
}
#pragma once

#include <cstdio>
#include <cstring>

#include "../utilities/cuda_utils.cuh"
#include "../utilities/get_lvl_idx.cuh"

__host__
void write_hierarchy_array_bool
(
	const char* dirroot,
	const char* filename,
	bool*       d_hierarchy,
	const int&  levels
);
#include "write_hierarchy_array_real.cuh"

__host__
void write_hierarchy_array_real
(
	const char* dirroot,
	const char* filename,
	real*       d_hierarchy,
	const int&  levels
)
{
	const int num_all_elems = get_lvl_idx(levels + 1);
	
	// allocating host array to copy_cuda device array to 
	real* h_hierarchy = new real[num_all_elems];

	size_t bytes = num_all_elems * sizeof(real);

	copy_cuda
	(
		h_hierarchy,
		d_hierarchy,
		bytes
	);

	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", dirroot, '/', filename, ".txt");

	FILE* fp = fopen(fullpath, "w");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening %s for writing hierarchy to file", filename);
		exit(-1);
	}

	for (int level = 0; level <= levels; level++)
	{
		const int start = get_lvl_idx(level);
		const int end   = get_lvl_idx(level+1);

		for (int i = start; i < end; i++)
		{
			fprintf(fp, "%" NUM_FRMT " ", h_hierarchy[i]);
		}

		fprintf(fp, "\n");
	}

	fclose(fp);

	delete[] h_hierarchy;
}
#pragma once

#include <cstdio>
#include <cstring>

#include "../types/real.h"

#include "../utilities/cuda_utils.cuh"
#include "../utilities/get_lvl_idx.cuh"

__host__
void write_hierarchy_array_real
(
	const char* dirroot,
	const char* filename,
	real*       d_hierarchy,
	const int&  levels
);
#include "write_int_to_file.cuh"

__host__
void write_int_to_file
(
	const char* filename,
	const char* dirroot,
	int*        d_results,
	const int   array_length
)
{
	// allocating host array to copy_cuda device array to 
	int* h_results = new int[array_length];
	
	size_t bytes = array_length * sizeof(int);

	copy_cuda
	(
		h_results, 
		d_results, 
		bytes
	);
	
	FILE* fp;

	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%s%s", dirroot, filename, ".csv");
	
	fp = fopen(fullpath, "w+");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file : %s", filename);
		exit(-1);
	}

	fprintf(fp, "n\n");

	for (int i = 0; i < array_length; i++)
	{
		fprintf(fp, "%d\n", h_results[i]);
	}

	fclose(fp);

	delete[] h_results;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include <cstdio>
#include <cstring>


__host__
void write_int_to_file
(
	const char* filename,
	const char* dirroot,
	int*        d_results,
	const int   array_length
);
#include "write_mesh_info.h"

void write_mesh_info
(
	const SimulationParams& sim_params,
	const int&              mesh_dim,
	const char*             dirroot
)
{
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s", dirroot, '/', "mesh_info.csv");
	
	FILE* fp = fopen(fullpath, "w");

	if (NULL == fp)
	{
		fprintf(stderr, "Error in opening mesh information file.\n");
		exit(-1);
	}

	fprintf(fp, "mesh_dim,xmin,xmax,ymin,ymax,xsz,ysz\n");

	fprintf
	(
		fp,
		"%d,%" NUM_FRMT ",%" NUM_FRMT ",%" NUM_FRMT ",%" NUM_FRMT ",%d,%d\n", 
		mesh_dim, 
		sim_params.xmin, 
		sim_params.xmax, 
		sim_params.ymin, 
		sim_params.ymax,
		sim_params.xsz,
		sim_params.ysz
	);

	fclose(fp);
}
#pragma once

#include <cstdio>
#include <cstdlib>
#include <cstring>

#include "../classes/SimulationParams.h"

void write_mesh_info
(
	const SimulationParams& sim_params,
	const int&                  mesh_dim,
	const char*                 resdir
);
#include "write_raster_file.cuh"

__host__
void write_raster_file
(
	const PlottingParams&   plot_params,
	const char*             file_extension,
	real*                   raster,
	const SimulationParams& sim_params,
	const SaveInterval      saveint,
	const real&             dx_finest,
	const int&              mesh_dim
)
{
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%c%d%c%s", plot_params.dirroot, '/', plot_params.resroot, '-', saveint.count - 1, '.', file_extension);

	FILE* fp = fopen(fullpath, "w");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file to write raster: %s", file_extension);
		exit(-1);
	}
	
	size_t bytes = mesh_dim * mesh_dim * sizeof(real);
	
	real xllcorner = sim_params.xmin;
	real yllcorner = sim_params.ymin;

	int ncols = sim_params.xsz;
	int nrows = sim_params.ysz;

	int NODATA_value = -9999;
	
	fprintf(fp, "ncols        %d\n", ncols);
	fprintf(fp, "nrows        %d\n", nrows);
	fprintf(fp, "xllcorner    %" NUM_FRMT "\n", xllcorner);
	fprintf(fp, "yllcorner    %" NUM_FRMT "\n", yllcorner);
	fprintf(fp, "cellsize     %" NUM_FRMT "\n", dx_finest);
	fprintf(fp, "NODATA_value %d\n", NODATA_value);

	for (int j = 0; j < nrows; j++)
	{
		for (int i = 0; i < ncols; i++)
		{
			int idx = (nrows - 1 - j) * mesh_dim + i;

			fprintf(fp, "%" NUM_FIG NUM_FRMT " ", raster[idx]);
		}

		fprintf(fp, "\n");
	}

	fclose(fp);
}
#pragma once

#include <cstdio>
#include <cstring>

#include "../utilities/BLOCK_VAR_MACROS.cuh"
#include "../utilities/cuda_utils.cuh"

#include "../classes/SimulationParams.h"
#include "../classes/PlottingParams.h"
#include "../classes/SaveInterval.h"

__host__
void write_raster_file
(
	const PlottingParams&   plot_params,
	const char*             file_extension,
	real*                   raster,
	const SimulationParams& sim_params,
	const SaveInterval      massint,
	const real&             dx_finest,
	const int&              mesh_dim
);
#include "write_reals_to_file.cuh"

__host__
void write_reals_to_file
(
	const char* filename,
	const char* dirroot,
	real*       d_results,
	const int&  array_length
)
{
	// allocating host array to copy_cuda device array to 
	real* h_results = new real[array_length];

	size_t bytes = array_length * sizeof(real);

	copy_cuda
	(
		h_results,
		d_results,
		bytes
	);

	FILE* fp;

	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%s%s", dirroot, filename, ".csv");

	fp = fopen(fullpath, "w");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file : %s", filename);
		exit(-1);
	}

	fprintf(fp, "results\n");

	for (int i = 0; i < array_length; i++)
	{
		fprintf(fp, "%" NUM_FRMT "\n", h_results[i]);
	}

	fclose(fp);

	delete[] h_results;
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include <cstdio>
#include <cstring>

#include "../types/real.h"

__host__
void write_reals_to_file
(
	const char* filename,
	const char* dirroot,
	real*       d_results,
	const int&  array_length
);
#include "write_soln_vtk.cuh"

__host__ void write_soln_vtk
(
	const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	      real*              d_dt_CFL,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint
)
{	
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%c%d%s", plot_params.dirroot, '/', plot_params.resroot, '-', saveint.count - 1, ".vtk");

	FILE* fp = fopen(fullpath, "w");

	if (NULL == fp)
	{
		fprintf(stderr, "Error writing VTK file, file: %s, line: %d.\n", __FILE__, __LINE__);
		exit(-1);
	}

	printf("Writing VTK file.\n");

	fprintf
	(
		fp,
		"# vtk DataFile Version 3.0\n"
		"Multiresolution flow and topo data\n"
		"ASCII\n"
		"\n"
		"DATASET UNSTRUCTURED_GRID\n"
		"POINTS %d float\n",
		d_assem_sol.length * 4
	);

	// xmax, ymax from sim_params may have non-zero origin
	// however, Morton codes assume zero origin
	// hence, modified xmax, ymax for bounds checking
	real xmax_0_orig = sim_params.xsz * dx_finest;
	real ymax_0_orig = sim_params.ysz * dx_finest;

	real*           h        = new real[d_assem_sol.length];
	real*           qx       = new real[d_assem_sol.length];
	real*           qy       = new real[d_assem_sol.length];
	real*           z        = new real[d_assem_sol.length];
	real*           dt       = new real[d_assem_sol.length];
	HierarchyIndex* act_idcs = new HierarchyIndex[d_assem_sol.length];
	int*            levels   = new int[d_assem_sol.length];

	size_t bytes_flow     = d_assem_sol.length * sizeof(real);
	size_t bytes_act_idcs = d_assem_sol.length * sizeof(HierarchyIndex);
	size_t bytes_levels   = d_assem_sol.length * sizeof(int);
	
	copy_cuda(h,        d_assem_sol.h0,       bytes_flow);
	copy_cuda(qx,       d_assem_sol.qx0,      bytes_flow);
	copy_cuda(qy,       d_assem_sol.qy0,      bytes_flow);
	copy_cuda(z,        d_assem_sol.z0,       bytes_flow);
	copy_cuda(dt,       d_dt_CFL,             bytes_flow);
	copy_cuda(act_idcs, d_assem_sol.act_idcs, bytes_act_idcs);
	copy_cuda(levels,   d_assem_sol.levels,   bytes_levels);

	// number of cells excluding those in extended domain
	int num_bound = 0;

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		HierarchyIndex act_idx  = act_idcs[i];
		int      level    = levels[i];

		MortonCode code = act_idx - get_lvl_idx(level);

		real local_cell_size_x = dx_finest * ( 1 << (solver_params.L - level) );
		real local_cell_size_y = dy_finest * ( 1 << (solver_params.L - level) );

		Coordinate x = compact(code);
		Coordinate y = compact(code >> 1);

		real x_centre = x * local_cell_size_x + local_cell_size_x / C(2.0);
		real y_centre = y * local_cell_size_y + local_cell_size_y / C(2.0);

		bool bound = (x_centre < xmax_0_orig && y_centre < ymax_0_orig);

		//if (!bound) continue;

		num_bound++;

		Points points =
		{
			sim_params.xmin + x * local_cell_size_x,       // lower left  x
			sim_params.ymin + y * local_cell_size_y,       // lower left  y
			sim_params.xmin + x * local_cell_size_x,       // upper left  x
			sim_params.ymin + (y + 1) * local_cell_size_y, // upper left  y
			sim_params.xmin + (x + 1) * local_cell_size_x, // lower right x
			sim_params.ymin + y * local_cell_size_y,       // lower right y
			sim_params.xmin + (x + 1) * local_cell_size_x, // upper right x
			sim_params.ymin + (y + 1) * local_cell_size_y  // upper right y
		};

		fprintf
		(
			fp,
			"%" NUM_FRMT " %" NUM_FRMT " %" NUM_FRMT "\n"
			"%" NUM_FRMT " %" NUM_FRMT " %" NUM_FRMT "\n"
			"%" NUM_FRMT " %" NUM_FRMT " %" NUM_FRMT "\n"
			"%" NUM_FRMT " %" NUM_FRMT " %" NUM_FRMT "\n",
			points.ll_x, points.ll_y, C(1.0),
			points.ul_x, points.ul_y, C(1.0),
			points.lr_x, points.lr_y, C(1.0),
			points.ur_x, points.ur_y, C(1.0)
		);
	}

	fprintf(fp, "\nCELLS %d %d\n", d_assem_sol.length, d_assem_sol.length * 5);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		// point counter to make sure correct vertices per cell
		int pt_ctr = i * 4;

		fprintf(fp, "4 %d %d %d %d\n", 0 + pt_ctr, 1 + pt_ctr, 2 + pt_ctr, 3 + pt_ctr);
	}

	fprintf(fp, "\nCELL_TYPES %d\n", d_assem_sol.length);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		fprintf(fp, "%d\n", 8);
	}

	fprintf(fp, "\nCELL_DATA %d\n", d_assem_sol.length);

	fprintf
	(
		fp,
		"\nSCALARS dt float 1\n"
		"LOOKUP_TABLE default\n"
	);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		fprintf( fp, "%" NUM_FRMT "\n", dt[i] );
	}
	
	fprintf
	(
		fp,
		"\nSCALARS h float 1\n"
		"LOOKUP_TABLE default\n"
	);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		fprintf( fp, "%" NUM_FRMT "\n", h[i] );
	}
	
	fprintf
	(
		fp,
		"\nSCALARS qx float 1\n"
		"LOOKUP_TABLE default\n"
	);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		real vx = (h[i] < solver_params.tol_h) ? C(0.0) : qx[i] / h[i];
		
		fprintf( fp, "%" NUM_FRMT "\n", qx[i]);
	}

	fprintf
	(
		fp,
		"\nSCALARS qy float 1\n"
		"LOOKUP_TABLE default\n"
	);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		real vy = (h[i] < solver_params.tol_h) ? C(0.0) : qy[i] / h[i];
		
		fprintf( fp, "%" NUM_FRMT "\n", qy[i]);
	}

	fprintf
	(
		fp,
		"\nSCALARS z float 1\n"
		"LOOKUP_TABLE default\n"
	);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		fprintf( fp, "%" NUM_FRMT "\n", z[i] );
	}
	
	fprintf
	(
		fp,
		"\nSCALARS eta float 1\n"
		"LOOKUP_TABLE default\n"
	);

	for (int i = 0; i < d_assem_sol.length; i++)
	{
		fprintf( fp, "%" NUM_FRMT "\n", h[i] + z[i] );
	}

	fclose(fp);

	delete[] h;
	delete[] qx;
	delete[] qy;
	delete[] z;
	delete[] dt;
	delete[] act_idcs;
	delete[] levels;
}
#pragma once

#include <cstdio>
#include <cstdlib>

#include "../utilities/cuda_utils.cuh"

#include "../classes/Points.h"
#include "../classes/AssembledSolution.h"
#include "../classes/SimulationParams.h"
#include "../classes/SolverParams.h"
#include "../classes/PlottingParams.h"
#include "../classes/SaveInterval.h"

#include "../zorder/compact.cuh"
#include "../utilities/get_lvl_idx.cuh"

__host__ void write_soln_vtk
(
	const PlottingParams&    plot_params,
	const AssembledSolution& d_assem_sol,
	      real*              d_dt_CFL,
	const real&              dx_finest,
	const real&              dy_finest,
	const SimulationParams&  sim_params,
	const SolverParams&      solver_params,
	const SaveInterval&      saveint
);
#include "write_stage_point_data.cuh"

__host__
void write_stage_point_data
(
	const int&            mesh_dim,
	const SolverParams&   solver_params,
	const PlottingParams& plot_params,
	AssembledSolution     d_plot_assem_sol,
	FinestGrid            p_finest_grid,
	StagePoints           stage_points,
	const real&           current_time,
	const real&           dx_finest,
	const real&           dy_finest,
	const bool&           first_t_step
)
{
	if (stage_points.num_points == 0) return;
	
	int num_finest_elems = mesh_dim * mesh_dim;
	
	size_t bytes = sizeof(real) * num_finest_elems;

	copy_cuda(p_finest_grid.h, d_plot_assem_sol.h0, bytes);
	copy_cuda(p_finest_grid.z, d_plot_assem_sol.z0, bytes);
	
	if (plot_params.voutput_stage)
	{
		copy_cuda(p_finest_grid.qx, d_plot_assem_sol.qx0, bytes);
		copy_cuda(p_finest_grid.qy, d_plot_assem_sol.qy0, bytes);
	}

	char fullpath_h[255]  = {"\0"};
	char fullpath_vx[255] = {"\0"};
	char fullpath_vy[255] = {"\0"};

	sprintf(fullpath_h,  "%s%c%s%s", plot_params.dirroot, '/', plot_params.resroot, ".stage");
	sprintf(fullpath_vx, "%s%c%s%s", plot_params.dirroot, '/', plot_params.resroot, ".xvelocity");
	sprintf(fullpath_vy, "%s%c%s%s", plot_params.dirroot, '/', plot_params.resroot, ".yvelocity");
	
	FILE* fp_h  = fopen(fullpath_h,  (first_t_step) ? "w" : "a");
	FILE* fp_vx = fopen(fullpath_vx, (first_t_step) ? "w" : "a");
	FILE* fp_vy = fopen(fullpath_vy, (first_t_step) ? "w" : "a");

	if (NULL == fp_h || NULL == fp_vx || NULL == fp_vy)
	{
		fprintf(stderr, "Error opening stage results file, file: %s, line: %d.\n", __FILE__, __LINE__);
		exit(-1);
	}

	if (first_t_step)
	{
		fprintf(fp_h, "Stage output, depth (m).\n\n");
		fprintf(fp_h, "Stage information (stage,x,y,elev):\n");

		for (int point = 0; point < stage_points.num_points; point++)
		{
			Coordinate i = get_i_index( stage_points.codes[point] );
			Coordinate j = get_j_index( stage_points.codes[point] );
			
			int idx = mesh_dim * j + i;

			fprintf
			(
				fp_h,
				"%d"           // stage point number
				" %" NUM_FRMT  // x coordinate
				" %" NUM_FRMT  // y coordinate
				" %" NUM_FRMT  // elevation (z) 
				"\n",
				point + 1,
				i * dx_finest + dx_finest / C(2.0),
				j * dy_finest + dy_finest / C(2.0),
				p_finest_grid.z[idx]
			);
		}
		
		fprintf(fp_h, "\nOutput, depths:\n");
		fprintf(fp_h, "Time; stages 1 to %d\n", stage_points.num_points);
		
		if (plot_params.voutput_stage)
		{
		    fprintf(fp_vx, "Stage output, x velocity (m/s).\n\n");
		    fprintf(fp_vx, "Stage information (stage,x,y,elev):\n");
		   
			fprintf(fp_vy, "Stage output, y velocity (m/s).\n\n");
		    fprintf(fp_vy, "Stage information (stage,x,y,elev):\n");
		    
		    for (int point = 0; point < stage_points.num_points; point++)
		    {
		    	Coordinate i = get_i_index( stage_points.codes[point] );
		    	Coordinate j = get_j_index( stage_points.codes[point] );
		    	
		    	int idx = mesh_dim * j + i;
		    
		    	fprintf
		    	(
		    		fp_vx,
		    		"%d"           // stage point number
		    		" %" NUM_FRMT  // x coordinate
		    		" %" NUM_FRMT  // y coordinate
		    		" %" NUM_FRMT  // elevation (z) 
		    		"\n",
		    		point + 1,
		    		i * dx_finest + dx_finest / C(2.0),
		    		j * dy_finest + dy_finest / C(2.0),
		    		p_finest_grid.z[idx]
		    	);

				fprintf
		    	(
		    		fp_vy,
		    		"%d"           // stage point number
		    		" %" NUM_FRMT  // x coordinate
		    		" %" NUM_FRMT  // y coordinate
		    		" %" NUM_FRMT  // elevation (z) 
		    		"\n",
		    		point + 1,
		    		i * dx_finest + dx_finest / C(2.0),
		    		j * dy_finest + dy_finest / C(2.0),
		    		p_finest_grid.z[idx]
		    	);
		    }
		    
		    fprintf(fp_vx, "\nOutput, x velocities:\n");
		    fprintf(fp_vx, "Time; stages 1 to %d\n", stage_points.num_points);
			
			fprintf(fp_vy, "\nOutput, y velocities:\n");
		    fprintf(fp_vy, "Time; stages 1 to %d\n", stage_points.num_points);
		}
	}

	fprintf(fp_h, "%" NUM_FRMT " ", current_time);

	if (plot_params.voutput_stage)
	{
		fprintf(fp_vx, "%" NUM_FRMT " ", current_time);
		fprintf(fp_vy, "%" NUM_FRMT " ", current_time);
	}

	for (int point = 0; point < stage_points.num_points; point++)
	{
		Coordinate i = get_i_index( stage_points.codes[point] );
		Coordinate j = get_j_index( stage_points.codes[point] );

		int idx = j * mesh_dim + i;

		fprintf
		(
			fp_h,
			( (point + 1) == stage_points.num_points )
			? "%" NUM_FRMT
			: "%" NUM_FRMT " ",
			p_finest_grid.h[idx]
		);

		if (plot_params.voutput_stage)
		{
			real vx = (p_finest_grid.h[idx] < solver_params.tol_h) ? C(0.0) : p_finest_grid.qx[idx] / p_finest_grid.h[idx];
			real vy = (p_finest_grid.h[idx] < solver_params.tol_h) ? C(0.0) : p_finest_grid.qy[idx] / p_finest_grid.h[idx];

			fprintf
			(
				fp_vx,
				( (point + 1) == stage_points.num_points )
				? "%" NUM_FRMT
				: "%" NUM_FRMT " ",
				vx
			);

			fprintf
			(
				fp_vy,
				( (point + 1) == stage_points.num_points )
				? "%" NUM_FRMT
				: "%" NUM_FRMT " ",
				vy
			);
		}
	}

	fprintf(fp_h, "\n");
	
	if (plot_params.voutput_stage)
	{
		fprintf(fp_vx, "\n");
		fprintf(fp_vy, "\n");
	}

	fclose(fp_h);
	fclose(fp_vx);
	fclose(fp_vy);
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include <cstdio>
#include <cstdlib>

#include "../classes/AssembledSolution.h"
#include "../classes/ScaleCoefficients.h"
#include "../classes/SolverParams.h"
#include "../classes/PlottingParams.h"
#include "../classes/StagePoints.h"
#include "../classes/FinestGrid.h"

#include "../zorder/get_i_index.cuh"
#include "../zorder/get_j_index.cuh"

__host__
void write_stage_point_data
(
    const int&            mesh_dim,
	const SolverParams&   solver_params,
	const PlottingParams& plot_params,
	AssembledSolution     d_plot_assem_sol,
	FinestGrid            p_finest_grid,
	StagePoints           stage_points,
	const real&           current_time,
	const real&           dx_finest,
	const real&           dy_finest,
	const bool&           first_t_step
);
#pragma once

#include "h_init_overtopping.cuh"
#include "h_init_c_property.cuh"
#include "h_init_radial.cuh"
#include "h_init_three_peaks.cuh"
#include "h_init_three_blocks.cuh"
#include "h_init_parabolic_bowl.cuh"

__device__ __forceinline__
real h_init
(
	const real& x_int,
	const real& y_int,
	const real& z_int,
	const Depths1D& bcs,
	const int& test_case
)
{
	real h_int = 0;

	switch (test_case)
	{
	    case 1: // wet c prop x dir
	    case 3: // wet-dry c prop x dir
	    	h_int = h_init_c_property(bcs, z_int, x_int);
	    	break;
	    case 2: // wet c prop y dir
	    case 4: // wet-dry c prop y dir
	    	h_int = h_init_c_property(bcs, z_int, y_int);
	    	break;
	    case 5:  // wet dam break x dir
	    case 7:  // dry dam break x dir
	    case 9:  // dry dam break x dir w fric
	    case 11: // wet building overtopping x dir
	    case 13: // dry building overtopping x dir
	    	h_int = h_init_overtopping(bcs, z_int, x_int);
	    	break;
	    case 6:  // wet dam break y dir
	    case 8:  // dry dam break y dir
	    case 10: // dry dam break y dir w fric
	    case 12: // wet building overtopping y dir
	    case 14: // dry building overtopping y dir
	    	h_int = h_init_overtopping(bcs, z_int, y_int);
	    	break;
	    case 15: // triangular dam break x dir
	    	h_int = ( x_int < C(15.5) ) ? C(0.75) : C(0.0);
	    	break;
	    case 16: // triangular dam break y dir
	    	h_int = ( y_int < C(15.5) ) ? C(0.75) : C(0.0);
	    	break;
	    case 17: // parabolic bowl x dir
			h_int = h_init_parabolic_bowl(x_int, z_int);
	    	break;
	    case 18: // parabolic bowl y dir
	    	h_int = h_init_parabolic_bowl(y_int, z_int);
	    	break;
	    case 19: // three cones
	    	h_int = C(1.0) - z_int;
	    	break;
	    case 20: // three cones dam break
	    	h_int = ( x_int < C(16.0) ) ? max( (C(1.875) - z_int), C(0.0) ) : C(0.0);
	    	break;
	    case 21: // differential geometry
	    	h_int = C(1.95) - z_int;
	    	break;
	    case 22: // non-differential geometry
	    	h_int = C(1.78) - z_int;
	    	break;
	    case 23: // radial dam break
	    	h_int = h_init_radial(x_int, y_int);
	    	break;
	    default:
	    	break;
	}

	return h_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../classes/Depths1D.h"

__device__ __forceinline__
real h_init_c_property
(
	const Depths1D& bcs, 
	const real&     z_int,
	const real&     x_or_y_int
)
{
	real eta_west = bcs.hl;
	real eta_east = bcs.hr;

	real h = eta_west - z_int;

	return h;

	return (h < 0) ? 0 : h;

	return (x_or_y_int <= 25) ? ( (h < 0) ? bcs.hl : h ) : eta_east - z_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../classes/Depths1D.h"

__device__ __forceinline__
real h_init_overtopping
(
	const Depths1D& bcs, 
	const real&               z_int, 
	const real&               x_or_y_int
)
{
	return (x_or_y_int <= 25) ? max(C(0.0), bcs.hl - z_int) : max(C(0.0), bcs.hr - z_int);
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

// inspired from https://core.ac.uk/download/pdf/196597598.pdf
__device__ __forceinline__
real h_init_parabolic_bowl
(
	const real& x_or_y_int,
	const real& z_int
)
{
	const real eta = C(0.2) * x_or_y_int + C(10.0);

	return max(C(0.0), eta - z_int);
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

__device__ __forceinline__
real h_init_radial
(
	const real& x_int,
	const real& y_int
)
{
	const real r = sqrt(x_int * x_int + y_int * y_int);

	return ( r < C(2.5) ) ? C(2.5) : C(0.5);
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

__device__ __forceinline__
real h_init_three_blocks
(
	const real& z_int
)
{
	return C(1.78) - z_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

__device__ __forceinline__
real h_init_three_peaks
(
	const real& z_int
)
{
	return C(1.95) - z_int;
}
#pragma once

#include "topo_c_prop_1D.cuh"
#include "topo_three_cones.cuh"
#include "topo_diff.cuh"
#include "topo_non_diff.cuh"
#include "topo_triangle.cuh"
#include "topo_parabolic_bowl.cuh"

// generate theoretical topography based on x, y nodal values
__device__ __forceinline__
real topo
(
	const real& x_int, 
	const real& y_int, 
	const int&  test_case
)
{
	real z_int = C(0.0);

	switch (test_case)
	{
	    case 1:
	    case 3:
	    	// variant along x-direction
	    	z_int = topo_c_prop_1D(x_int);
	    	break;
	    case 2:
	    case 4:
	    	// variant along y-direction
	    	z_int = topo_c_prop_1D(y_int);
	    	break;
	    case 11: // wet building overtopping x dir
		case 13: // wet-dry building overtopping x dir
	    	z_int = topo_c_prop_1D(x_int);
	    	break;
	    case 12: // wet building overtopping y dir
		case 14: // wet-dry building overtopping y dir
	    	z_int = topo_c_prop_1D(y_int);
	    	break;
	    case 15:
	    	z_int = topo_triangle(x_int);
	    	break;
	    case 16:
	    	z_int = topo_triangle(y_int);
	    	break;
	    case 17:
	    	// parabolic bowl in x dir
	    	// parabolic eqn is y = ax^2
	    	z_int = topo_parabolic_bowl(x_int);
	    	break;
	    case 18:
	    	// parabolic bowl in y dir
	    	z_int = topo_parabolic_bowl(y_int);
	    	break;
	    case 19:
	    case 20:
	    	// three cones c prop and dam break
			z_int = topo_three_cones(x_int, y_int);
	    	break;
	    case 21:
	    	z_int = topo_diff(x_int, y_int);
	    	break;
	    case 22:
	    	z_int = topo_non_diff(x_int, y_int);
	    	break;
	    default:
	    	break;
	}

	return z_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

/*
 * 1D topography mimicking the c-property test case from GK's HFV1_MATLAB
 * see: https://github.com/ci1xgk/HFV1_MATLAB/tree/master/Test1_C_Pty
 * if x nodal values are input, topography will vary only along x-direction
 * likewise, if y nodal value is input, topography will vary only along y-direction
 */

__device__ __forceinline__ 
real topo_c_prop_1D(real x_or_y_int)
{
	real a = x_or_y_int;
	real z_int;

	if (a >= 22 && a < 25)
	{
		z_int = C(0.05) * a - C(1.1);
	}
	else if (a >= 25 && a <= 28)
	{
		z_int = C(-0.05) * a + C(1.4);
	}
	else if (a > 8 && a < 12)
	{
		z_int = C(0.2) - C(0.05) * (a - 10) * (a - 10);
	}
	else if (a > 39 && a < 46.5)
	{
		z_int = C(0.3);
	}
	else
	{
		z_int = 0;
	}
	
	return C(10.0) * z_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

// from https://www.sciencedirect.com/science/article/pii/S004578251830389X
__device__ __forceinline__
real topo_diff
(
	const real& x_int,
	const real& y_int
)
{
	real z_int = 0;

	real cone1 = C(1.0) - C(0.2) * sqrt( ( x_int - C(20.0) ) * ( x_int - C(20.0) ) + ( y_int - C(15.0) ) * ( y_int - C(15.0) ) );
	real cone2 = C(2.0) - C(0.5) * sqrt( ( x_int - C(40.0) ) * ( x_int - C(40.0) ) + ( y_int - C(15.0) ) * ( y_int - C(15.0) ) );
	real cone3 = C(3.0) - C(0.3) * sqrt( ( x_int - C(60.0) ) * ( x_int - C(60.0) ) + ( y_int - C(15.0) ) * ( y_int - C(15.0) ) );

	z_int = max(z_int, cone1);
	z_int = max(z_int, cone2);
	z_int = max(z_int, cone3);

	return z_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

// from https://www.sciencedirect.com/science/article/pii/S004578251830389X
__device__ __forceinline__
real topo_non_diff
(
	const real& x_int,
	const real& y_int
)
{
	real z_int = 0;

	bool y_bound = ( C(11.0) <= y_int && y_int <= C(19.0) );

	if (C(16.0) <= x_int && x_int <= C(24.0) && y_bound)
	{
		z_int = C(0.86);
	}
	else if (C(36.0) <= x_int && x_int <= C(44.0) && y_bound)
	{
		z_int = C(1.78);
	}
	else if (C(56.0) <= x_int && x_int <= C(64.0) && y_bound)
	{
		z_int = C(2.30);
	}

	return z_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

__device__ __forceinline__
real topo_parabolic_bowl
(
	const real& x_or_y_int
)
{
	return C(0.01) * x_or_y_int * x_or_y_int;
}
#pragma once

#include "cuda_runtime.h"

#include <math.h>

#include "../types/real.h"

__device__ __forceinline__
real topo_three_cones
(
	real x_int,
	real y_int
)
{
	
	real z_int = 0;

	real x_1 = 30;
	real y_1 = 6;
	real x_2 = 30;
	real y_2 = 24;
	real x_3 = C(47.5);
	real y_3 = 15;

	int rm_1 = 8;
	int rm_2 = 8;
	int rm_3 = 10;

	real r_1 = sqrt( (x_int - x_1) * (x_int - x_1) + (y_int - y_1) * (y_int - y_1) );
	real r_2 = sqrt( (x_int - x_2) * (x_int - x_2) + (y_int - y_2) * (y_int - y_2) );
	real r_3 = sqrt( (x_int - x_3) * (x_int - x_3) + (y_int - y_3) * (y_int - y_3) );

	real zb_1 = (rm_1 - r_1) / 8;
	real zb_2 = (rm_2 - r_2) / 8;
	real zb_3 = C(0.3) * (rm_3 - r_3);

	z_int = max(zb_1 , zb_2);
	z_int = max(z_int, zb_3);
	z_int = max(z_int, C(0.0) );

	return z_int;
}
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

// from https://www.sciencedirect.com/science/article/pii/S0309170815002237
__device__ __forceinline__
real topo_triangle
(
	const real& x_or_y_int
)
{
	real slope = C(0.4) / C(3.0);
	
	real z_int = C(0.0);

	if ( x_or_y_int > C(25.5) && x_or_y_int <= C(28.5) )
	{
		z_int = ( x_or_y_int - C(25.5) ) * slope;
	}
	else if ( x_or_y_int > C(28.5) && x_or_y_int <= C(31.5) )
	{
		z_int = C(0.4) - ( x_or_y_int - C(28.5) ) * slope;
	}

	return z_int;
}
#pragma once

typedef int Coordinate;
#pragma once

enum Directions
{
    NORTH = 1, // 0001
    EAST  = 2, // 0010
    SOUTH = 4, // 0100
    WEST  = 8  // 1000

    // NORTH | EAST = 3
    // NORTH | WEST = 9
    // SOUTH | EAST = 6
    // SOUTH | WEST = 12
};
#pragma once

typedef int HierarchyIndex;
#pragma once

enum InletTypes
{
	CLOSED = 1,
	FREE   = 2,
	HFIX   = 4,
	HVAR   = 8,
	QFIX   = 16,
	QVAR   = 32
};
#pragma once

typedef int MortonCode;
#pragma once

#if _USE_DOUBLES == 1

typedef double real;
#define C(x) x
#define NUM_FRMT "lf"
#define NUM_FIG  ".15"

#else

typedef float real;
#define C(x) x##f
#define NUM_FRMT "f"
#define NUM_FIG  ".8"

#endif
#pragma once

enum SolverTypes
{
	HWFV1 = 1,
	MWDG2 = 2
};
target_sources(
	    gpu-mwdg2
		PRIVATE
		generate_data_unit_tests.cu
        run_unit_tests.cu
        unit_tests_classes.cu
        unit_tests_output.cu
        unit_tests_input.cu
        unit_tests_mra.cu
        unit_tests_utilities.cu
	)
#include "generate_data_unit_tests.cuh"

void generate_data_unit_test_preflag_topo
(
	const char*       dirroot,
	const char*       input_or_output_str,
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	bool*             d_preflagged_details,
	SolverParams      solver_params
)
{
	char prefix[255] = {'\0'};

	sprintf
	(
		prefix,
		"%s%s%s",
		"unit_test_preflag_topo_",
		(solver_params.solver_type == HWFV1) ? "HW-" : "MW-",
		input_or_output_str
	);

	d_scale_coeffs.write_to_file(dirroot, prefix);
	d_details.write_to_file(dirroot, prefix);

	char filename_preflagged_details[255] = {'\0'};

	sprintf
	(
		filename_preflagged_details,
		"%s%s%s%s",
		"unit_test_preflag_topo_",
		(d_scale_coeffs.solver_type == HWFV1) ? "HW-" : "MW-",
		input_or_output_str,
		"-preflagged-details"
	);

	write_hierarchy_array_bool(dirroot, filename_preflagged_details, d_preflagged_details, solver_params.L - 1);
}

void generate_data_unit_test_encode_flow
(
	const char*       dirroot,
	const char*       input_or_output_str,
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	SolverParams      solver_params,
	const int&        timestep
)
{
	const std::string timestep_str = std::to_string(timestep);

	const std::string solver_str = (solver_params.solver_type == HWFV1) ? "_HW-" : "_MW-";
	
	const std::string prefix = "unit_test_encode_flow_TIMESTEP_" + timestep_str + solver_str + input_or_output_str;
	
	d_scale_coeffs.write_to_file( dirroot, prefix.c_str() );
	d_details.write_to_file( dirroot, prefix.c_str() );
	write_hierarchy_array_real(dirroot, (prefix + "-norm-details").c_str(),       d_norm_details,        solver_params.L - 1);
	write_hierarchy_array_bool(dirroot, (prefix + "-sig-details").c_str(),        d_sig_details,         solver_params.L - 1);
	write_hierarchy_array_bool(dirroot, (prefix + "-preflagged-details").c_str(), d_preflagged_details,  solver_params.L - 1);

}

void generate_data_unit_test_decoding
(
	const char*       dirroot,
	const char*       input_or_output_str,
	bool*             d_sig_details,
	real*             d_norm_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,	
	const int&        timestep
)
{
	const std::string timestep_str = std::to_string(timestep);

	const std::string solver_str = (solver_params.solver_type == HWFV1) ? "_HW-" : "_MW-";
	
	const std::string prefix = "unit_test_decoding_TIMESTEP_" + timestep_str + solver_str + input_or_output_str;
	
	d_scale_coeffs.write_to_file( dirroot, prefix.c_str() );
	d_details.write_to_file( dirroot, prefix.c_str() );
	write_hierarchy_array_real(dirroot, (prefix + "-norm-details").c_str(),       d_norm_details,        solver_params.L - 1);
	write_hierarchy_array_bool(dirroot, (prefix + "-sig-details").c_str(),        d_sig_details,         solver_params.L - 1);
}
#pragma once

#include <string>

#include "../classes/Details.h"
#include "../classes/ScaleCoefficients.h"
#include "../output/write_hierarchy_array_bool.cuh"

void generate_data_unit_test_preflag_topo
(
	const char*       dirroot,
	const char*       input_or_output_str,
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	bool*             d_preflagged_details,
	SolverParams      solver_params
);

void generate_data_unit_test_encode_flow
(
	const char*       dirroot,
	const char*       input_or_output_str,
	ScaleCoefficients d_scale_coeffs,
	Details           d_details,
	real*             d_norm_details,
	bool*             d_sig_details,
	bool*             d_preflagged_details,
	SolverParams      solver_params,
	const int&        timestep
);

void generate_data_unit_test_decoding
(
	const char*       dirroot,
	const char*       input_or_output_str,
	bool*             d_sig_details,
	real*             d_norm_details,
	Details           d_details,
	ScaleCoefficients d_scale_coeffs,
	SolverParams      solver_params,
	const int&        timestep
);
#include "run_unit_tests.cuh"

#if _RUN_UNIT_TESTS

void run_unit_tests()
{
	run_unit_tests_classes();
	run_unit_tests_output();
	run_unit_tests_input();
	run_unit_tests_mra();
	run_unit_tests_utilities();
}

#endif
#pragma once

#include "unit_tests_classes.cuh"
#include "unit_tests_output.cuh"
#include "unit_tests_input.cuh"
#include "unit_tests_mra.cuh"
#include "unit_tests_utilities.cuh"

void run_unit_tests();
#include "unit_tests_classes.cuh"

#if _RUN_UNIT_TESTS

#define TEST_MESSAGE_PASSED_ELSE_FAILED { printf("Passed %s!\n", __func__); } else { printf("Failed %s.\n", __func__); }

void unit_test_scale_coeffs_CONSTRUCTOR_LEVELS_HW()
{
	SolverParams solver_params;

	solver_params.L           = 1;
	solver_params.solver_type = HWFV1;

	ScaleCoefficients d_scale_coeffs(solver_params);

	bool passed =
	(
		d_scale_coeffs.is_copy_cuda == false &&
		d_scale_coeffs.levels       == solver_params.L &&
		d_scale_coeffs.solver_type  == solver_params.solver_type &&
		d_scale_coeffs.eta0         != nullptr &&
		d_scale_coeffs.qx0          != nullptr &&
		d_scale_coeffs.qy0          != nullptr &&
		d_scale_coeffs.z0           != nullptr &&
		d_scale_coeffs.eta1x        == nullptr &&
		d_scale_coeffs.qx1x         == nullptr &&
		d_scale_coeffs.qy1x         == nullptr &&
		d_scale_coeffs.z1x          == nullptr &&
		d_scale_coeffs.eta1y        == nullptr &&
		d_scale_coeffs.qx1y         == nullptr &&
		d_scale_coeffs.qy1y         == nullptr &&
		d_scale_coeffs.z1y          == nullptr
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_CONSTRUCTOR_FILES_HW()
{
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_scale_coeffs_CONSTRUCTOR_FILES_HW";

	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = HWFV1;

	ScaleCoefficients d_scale_coeffs(solver_params, dirroot, prefix);

	const int array_length = get_lvl_idx(solver_params.L + 1);
	real* h_scale_coeffs = new real[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_scale_coeffs[i] = i;
	}

	const real error_eta0  = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.eta0,  array_length);
	const real error_qx0   = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qx0,   array_length);
	const real error_qy0   = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qy0,   array_length);
	const real error_z0    = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.z0,    array_length);
	
	const real expected_error = C(1e-6);

	bool passed = 
	(
		are_reals_equal(error_eta0,  expected_error) &&
		are_reals_equal(error_qx0,   expected_error) &&
		are_reals_equal(error_qy0,   expected_error) &&
		are_reals_equal(error_z0,    expected_error)
	);

	delete[] h_scale_coeffs;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_WRITE_TO_FILE_HW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = HWFV1;

	ScaleCoefficients d_scale_coeffs(solver_params);

	const int array_length = get_lvl_idx(solver_params.L + 1);
	const size_t bytes     = array_length * sizeof(real);
	real* h_scale_coeffs    = new real[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_scale_coeffs[i] = i;
	}

	copy_cuda(d_scale_coeffs.eta0, h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx0,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy0,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z0,   h_scale_coeffs, bytes);

	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_scale_coeffs_WRITE_TO_FILE_HW";

	d_scale_coeffs.write_to_file(dirroot, prefix);
	
	char filename_eta0[255] = {'\0'};
	char filename_qx0[255]  = {'\0'};
	char filename_qy0[255]  = {'\0'};
	char filename_z0[255]   = {'\0'};

	sprintf(filename_eta0, "%s%s", prefix, "-scale-coeffs-eta0-hw");
	sprintf(filename_qx0,  "%s%s", prefix, "-scale-coeffs-qx0-hw");
	sprintf(filename_qy0,  "%s%s", prefix, "-scale-coeffs-qy0-hw");
	sprintf(filename_z0,   "%s%s", prefix, "-scale-coeffs-z0-hw");

	const real error_eta0 = compare_array_with_file_real(dirroot, filename_eta0, h_scale_coeffs, array_length);
	const real error_qx0  = compare_array_with_file_real(dirroot, filename_qx0,  h_scale_coeffs, array_length);
	const real error_qy0  = compare_array_with_file_real(dirroot, filename_qy0,  h_scale_coeffs, array_length);
	const real error_z0   = compare_array_with_file_real(dirroot, filename_z0,   h_scale_coeffs, array_length);

	const real expected_error = C(1e-6);

	bool passed = 
	(
		are_reals_equal(error_eta0, expected_error) &&
		are_reals_equal(error_qx0,  expected_error) &&
		are_reals_equal(error_qy0,  expected_error) &&
		are_reals_equal(error_z0,   expected_error)
	);

	delete[] h_scale_coeffs;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_VERIFY_HW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = HWFV1;

	ScaleCoefficients d_scale_coeffs(solver_params);

	const int array_length = get_lvl_idx(solver_params.L + 1);
	const size_t bytes     = array_length * sizeof(real);
	real* h_scale_coeffs    = new real[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_scale_coeffs[i] = i;
	}

	copy_cuda(d_scale_coeffs.eta0, h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx0,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy0,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z0,   h_scale_coeffs, bytes);
	
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_scale_coeffs_VERIFY_HW";

	const real actual_error   = d_scale_coeffs.verify(dirroot, prefix);
	const real expected_error = C(0.0);

	delete[] h_scale_coeffs;

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_CONSTRUCTOR_LEVELS_MW()
{
	SolverParams solver_params;

	solver_params.L           = 1;
	solver_params.solver_type = MWDG2;

	ScaleCoefficients d_scale_coeffs(solver_params);

	bool passed =
	(
		d_scale_coeffs.is_copy_cuda == false &&
		d_scale_coeffs.levels       == solver_params.L &&
		d_scale_coeffs.solver_type  == solver_params.solver_type &&
		d_scale_coeffs.eta0         != nullptr &&
		d_scale_coeffs.qx0          != nullptr &&
		d_scale_coeffs.qy0          != nullptr &&
		d_scale_coeffs.z0           != nullptr &&
		d_scale_coeffs.eta1x        != nullptr &&
		d_scale_coeffs.qx1x         != nullptr &&
		d_scale_coeffs.qy1x         != nullptr &&
		d_scale_coeffs.z1x          != nullptr &&
		d_scale_coeffs.eta1y        != nullptr &&
		d_scale_coeffs.qx1y         != nullptr &&
		d_scale_coeffs.qy1y         != nullptr &&
		d_scale_coeffs.z1y          != nullptr
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_CONSTRUCTOR_FILES_MW()
{
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_scale_coeffs_CONSTRUCTOR_FILES_MW";

	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = MWDG2;

	ScaleCoefficients d_scale_coeffs(solver_params, dirroot, prefix);

	const int array_length = get_lvl_idx(solver_params.L + 1);
	real* h_scale_coeffs = new real[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_scale_coeffs[i] = i;
	}

	const real error_eta0  = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.eta0,  array_length);
	const real error_qx0   = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qx0,   array_length);
	const real error_qy0   = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qy0,   array_length);
	const real error_z0    = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.z0,    array_length);
	const real error_eta1x = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.eta1x, array_length);
	const real error_qx1x  = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qx1x,  array_length);
	const real error_qy1x  = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qy1x,  array_length);
	const real error_z1x   = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.z1x,   array_length);
	const real error_eta1y = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.eta1y, array_length);
	const real error_qx1y  = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qx1y,  array_length);
	const real error_qy1y  = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.qy1y,  array_length);
	const real error_z1y   = compare_array_on_device_vs_host_real(h_scale_coeffs, d_scale_coeffs.z1y,   array_length);

	const real expected_error = C(1e-6);

	bool passed = 
	(
		are_reals_equal(error_eta0,  expected_error) &&
		are_reals_equal(error_qx0,   expected_error) &&
		are_reals_equal(error_qy0,   expected_error) &&
		are_reals_equal(error_z0,    expected_error) &&
		are_reals_equal(error_eta1x, expected_error) &&
		are_reals_equal(error_qx1x,  expected_error) &&
		are_reals_equal(error_qy1x,  expected_error) &&
		are_reals_equal(error_z1x,   expected_error) &&
		are_reals_equal(error_eta1y, expected_error) &&
		are_reals_equal(error_qx1y,  expected_error) &&
		are_reals_equal(error_qy1y,  expected_error) &&
		are_reals_equal(error_z1y,   expected_error) 
	);

	delete[] h_scale_coeffs;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_WRITE_TO_FILE_MW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = MWDG2;

	ScaleCoefficients d_scale_coeffs(solver_params);

	const int array_length = get_lvl_idx(solver_params.L + 1);
	const size_t bytes     = array_length * sizeof(real);
	real* h_scale_coeffs    = new real[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_scale_coeffs[i] = i;
	}

	copy_cuda(d_scale_coeffs.eta0,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx0,   h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy0,   h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z0,    h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.eta1x, h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx1x,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy1x,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z1x,   h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.eta1y, h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx1y,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy1y,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z1y,   h_scale_coeffs, bytes);

	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_scale_coeffs_WRITE_TO_FILE_MW";

	d_scale_coeffs.write_to_file(dirroot, prefix);
	
	char filename_eta0[255]  = {'\0'};
	char filename_qx0[255]   = {'\0'};
	char filename_qy0[255]   = {'\0'};
	char filename_z0[255]    = {'\0'};
	char filename_eta1x[255] = {'\0'};
	char filename_qx1x[255]  = {'\0'};
	char filename_qy1x[255]  = {'\0'};
	char filename_z1x[255]   = {'\0'};
	char filename_eta1y[255] = {'\0'};
	char filename_qx1y[255]  = {'\0'};
	char filename_qy1y[255]  = {'\0'};
	char filename_z1y[255]   = {'\0'};

	sprintf(filename_eta0,  "%s%s", prefix, "-scale-coeffs-eta0-mw");
	sprintf(filename_qx0,   "%s%s", prefix, "-scale-coeffs-qx0-mw");
	sprintf(filename_qy0,   "%s%s", prefix, "-scale-coeffs-qy0-mw");
	sprintf(filename_z0,    "%s%s", prefix, "-scale-coeffs-z0-mw");
	sprintf(filename_eta1x, "%s%s", prefix, "-scale-coeffs-eta1x-mw");
	sprintf(filename_qx1x,  "%s%s", prefix, "-scale-coeffs-qx1x-mw");
	sprintf(filename_qy1x,  "%s%s", prefix, "-scale-coeffs-qy1x-mw");
	sprintf(filename_z1x,   "%s%s", prefix, "-scale-coeffs-z1x-mw");
	sprintf(filename_eta1y, "%s%s", prefix, "-scale-coeffs-eta1y-mw");
	sprintf(filename_qx1y,  "%s%s", prefix, "-scale-coeffs-qx1y-mw");
	sprintf(filename_qy1y,  "%s%s", prefix, "-scale-coeffs-qy1y-mw");
	sprintf(filename_z1y,   "%s%s", prefix, "-scale-coeffs-z1y-mw");

	const real error_eta0  = compare_array_with_file_real(dirroot, filename_eta0,  h_scale_coeffs, array_length);
	const real error_qx0   = compare_array_with_file_real(dirroot, filename_qx0,   h_scale_coeffs, array_length);
	const real error_qy0   = compare_array_with_file_real(dirroot, filename_qy0,   h_scale_coeffs, array_length);
	const real error_z0    = compare_array_with_file_real(dirroot, filename_z0,    h_scale_coeffs, array_length);
	const real error_eta1x = compare_array_with_file_real(dirroot, filename_eta1x, h_scale_coeffs, array_length);
	const real error_qx1x  = compare_array_with_file_real(dirroot, filename_qx1x,  h_scale_coeffs, array_length);
	const real error_qy1x  = compare_array_with_file_real(dirroot, filename_qy1x,  h_scale_coeffs, array_length);
	const real error_z1x   = compare_array_with_file_real(dirroot, filename_z1x,   h_scale_coeffs, array_length);
	const real error_eta1y = compare_array_with_file_real(dirroot, filename_eta1y, h_scale_coeffs, array_length);
	const real error_qx1y  = compare_array_with_file_real(dirroot, filename_qx1y,  h_scale_coeffs, array_length);
	const real error_qy1y  = compare_array_with_file_real(dirroot, filename_qy1y,  h_scale_coeffs, array_length);
	const real error_z1y   = compare_array_with_file_real(dirroot, filename_z1y,   h_scale_coeffs, array_length);

	const real expected_error = C(1e-6);

	bool passed = 
	(
		are_reals_equal(error_eta0,  expected_error) &&
		are_reals_equal(error_qx0,   expected_error) &&
		are_reals_equal(error_qy0,   expected_error) &&
		are_reals_equal(error_z0,    expected_error) &&
		are_reals_equal(error_eta1x, expected_error) &&
		are_reals_equal(error_qx1x,  expected_error) &&
		are_reals_equal(error_qy1x,  expected_error) &&
		are_reals_equal(error_z1x,   expected_error) &&
		are_reals_equal(error_eta1y, expected_error) &&
		are_reals_equal(error_qx1y,  expected_error) &&
		are_reals_equal(error_qy1y,  expected_error) &&
		are_reals_equal(error_z1y,   expected_error) 
	);

	delete[] h_scale_coeffs;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_VERIFY_MW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = MWDG2;

	ScaleCoefficients d_scale_coeffs(solver_params);

	const int array_length = get_lvl_idx(solver_params.L + 1);
	const size_t bytes     = array_length * sizeof(real);
	real* h_scale_coeffs    = new real[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_scale_coeffs[i] = i;
	}

	copy_cuda(d_scale_coeffs.eta0,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx0,   h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy0,   h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z0,    h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.eta1x, h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx1x,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy1x,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z1x,   h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.eta1y, h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qx1y,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.qy1y,  h_scale_coeffs, bytes);
	copy_cuda(d_scale_coeffs.z1y,   h_scale_coeffs, bytes);
	
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_scale_coeffs_VERIFY_MW";

	const real actual_error   = d_scale_coeffs.verify(dirroot, prefix);
	const real expected_error = C(0.0);

	delete[] h_scale_coeffs;

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_scale_coeffs_CONSTRUCTOR_COPY()
{
	SolverParams solver_params;

	ScaleCoefficients d_scale_coeffs(solver_params);

	ScaleCoefficients d_scale_coeffs_copy(d_scale_coeffs);

	if (d_scale_coeffs_copy.is_copy_cuda)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_subdetails_CONSTRUCTOR_DEFAULT()
{
	SubDetails d_subdetails;

	bool passed =
	(
		d_subdetails.alpha        == nullptr &&
		d_subdetails.beta         == nullptr &&
		d_subdetails.gamma        == nullptr &&
		d_subdetails.levels       == -1 &&
		d_subdetails.is_copy_cuda == false
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_subdetails_CONSTRUCTOR_LEVELS()
{
	SubDetails d_subdetails(0);

	bool initialised = test_subdetails_CONSTRUCTOR_LEVELS(d_subdetails);

	if (initialised)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_subdetails_CONSTRUCTOR_FILES()
{
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_subdetails_CONSTRUCTOR_FILES";
	const char* suffix  = "theta";

	const int levels = 3;

	SubDetails d_subdetails(levels, dirroot, prefix, suffix);

	const int num_details = get_lvl_idx(levels + 1);
	real* h_subdetails = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_subdetails[i] = i;
	}
	
	bool passed = test_subdetails_CONSTRUCTOR_FILES
	(
		h_subdetails,
		d_subdetails,
		num_details
	);

	delete[] h_subdetails;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_subdetails_WRITE_TO_FILE()
{
	const int levels = 3;
	const int num_details = get_lvl_idx(levels + 1);
	const size_t bytes = num_details * sizeof(real);
	real* h_subdetails = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_subdetails[i] = i;
	}

	SubDetails d_subdetails(levels);

	copy_cuda(d_subdetails.alpha, h_subdetails, bytes);
	copy_cuda(d_subdetails.beta , h_subdetails, bytes);
	copy_cuda(d_subdetails.gamma, h_subdetails, bytes);
	
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_subdetails_WRITE_TO_FILE";
	const char* suffix  = "theta";

	d_subdetails.write_to_file(dirroot, prefix, suffix);

	bool passed = test_subdetails_WRITE_TO_FILE
	(
		dirroot,
		prefix,
		suffix,
		h_subdetails,
		num_details
	);

	delete[] h_subdetails;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_subdetails_VERIFY()
{
	const int levels      = 3;
	const int num_details = get_lvl_idx(levels + 1);
	const size_t bytes    = num_details * sizeof(real);
	real* h_subdetails    = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_subdetails[i] = i;
	}

	SubDetails d_subdetails(levels);

	copy_cuda(d_subdetails.alpha, h_subdetails, bytes);
	copy_cuda(d_subdetails.beta,  h_subdetails, bytes);
	copy_cuda(d_subdetails.gamma, h_subdetails, bytes);
	
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_subdetails_VERIFY";
	const char* suffix  = "theta";

	const real actual_error   = d_subdetails.verify(dirroot, prefix, suffix);
	const real expected_error = C(0.0);

	delete[] h_subdetails;

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_subdetails_CONSTRUCTOR_COPY()
{
	SubDetails d_subdetails;

	SubDetails d_subdetails_copy(d_subdetails);

	if (d_subdetails_copy.is_copy_cuda)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_details_CONSTRUCTOR_LEVELS_HW()
{
	SolverParams solver_params;

	solver_params.L           = 1;
	solver_params.solver_type = HWFV1;

	Details d_details(solver_params);

	bool init_eta0  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.eta0);
	bool init_qx0   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qx0);
	bool init_qy0   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qy0);
	bool init_z0    = test_subdetails_CONSTRUCTOR_LEVELS(d_details.z0);
	
	bool init_eta1x = test_subdetails_CONSTRUCTOR_LEVELS(d_details.eta1x);
	bool init_qx1x  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qx1x);
	bool init_qy1x  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qy1x);
	bool init_z1x   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.z1x);
	
	bool init_eta1y = test_subdetails_CONSTRUCTOR_LEVELS(d_details.eta1y);
	bool init_qx1y  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qx1y);
	bool init_qy1y  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qy1y);
	bool init_z1y   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.z1y);

	bool subdetails_correctly_initialised =
	(
		init_eta0   && init_qx0   && init_qy0   && init_z0 &&
		!init_eta1x && !init_qx1x && !init_qy1x && !init_z1x &&
		!init_eta1y && !init_qx1y && !init_qy1y && !init_z1y
	);

	if (subdetails_correctly_initialised && d_details.solver_type == solver_params.solver_type)
		TEST_MESSAGE_PASSED_ELSE_FAILED

}

void unit_test_details_CONSTRUCTOR_FILES_HW()
{
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_details_CONSTRUCTOR_FILES_HW";
	
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = HWFV1;

	Details d_details(solver_params, dirroot, prefix);

	const int num_details = get_lvl_idx(d_details.eta0.levels + 1);
	real* h_details = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_details[i] = i;
	}

	bool passed_eta0 = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.eta0, num_details);
	bool passed_qx0  = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qx0,  num_details);
	bool passed_qy0  = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qy0,  num_details);
	bool passed_z0   = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.z0,   num_details);

	bool passed = passed_eta0 && passed_qx0 && passed_qy0 && passed_z0;

	delete[] h_details;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_details_WRITE_TO_FILE_HW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = HWFV1;

	Details d_details(solver_params);

	const int num_details = get_lvl_idx(d_details.eta0.levels + 1);
	const size_t bytes = num_details * sizeof(real);
	real* h_details = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_details[i] = i;
	}

	init_details(h_details, d_details, bytes);

	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_details_WRITE_TO_FILE_HW";

	d_details.write_to_file(dirroot, prefix);

	bool passed_eta0 = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "eta0-hw", h_details, num_details);
	bool passed_qx0  = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qx0-hw",  h_details, num_details);
	bool passed_qy0  = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qy0-hw",  h_details, num_details);
	bool passed_z0   = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "z0-hw",   h_details, num_details);

	bool passed = passed_eta0 && passed_qx0 && passed_qy0 && passed_z0;

	delete[] h_details;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_details_VERIFY_HW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = HWFV1;

	Details d_details(solver_params);

	const int num_details = get_lvl_idx(d_details.eta0.levels + 1);
	const size_t bytes = num_details * sizeof(real);
	real* h_details = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_details[i] = i;
	}

	init_details(h_details, d_details, bytes);

	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_details_VERIFY_HW";

	const real actual_error = d_details.verify(dirroot, prefix);
	const real expected_error = C(0.0);

	delete[] h_details;

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_details_CONSTRUCTOR_LEVELS_MW()
{
	SolverParams solver_params;

	solver_params.L           = 1;
	solver_params.solver_type = MWDG2;

	Details d_details(solver_params);

	bool init_eta0  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.eta0);
	bool init_qx0   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qx0);
	bool init_qy0   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qy0);
	bool init_z0    = test_subdetails_CONSTRUCTOR_LEVELS(d_details.z0);
	
	bool init_eta1x = test_subdetails_CONSTRUCTOR_LEVELS(d_details.eta1x);
	bool init_qx1x  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qx1x);
	bool init_qy1x  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qy1x);
	bool init_z1x   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.z1x);
	
	bool init_eta1y = test_subdetails_CONSTRUCTOR_LEVELS(d_details.eta1y);
	bool init_qx1y  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qx1y);
	bool init_qy1y  = test_subdetails_CONSTRUCTOR_LEVELS(d_details.qy1y);
	bool init_z1y   = test_subdetails_CONSTRUCTOR_LEVELS(d_details.z1y);

	bool subdetails_correctly_initialised =
	(
		init_eta0  && init_qx0  && init_qy0  && init_z0 &&
		init_eta1x && init_qx1x && init_qy1x && init_z1x &&
		init_eta1y && init_qx1y && init_qy1y && init_z1y
	);

	if (subdetails_correctly_initialised && d_details.solver_type == solver_params.solver_type)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_details_CONSTRUCTOR_FILES_MW()
{
	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_details_CONSTRUCTOR_FILES_MW";
	
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = MWDG2;

	Details d_details(solver_params, dirroot, prefix);

	const int num_details = get_lvl_idx(d_details.eta0.levels + 1);
	real* h_details = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_details[i] = i;
	}

	bool passed_eta0  = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.eta0,  num_details);
	bool passed_qx0   = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qx0,   num_details);
	bool passed_qy0   = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qy0,   num_details);
	bool passed_z0    = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.z0,    num_details);
	bool passed_eta1x = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.eta1x, num_details);
	bool passed_qx1x  = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qx1x,  num_details);
	bool passed_qy1x  = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qy1x,  num_details);
	bool passed_z1x   = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.z1x,   num_details);
	bool passed_eta1y = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.eta1y, num_details);
	bool passed_qx1y  = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qx1y,  num_details);
	bool passed_qy1y  = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.qy1y,  num_details);
	bool passed_z1y   = test_subdetails_CONSTRUCTOR_FILES(h_details, d_details.z1y,   num_details);

	bool passed =
	(
		passed_eta0  && passed_qx0  && passed_qy0  && passed_z0 &&
		passed_eta1x && passed_qx1x && passed_qy1x && passed_z1x &&
		passed_eta1y && passed_qx1y && passed_qy1y && passed_z1y
	);

	delete[] h_details;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_details_WRITE_TO_FILE_MW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = MWDG2;

	Details d_details(solver_params);

	const int num_details = get_lvl_idx(d_details.eta0.levels + 1);
	const size_t bytes = num_details * sizeof(real);
	real* h_details = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_details[i] = i;
	}

	init_details(h_details, d_details, bytes);

	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_details_WRITE_TO_FILE_MW";

	d_details.write_to_file(dirroot, prefix);

	bool passed_eta0  = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "eta0-mw",  h_details, num_details);
	bool passed_qx0   = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qx0-mw",   h_details, num_details);
	bool passed_qy0   = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qy0-mw",   h_details, num_details);
	bool passed_z0    = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "z0-mw",    h_details, num_details);
	bool passed_eta1x = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "eta1x-mw", h_details, num_details);
	bool passed_qx1x  = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qx1x-mw",  h_details, num_details);
	bool passed_qy1x  = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qy1x-mw",  h_details, num_details);
	bool passed_z1x   = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "z1x-mw",   h_details, num_details);
	bool passed_eta1y = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "eta1y-mw", h_details, num_details);
	bool passed_qx1y  = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qx1y-mw",  h_details, num_details);
	bool passed_qy1y  = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "qy1y-mw",  h_details, num_details);
	bool passed_z1y   = test_subdetails_WRITE_TO_FILE(dirroot, prefix, "z1y-mw",   h_details, num_details);

	bool passed =
	(
		passed_eta0  && passed_qx0  && passed_qy0  && passed_z0 &&
		passed_eta1x && passed_qx1x && passed_qy1x && passed_z1x &&
		passed_eta1y && passed_qx1y && passed_qy1y && passed_z1y
	);

	delete[] h_details;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_details_VERIFY_MW()
{
	SolverParams solver_params;

	solver_params.L           = 3;
	solver_params.solver_type = MWDG2;

	Details d_details(solver_params);

	const int num_details = get_lvl_idx(d_details.eta0.levels + 1);
	const size_t bytes = num_details * sizeof(real);
	real* h_details = new real[num_details];

	for (int i = 0; i < num_details; i++)
	{
		h_details[i] = i;
	}

	init_details(h_details, d_details, bytes);

	const char* dirroot = "unittestdata";
	const char* prefix  = "unit_test_details_VERIFY_MW";

	const real actual_error = d_details.verify(dirroot, prefix);
	const real expected_error = C(0.0);

	delete[] h_details;

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void run_unit_tests_classes()
{
	unit_test_scale_coeffs_CONSTRUCTOR_LEVELS_HW();
	unit_test_scale_coeffs_CONSTRUCTOR_FILES_HW();
	unit_test_scale_coeffs_WRITE_TO_FILE_HW();
	unit_test_scale_coeffs_VERIFY_HW();

	unit_test_scale_coeffs_CONSTRUCTOR_LEVELS_MW();
	unit_test_scale_coeffs_CONSTRUCTOR_FILES_MW();
	unit_test_scale_coeffs_WRITE_TO_FILE_MW();
	unit_test_scale_coeffs_VERIFY_MW();

	unit_test_scale_coeffs_CONSTRUCTOR_COPY();

	unit_test_subdetails_CONSTRUCTOR_DEFAULT();
	unit_test_subdetails_CONSTRUCTOR_LEVELS();
	unit_test_subdetails_CONSTRUCTOR_FILES();
	unit_test_subdetails_WRITE_TO_FILE();
	unit_test_subdetails_VERIFY();
	unit_test_subdetails_CONSTRUCTOR_COPY();

	unit_test_details_CONSTRUCTOR_LEVELS_HW();
	unit_test_details_CONSTRUCTOR_FILES_HW();
	unit_test_details_WRITE_TO_FILE_HW();
	unit_test_details_VERIFY_HW();

	unit_test_details_CONSTRUCTOR_LEVELS_MW();
	unit_test_details_CONSTRUCTOR_FILES_MW();
	unit_test_details_WRITE_TO_FILE_MW();
	unit_test_details_VERIFY_MW();
}

bool test_subdetails_CONSTRUCTOR_LEVELS(SubDetails d_subdetails)
{
	bool initialised =
	(
		d_subdetails.alpha        != nullptr &&
		d_subdetails.beta         != nullptr &&
		d_subdetails.gamma        != nullptr &&
		d_subdetails.levels        > -1
	);

	return initialised;
}

bool test_subdetails_CONSTRUCTOR_FILES
(
	real*      h_subdetails,
	SubDetails d_subdetails,
	const int& num_details
)
{
	const real error_alpha = compare_array_on_device_vs_host_real(h_subdetails, d_subdetails.alpha, num_details);
	const real error_beta  = compare_array_on_device_vs_host_real(h_subdetails, d_subdetails.beta,  num_details);
	const real error_gamma = compare_array_on_device_vs_host_real(h_subdetails, d_subdetails.gamma, num_details);
	
	const real expected_error = C(1e-6);

	bool passed =
	(
		are_reals_equal(error_alpha, expected_error) &&
		are_reals_equal(error_beta,  expected_error) &&
		are_reals_equal(error_gamma, expected_error) 
	);

	return passed;
}

bool test_subdetails_WRITE_TO_FILE
(
	const char* dirroot,
	const char* prefix,
	const char* suffix,
	real*       h_subdetails,
	const int&  num_details
)
{
	char filename_alpha[255] = {'\0'};
	char filename_beta[255]  = {'\0'};
	char filename_gamma[255] = {'\0'};

	sprintf(filename_alpha, "%s%s%s", prefix, "-details-alpha-", suffix);
	sprintf(filename_beta,  "%s%s%s", prefix, "-details-beta-",  suffix);
	sprintf(filename_gamma, "%s%s%s", prefix, "-details-gamma-", suffix);

	const real error_alpha = compare_array_with_file_real(dirroot, filename_alpha, h_subdetails, num_details);
	const real error_beta  = compare_array_with_file_real(dirroot, filename_beta,  h_subdetails, num_details);
	const real error_gamma = compare_array_with_file_real(dirroot, filename_gamma, h_subdetails, num_details);
	
	const real expected_error = C(1e-6);

	bool passed = 
	(
		are_reals_equal(error_alpha,  expected_error) &&
		are_reals_equal(error_beta,   expected_error) &&
		are_reals_equal(error_gamma,  expected_error) 
	);

	return passed;
}

void init_details
(
	real*   h_details,
	Details d_details,
	const size_t& bytes
)
{
	if (d_details.solver_type == HWFV1)
	{
		copy_cuda(d_details.eta0.alpha, h_details, bytes);
		copy_cuda(d_details.eta0.beta,  h_details, bytes);
		copy_cuda(d_details.eta0.gamma, h_details, bytes);

		copy_cuda(d_details.qx0.alpha,  h_details, bytes);
		copy_cuda(d_details.qx0.beta,   h_details, bytes);
		copy_cuda(d_details.qx0.gamma,  h_details, bytes);

		copy_cuda(d_details.qy0.alpha,  h_details, bytes);
		copy_cuda(d_details.qy0.beta,   h_details, bytes);
		copy_cuda(d_details.qy0.gamma,  h_details, bytes);

		copy_cuda(d_details.z0.alpha,   h_details, bytes);
		copy_cuda(d_details.z0.beta,    h_details, bytes);
		copy_cuda(d_details.z0.gamma,   h_details, bytes);
	}
	else if (d_details.solver_type == MWDG2)
	{
		copy_cuda(d_details.eta0.alpha, h_details, bytes);
		copy_cuda(d_details.eta0.beta,  h_details, bytes);
		copy_cuda(d_details.eta0.gamma, h_details, bytes);

		copy_cuda(d_details.qx0.alpha,  h_details, bytes);
		copy_cuda(d_details.qx0.beta,   h_details, bytes);
		copy_cuda(d_details.qx0.gamma,  h_details, bytes);

		copy_cuda(d_details.qy0.alpha,  h_details, bytes);
		copy_cuda(d_details.qy0.beta,   h_details, bytes);
		copy_cuda(d_details.qy0.gamma,  h_details, bytes);

		copy_cuda(d_details.z0.alpha,   h_details, bytes);
		copy_cuda(d_details.z0.beta,    h_details, bytes);
		copy_cuda(d_details.z0.gamma,   h_details, bytes);

		copy_cuda(d_details.eta1x.alpha, h_details, bytes);
		copy_cuda(d_details.eta1x.beta,  h_details, bytes);
		copy_cuda(d_details.eta1x.gamma, h_details, bytes);

		copy_cuda(d_details.qx1x.alpha,  h_details, bytes);
		copy_cuda(d_details.qx1x.beta,   h_details, bytes);
		copy_cuda(d_details.qx1x.gamma,  h_details, bytes);

		copy_cuda(d_details.qy1x.alpha,  h_details, bytes);
		copy_cuda(d_details.qy1x.beta,   h_details, bytes);
		copy_cuda(d_details.qy1x.gamma,  h_details, bytes);

		copy_cuda(d_details.z1x.alpha,   h_details, bytes);
		copy_cuda(d_details.z1x.beta,    h_details, bytes);
		copy_cuda(d_details.z1x.gamma,   h_details, bytes);

		copy_cuda(d_details.eta1y.alpha, h_details, bytes);
		copy_cuda(d_details.eta1y.beta,  h_details, bytes);
		copy_cuda(d_details.eta1y.gamma, h_details, bytes);

		copy_cuda(d_details.qx1y.alpha,  h_details, bytes);
		copy_cuda(d_details.qx1y.beta,   h_details, bytes);
		copy_cuda(d_details.qx1y.gamma,  h_details, bytes);

		copy_cuda(d_details.qy1y.alpha,  h_details, bytes);
		copy_cuda(d_details.qy1y.beta,   h_details, bytes);
		copy_cuda(d_details.qy1y.gamma,  h_details, bytes);

		copy_cuda(d_details.z1y.alpha,   h_details, bytes);
		copy_cuda(d_details.z1y.beta,    h_details, bytes);
		copy_cuda(d_details.z1y.gamma,   h_details, bytes);
	}
	else
	{
		fprintf(stderr, "Solver type other than HWFV1 and MWDG2 for Details in %s.\n", __FILE__);
		return;
	}
}

#endif
#pragma once

#include "../classes/ScaleCoefficients.h"
#include "../classes/Details.h"
#include "../utilities/compare_array_with_file_real.h"
#include "../utilities/compare_array_on_device_vs_host_real.cuh"

void unit_test_scale_coeffs_CONSTRUCTOR_LEVELS_HW();
void unit_test_scale_coeffs_CONSTRUCTOR_FILES_HW();
void unit_test_scale_coeffs_WRITE_TO_FILE_HW();
void unit_test_scale_coeffs_VERIFY_HW();

void unit_test_scale_coeffs_CONSTRUCTOR_LEVELS_MW();
void unit_test_scale_coeffs_CONSTRUCTOR_FILES_MW();
void unit_test_scale_coeffs_WRITE_TO_FILE_MW();
void unit_test_scale_coeffs_VERIFY_MW();

void unit_test_scale_coeffs_CONSTRUCTOR_COPY();

void unit_test_subdetails_CONSTRUCTOR_DEFAULT();
void unit_test_subdetails_CONSTRUCTOR_LEVELS();
void unit_test_subdetails_CONSTRUCTOR_FILES();
void unit_test_subdetails_WRITE_TO_FILE();
void unit_test_subdetails_VERIFY();
void unit_test_subdetails_CONSTRUCTOR_COPY();

void unit_test_details_CONSTRUCTOR_LEVELS_HW();
void unit_test_details_CONSTRUCTOR_FILES_HW();
void unit_test_details_WRITE_TO_FILE_HW();
void unit_test_details_VERIFY_HW();

void unit_test_details_CONSTRUCTOR_LEVELS_MW();
void unit_test_details_CONSTRUCTOR_FILES_MW();
void unit_test_details_WRITE_TO_FILE_MW();
void unit_test_details_VERIFY_MW();

void run_unit_tests_classes();

bool test_subdetails_CONSTRUCTOR_LEVELS(SubDetails d_subdetails);

bool test_subdetails_CONSTRUCTOR_FILES
(
	real*      h_subdetails,
	SubDetails d_subdetails,
	const int& num_details
);

bool test_subdetails_WRITE_TO_FILE
(
	const char* dirroot,
	const char* prefix,
	const char* suffix,
	real* h_subdetails,
	const int& num_details
);

void init_details
(
	real*   h_details,
	Details d_details,
	const   size_t& bytes
);

#include "unit_tests_input.cuh"

#if _RUN_UNIT_TESTS

#define TEST_MESSAGE_PASSED_ELSE_FAILED { printf("Passed %s!\n", __func__); } else { printf("Failed %s.\n", __func__); }

void unit_test_read_keyword_int_KEYWORD_NOT_FOUND()
{
	// file looks like:
	// dummy 1
	const char* filename = "unittestdata/unit_test_read_keyword_int_KEYWORD_NOT_FOUND.txt";

	const char* keyword = "keyword";

	const int expected = 0; // read_keyword_int should return 0 if keyword not found

	const int actual = read_keyword_int(filename, keyword);

	if (actual == expected)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_read_keyword_int_KEYWORD_FOUND()
{
	// file looks like:
	// keyword 1
	const char* filename = "unittestdata/unit_test_read_keyword_int_KEYWORD_FOUND.txt";

	const char* keyword = "keyword";

	const int expected = 1;

	const int actual = read_keyword_int(filename, keyword);

	if (actual == expected)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_read_keyword_str_KEYWORD_NOT_FOUND()
{
	// file looks like:
	// #DEMfile monai.dem
	const char* filename = "unittestdata/unit_test_read_keyword_str_KEYWORD_NOT_FOUND.txt";

	const char* keyword = "DEMfile";

	char value_buf[128];

	read_keyword_str(filename, keyword, value_buf);

	// read_keyword_str should set first char of value_buf to '\0' if keyword not found
	if ( value_buf[0] == '\0')
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_read_keyword_str_KEYWORD_FOUND()
{
	// file looks like:
	// DEMfile monai.dem
	const char* filename = "unittestdata/unit_test_read_keyword_str_KEYWORD_FOUND.txt";

	const char* keyword = "DEMfile";

	const char* expected = "monai.dem";

	const int num_char_expected = strlen(expected);

	char value_buf[128] = {'\0'};

	read_keyword_str(filename, keyword, value_buf);

	if ( !strncmp(expected, value_buf, num_char_expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_read_cell_size_CELL_SIZE_FOUND()
{
	// file looks like:
	// ncols        392
	// nrows        243
	// xllcorner    0
	// yllcorner    0
	// cellsize     0.014
	// NODATA_value -9999
	// DEMfile      unittestdata/unit_test_read_cell_size_CELL_SIZE_FOUND.txt
	const char* input_filename = "unittestdata/unit_test_read_cell_size_CELL_SIZE_FOUND.txt";

	const real expected = C(0.014);

	const real actual = read_cell_size(input_filename);

	if ( are_reals_equal(expected, actual) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_read_hierarchy_array_real()
{
	const char*  dirroot      = "unittestdata";
	const char*  filename     = "unit_test_read_hierarchy_array_real";
	const int    levels       = 3;
	const int    array_length = get_lvl_idx(levels + 1);
	const size_t bytes        = array_length * sizeof(real);

	real* d_hierarchy = read_hierarchy_array_real(levels, dirroot, filename);
	real* h_hierarchy = new real[array_length];

	copy_cuda(h_hierarchy, d_hierarchy, bytes);

	bool passed = false;

	real dummy = C(0.0);

	for (int i = 0; i < array_length; i++)
	{
		dummy = i;
		
		if ( are_reals_equal( dummy, h_hierarchy[i] ) )
		{
			passed = true;
		}
		else
		{
			passed = false;
			break;
		}
	}

	free_device(d_hierarchy);
	delete[]    h_hierarchy;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_read_hierarchy_array_bool()
{
	const char*  dirroot      = "unittestdata";
	const char*  filename     = "unit_test_read_hierarchy_array_bool";
	const int    levels       = 3;
	const int    array_length = get_lvl_idx(levels + 1);
	const size_t bytes        = array_length * sizeof(bool);

	bool* d_hierarchy = read_hierarchy_array_bool(levels, dirroot, filename);
	bool* h_hierarchy = new bool[array_length];

	copy_cuda(h_hierarchy, d_hierarchy, bytes);

	bool passed = true;

	bool dummy = 0;

	for (int i = 0; i < array_length; i++)
	{
		dummy = (i % 2 == 0);
		
		if ( dummy != h_hierarchy[i] )
		{
			passed = false;
			break;
		}
	}

	free_device(d_hierarchy);
	delete[]    h_hierarchy;

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void run_unit_tests_input()
{
	unit_test_read_keyword_int_KEYWORD_NOT_FOUND();
	unit_test_read_keyword_int_KEYWORD_FOUND();
	unit_test_read_keyword_str_KEYWORD_NOT_FOUND();
	unit_test_read_keyword_str_KEYWORD_FOUND();
	unit_test_read_cell_size_CELL_SIZE_FOUND();
	unit_test_read_hierarchy_array_real();
	unit_test_read_hierarchy_array_bool();
}

#endif
#pragma once

#include "../input/read_keyword_int.h"
#include "../input/read_keyword_str.h"
#include "../input/read_cell_size.h"
#include "../input/read_hierarchy_array_real.cuh"
#include "../input/read_hierarchy_array_bool.cuh"
#include "../utilities/are_reals_equal.h"

void unit_test_read_keyword_int_KEYWORD_NOT_FOUND();
void unit_test_read_keyword_int_KEYWORD_FOUND();

void unit_test_read_keyword_str_KEYWORD_NOT_FOUND();
void unit_test_read_keyword_str_KEYWORD_FOUND();

void unit_test_read_cell_size_CELL_SIZE_FOUND();

void unit_test_read_hierarchy_array_real();

void unit_test_read_hierarchy_array_bool();

void run_unit_tests_input();
#include "unit_tests_mra.cuh"

#if _RUN_UNIT_TESTS

#define TEST_MESSAGE_PASSED_ELSE_FAILED { printf("Passed %s!\n", __func__); } else { printf("Failed %s.\n", __func__); }

const real child_0 = C(1.0);
const real child_1 = C(2.0);
const real child_2 = C(3.0);
const real child_3 = C(4.0);

const ScaleChildrenHW s_HW = { child_0, child_1, child_2, child_3 };

void unit_test_encode_scale()
{
	const real expected = C(0.5) * ( H0 * ( H0 * child_0 + H1 * child_2 ) + H1 * ( H0 * child_1 + H1 * child_3 ) );

	const real actual = encode_scale(s_HW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_alpha()
{
	const real expected  = C(0.5) * ( H0 * (G0 * child_0 + G1 * child_2) + H1 * (G0 * child_1 + G1 * child_3) );

	const real actual = encode_detail_alpha(s_HW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_beta()
{
	const real expected  = C(0.5) * ( G0 * (H0 * child_0 + H1 * child_2) + G1 * (H0 * child_1 + H1 * child_3) );

	const real actual = encode_detail_beta(s_HW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_gamma()
{
	const real expected = C(0.5) * ( G0 * (G0 * child_0 + G1 * child_2) + G1 * (G0 * child_1 + G1 * child_3) );

	const real actual = encode_detail_gamma(s_HW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

const real child_0_0  = C( 1.0);
const real child_0_1x = C( 2.0);
const real child_0_1y = C( 3.0);
const real child_1_0  = C( 4.0);
const real child_1_1x = C( 5.0);
const real child_1_1y = C( 6.0);
const real child_2_0  = C( 7.0);
const real child_2_1x = C( 8.0);
const real child_2_1y = C( 9.0);
const real child_3_0  = C(10.0);
const real child_3_1x = C(11.0);
const real child_3_1y = C(12.0);

const ScaleChildrenMW s_MW =
{
	{child_0_0,  child_1_0,  child_2_0,  child_3_0},
	{child_0_1x, child_1_1x, child_2_1x, child_3_1x},
	{child_0_1y, child_1_1y, child_2_1y, child_3_1y}
};

void unit_test_encode_scale_0()
{
	const real expected = (HH0_11 * child_0_0 + HH0_12 * child_0_1x + HH0_13 * child_0_1y +
						   HH1_11 * child_2_0 + HH1_12 * child_2_1x + HH1_13 * child_2_1y +
						   HH2_11 * child_1_0 + HH2_12 * child_1_1x + HH2_13 * child_1_1y +
						   HH3_11 * child_3_0 + HH3_12 * child_3_1x + HH3_13 * child_3_1y) / C(2.0);

	const real actual = encode_scale_0(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_scale_1x()
{
	const real expected = (HH0_21 * child_0_0 + HH0_22 * child_0_1x + HH0_23 * child_0_1y +
						   HH1_21 * child_2_0 + HH1_22 * child_2_1x + HH1_23 * child_2_1y +
						   HH2_21 * child_1_0 + HH2_22 * child_1_1x + HH2_23 * child_1_1y +
						   HH3_21 * child_3_0 + HH3_22 * child_3_1x + HH3_23 * child_3_1y) / C(2.0);

	const real actual = encode_scale_1x(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_scale_1y()
{
	const real expected = (HH0_21 * child_0_0 + HH0_22 * child_0_1x + HH0_23 * child_0_1y +
						   HH1_21 * child_2_0 + HH1_22 * child_2_1x + HH1_23 * child_2_1y +
						   HH2_21 * child_1_0 + HH2_22 * child_1_1x + HH2_23 * child_1_1y +
						   HH3_21 * child_3_0 + HH3_22 * child_3_1x + HH3_23 * child_3_1y) / C(2.0);

	const real actual = encode_scale_1x(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_alpha_0()
{
	const real expected = (GA0_11 * child_0_0 + GA0_12 * child_0_1x + GA0_13 * child_0_1y +
						   GA1_11 * child_2_0 + GA1_12 * child_2_1x + GA1_13 * child_2_1y +
						   GA2_11 * child_1_0 + GA2_12 * child_1_1x + GA2_13 * child_1_1y +
						   GA3_11 * child_3_0 + GA3_12 * child_3_1x + GA3_13 * child_3_1y) / C(2.0);

	const real actual = encode_detail_alpha_0(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_beta_0()
{
	const real expected = (GB0_11 * child_0_0 + GB0_12 * child_0_1x + GB0_13 * child_0_1y +
						   GB1_11 * child_2_0 + GB1_12 * child_2_1x + GB1_13 * child_2_1y +
						   GB2_11 * child_1_0 + GB2_12 * child_1_1x + GB2_13 * child_1_1y +
						   GB3_11 * child_3_0 + GB3_12 * child_3_1x + GB3_13 * child_3_1y) / C(2.0);

	const real actual = encode_detail_beta_0(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_gamma_0()
{
	const real expected = (GC0_11 * child_0_0 + GC0_12 * child_0_1x + GC0_13 * child_0_1y +
						   GC1_11 * child_2_0 + GC1_12 * child_2_1x + GC1_13 * child_2_1y +
						   GC2_11 * child_1_0 + GC2_12 * child_1_1x + GC2_13 * child_1_1y +
						   GC3_11 * child_3_0 + GC3_12 * child_3_1x + GC3_13 * child_3_1y) / C(2.0);

	const real actual = encode_detail_gamma_0(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_alpha_1x()
{
	const real expected = (GA0_21 * child_0_0 + GA0_22 * child_0_1x + GA0_23 * child_0_1y +
						   GA1_21 * child_2_0 + GA1_22 * child_2_1x + GA1_23 * child_2_1y +
						   GA2_21 * child_1_0 + GA2_22 * child_1_1x + GA2_23 * child_1_1y +
						   GA3_21 * child_3_0 + GA3_22 * child_3_1x + GA3_23 * child_3_1y) / C(2.0);

	const real actual = encode_detail_alpha_1x(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_beta_1x()
{
	const real expected = (GB0_21 * child_0_0 + GB0_22 * child_0_1x + GB0_23 * child_0_1y +
						   GB1_21 * child_2_0 + GB1_22 * child_2_1x + GB1_23 * child_2_1y +
						   GB2_21 * child_1_0 + GB2_22 * child_1_1x + GB2_23 * child_1_1y +
						   GB3_21 * child_3_0 + GB3_22 * child_3_1x + GB3_23 * child_3_1y) / C(2.0);

	const real actual = encode_detail_beta_1x(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_gamma_1x()
{
	const real expected = (GC0_21 * child_0_0 + GC0_22 * child_0_1x + GC0_23 * child_0_1y +
						   GC1_21 * child_2_0 + GC1_22 * child_2_1x + GC1_23 * child_2_1y +
						   GC2_21 * child_1_0 + GC2_22 * child_1_1x + GC2_23 * child_1_1y +
						   GC3_21 * child_3_0 + GC3_22 * child_3_1x + GC3_23 * child_3_1y) / C(2.0);

	const real actual = encode_detail_gamma_1x(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_alpha_1y()
{
	const real expected = (GA0_31 * child_0_0 + GA0_32 * child_0_1x + GA0_33 * child_0_1y +
						   GA1_31 * child_2_0 + GA1_32 * child_2_1x + GA1_33 * child_2_1y +
						   GA2_31 * child_1_0 + GA2_32 * child_1_1x + GA2_33 * child_1_1y +
						   GA3_31 * child_3_0 + GA3_32 * child_3_1x + GA3_33 * child_3_1y) / C(2.0);

	const real actual = encode_detail_alpha_1y(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_beta_1y()
{
	const real expected = (GB0_31 * child_0_0 + GB0_32 * child_0_1x + GB0_33 * child_0_1y +
						   GB1_31 * child_2_0 + GB1_32 * child_2_1x + GB1_33 * child_2_1y +
						   GB2_31 * child_1_0 + GB2_32 * child_1_1x + GB2_33 * child_1_1y +
						   GB3_31 * child_3_0 + GB3_32 * child_3_1x + GB3_33 * child_3_1y) / C(2.0);

	const real actual = encode_detail_beta_1y(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_detail_gamma_1y()
{
	const real expected = (GC0_31 * child_0_0 + GC0_32 * child_0_1x + GC0_33 * child_0_1y +
						   GC1_31 * child_2_0 + GC1_32 * child_2_1x + GC1_33 * child_2_1y +
						   GC2_31 * child_1_0 + GC2_32 * child_1_1x + GC2_33 * child_1_1y +
						   GC3_31 * child_3_0 + GC3_32 * child_3_1x + GC3_33 * child_3_1y) / C(2.0);

	const real actual = encode_detail_gamma_1y(s_MW);

	if ( are_reals_equal(actual, expected) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_preflag_topo_HW()
{
	// monai.par file looks like:
	// monai
	// hwfv1
	// cuda
	// cumulative
	// refine_wall
	// ref_thickness 16
	// max_ref_lvl   9
	// epsilon       1e-3
	// wall_height   0.5
	// initial_tstep 1
	// fpfric        0.01
	// sim_time      0.1
	// massint       0.1
	// saveint       0.1
	// DEMfile       monai.txt <- CAREFUL
	// startfile     monai.start
	// bcifile       monai.bci
	// bdyfile       monai.bdy
	// stagefile     monai.stage

	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_preflag_topo_HW";
	const std::string par_file = "unit_tests_HW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	Maxes             maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	bool*             d_preflagged_details = read_hierarchy_array_bool(solver_params.L - 1, dirroot.c_str(), (prefix + "-input-preflagged-details").c_str());
	
	preflag_topo
	(
		d_scale_coeffs, 
		d_details,  
		d_preflagged_details,
		maxes,
		solver_params
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const int  diffs_preflagged   = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-preflagged-details").c_str(), d_preflagged_details, num_details);

	const bool passed =
	(
		error_scale      < max_error &&
		error_details    < max_error &&
		diffs_preflagged < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_flow_TIMESTEP_1_HW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_encode_flow_TIMESTEP_1_HW";
	const std::string par_file = "unit_tests_HW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	Maxes             maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details       = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details        = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	bool*             d_preflagged_details = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-preflagged-details").c_str() );
	bool              for_nghbrs           = false;
	
	encode_flow
	(
		d_scale_coeffs,
		d_details,
		d_norm_details,
		d_sig_details,
		d_preflagged_details,
		maxes,
		solver_params,
		for_nghbrs
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	const int  diffs_preflagged   = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-preflagged-details").c_str(), d_preflagged_details, num_details);

	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs &&
		diffs_preflagged   < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_flow_TIMESTEP_2_HW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_encode_flow_TIMESTEP_2_HW";
	const std::string par_file = "unit_tests_HW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	Maxes             maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details       = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details        = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	bool*             d_preflagged_details = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-preflagged-details").c_str() );
	bool              for_nghbrs           = false;
	
	encode_flow
	(
		d_scale_coeffs,
		d_details,
		d_norm_details,
		d_sig_details,
		d_preflagged_details,
		maxes,
		solver_params,
		for_nghbrs
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	const int  diffs_preflagged   = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-preflagged-details").c_str(), d_preflagged_details, num_details);

	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs &&
		diffs_preflagged   < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_decoding_TIMESTEP_1_HW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_decoding_TIMESTEP_1_HW";
	const std::string par_file = "unit_tests_HW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details  = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	
	decoding
	(
		d_sig_details,
		d_norm_details,
		d_details,
		d_scale_coeffs,
		solver_params
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	
	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_decoding_TIMESTEP_2_HW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_decoding_TIMESTEP_2_HW";
	const std::string par_file = "unit_tests_HW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details  = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	
	decoding
	(
		d_sig_details,
		d_norm_details,
		d_details,
		d_scale_coeffs,
		solver_params
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	
	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_preflag_topo_MW()
{
	// monai.par file looks like:
	// monai
	// mwdg2
	// cuda
	// cumulative
	// refine_wall
	// ref_thickness 16
	// max_ref_lvl   9
	// epsilon       1e-3
	// wall_height   0.5
	// initial_tstep 1
	// fpfric        0.01
	// sim_time      0.1
	// massint       0.1
	// saveint       0.1
	// DEMfile       monai.txt <- CAREFUL
	// startfile     monai.start
	// bcifile       monai.bci
	// bdyfile       monai.bdy
	// stagefile     monai.stage

	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_preflag_topo_MW";
	const std::string par_file = "unit_tests_MW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	Maxes             maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	bool*             d_preflagged_details = read_hierarchy_array_bool(solver_params.L - 1, dirroot.c_str(), (prefix + "-input-preflagged-details").c_str());
	
	preflag_topo
	(
		d_scale_coeffs, 
		d_details,  
		d_preflagged_details,
		maxes,
		solver_params
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const int  diffs_preflagged   = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-preflagged-details").c_str(), d_preflagged_details, num_details);

	const bool passed =
	(
		error_scale      < max_error &&
		error_details    < max_error &&
		diffs_preflagged < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_flow_TIMESTEP_1_MW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_encode_flow_TIMESTEP_1_MW";
	const std::string par_file = "unit_tests_MW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	Maxes             maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details       = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details        = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	bool*             d_preflagged_details = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-preflagged-details").c_str() );
	bool              for_nghbrs           = false;
	
	encode_flow
	(
		d_scale_coeffs,
		d_details,
		d_norm_details,
		d_sig_details,
		d_preflagged_details,
		maxes,
		solver_params,
		for_nghbrs
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	const int  diffs_preflagged   = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-preflagged-details").c_str(), d_preflagged_details, num_details);

	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs &&
		diffs_preflagged   < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_encode_flow_TIMESTEP_2_MW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_encode_flow_TIMESTEP_2_MW";
	const std::string par_file = "unit_tests_MW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	Maxes             maxes = { C(1.0), C(1.0), C(1.0), C(1.0), C(1.0) };
	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details       = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details        = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	bool*             d_preflagged_details = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-preflagged-details").c_str() );
	bool              for_nghbrs           = false;
	
	encode_flow
	(
		d_scale_coeffs,
		d_details,
		d_norm_details,
		d_sig_details,
		d_preflagged_details,
		maxes,
		solver_params,
		for_nghbrs
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	const int  diffs_preflagged   = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-preflagged-details").c_str(), d_preflagged_details, num_details);

	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs &&
		diffs_preflagged   < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_decoding_TIMESTEP_1_MW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_decoding_TIMESTEP_1_MW";
	const std::string par_file = "unit_tests_MW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details  = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	
	decoding
	(
		d_sig_details,
		d_norm_details,
		d_details,
		d_scale_coeffs,
		solver_params
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	
	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_decoding_TIMESTEP_2_MW()
{
	const std::string dirroot  = "unittestdata";
	const std::string prefix   = "unit_test_decoding_TIMESTEP_2_MW";
	const std::string par_file = "unit_tests_MW.par";

	const std::string input_filename = dirroot + "/" + par_file;

	SolverParams      solver_params(input_filename.c_str());
	ScaleCoefficients d_scale_coeffs(solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	Details           d_details     (solver_params, dirroot.c_str(), (prefix + "-input").c_str());
	real*             d_norm_details = read_hierarchy_array_real( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-norm-details").c_str() );
	bool*             d_sig_details  = read_hierarchy_array_bool( solver_params.L - 1, dirroot.c_str(), (prefix + "-input-sig-details").c_str() );
	
	decoding
	(
		d_sig_details,
		d_norm_details,
		d_details,
		d_scale_coeffs,
		solver_params
	);

	const real max_error = C(2e-5);
	const int  max_diffs = 5;
	
	const real error_scale        = d_scale_coeffs.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const real error_details      = d_details.verify(dirroot.c_str(), (prefix + "-output").c_str());
	const int  num_details        = get_lvl_idx(solver_params.L);
	const real error_norm_details = compare_d_array_with_file_real(dirroot.c_str(), (prefix + "-output-norm-details").c_str(), d_norm_details, num_details);
	const int  diffs_sig          = compare_d_array_with_file_bool(dirroot.c_str(), (prefix + "-output-sig-details").c_str(), d_sig_details, num_details);
	
	const bool passed =
	(
		error_scale        < max_error &&
		error_details      < max_error &&
		error_norm_details < max_error &&
		diffs_sig          < max_diffs
	);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void run_unit_tests_mra()
{
	unit_test_encode_scale();
	unit_test_encode_scale_0();
	unit_test_encode_scale_1x();
	unit_test_encode_scale_1y();
	
	unit_test_encode_detail_alpha();
	unit_test_encode_detail_beta();
	unit_test_encode_detail_gamma();
	unit_test_encode_detail_alpha_0();
	unit_test_encode_detail_beta_0();
	unit_test_encode_detail_gamma_0();
	unit_test_encode_detail_alpha_1x();
	unit_test_encode_detail_beta_1x();
	unit_test_encode_detail_gamma_1x();
	unit_test_encode_detail_alpha_1y();
	unit_test_encode_detail_beta_1y();
	unit_test_encode_detail_gamma_1y();

	unit_test_preflag_topo_HW();
	unit_test_encode_flow_TIMESTEP_1_HW();
	unit_test_encode_flow_TIMESTEP_2_HW();
	unit_test_decoding_TIMESTEP_1_HW();
	unit_test_decoding_TIMESTEP_2_HW();

	unit_test_preflag_topo_MW();
	unit_test_encode_flow_TIMESTEP_1_MW();
	unit_test_encode_flow_TIMESTEP_2_MW();
	unit_test_decoding_TIMESTEP_1_MW();
	unit_test_decoding_TIMESTEP_2_MW();
}

#endif
#pragma once

#include <cmath>
#include <cstdio>
#include <string>

#include "../types/real.h"
#include "../mra/preflag_topo.cuh"
#include "../mra/encode_flow.cuh"
#include "../mra/decoding.cuh"
#include "../utilities/are_reals_equal.h"
#include "../utilities/compare_d_array_with_file_bool.cuh"
#include "../utilities/compare_d_array_with_file_real.cuh"
#include "../input/read_hierarchy_array_bool.cuh"
#include "../output/write_hierarchy_array_bool.cuh"

void unit_test_encode_scale();
void unit_test_encode_scale_0();
void unit_test_encode_scale_1x();
void unit_test_encode_scale_1y();

void unit_test_encode_detail_alpha();
void unit_test_encode_detail_beta();
void unit_test_encode_detail_gamma();
void unit_test_encode_detail_alpha_0();
void unit_test_encode_detail_beta_0();
void unit_test_encode_detail_gamma_0();
void unit_test_encode_detail_alpha_1x();
void unit_test_encode_detail_beta_1x();
void unit_test_encode_detail_gamma_1x();
void unit_test_encode_detail_alpha_1y();
void unit_test_encode_detail_beta_1y();
void unit_test_encode_detail_gamma_1y();

void unit_test_preflag_topo_HW();
void unit_test_encode_flow_TIMESTEP_1_HW();
void unit_test_encode_flow_TIMESTEP_2_HW();
void unit_test_decoding_TIMESTEP_1_HW();
void unit_test_decoding_TIMESTEP_2_HW();

void unit_test_preflag_topo_MW();
void unit_test_encode_flow_TIMESTEP_1_MW();
void unit_test_encode_flow_TIMESTEP_2_MW();
void unit_test_decoding_TIMESTEP_1_MW();
void unit_test_decoding_TIMESTEP_2_MW();

void run_unit_tests_mra();
#include "unit_tests_output.cuh"

#if _RUN_UNIT_TESTS

#define TEST_MESSAGE_PASSED_ELSE_FAILED { printf("Passed %s!\n", __func__); } else { printf("Failed %s.\n", __func__); }

void unit_test_write_hierarchy_array_real()
{
	const int    levels       = 3;
	const int    array_length = get_lvl_idx(levels + 1);
	      size_t bytes        = array_length * sizeof(real);
	      real*  h_hierarchy  = new real[array_length];
	      real*  d_hierarchy  = (real*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_hierarchy[i] = i;
	}

	copy_cuda(d_hierarchy, h_hierarchy, bytes);

	const char* dirroot  = "unittestdata";
	const char* filename = "unit_test_write_hierarchy_array_real";

	write_hierarchy_array_real(dirroot, filename, d_hierarchy, levels);

	const real actual_error   = compare_array_with_file_real(dirroot, filename, h_hierarchy, array_length);
	const real expected_error = C(1e-6);

	delete[]    h_hierarchy;
	free_device(d_hierarchy);

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_write_hierarchy_array_bool()
{
	const int    levels       = 3;
	const int    array_length = get_lvl_idx(levels + 1);
	      size_t bytes        = array_length * sizeof(real);
	      bool*  h_hierarchy  = new bool[array_length];
	      bool*  d_hierarchy  = (bool*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_hierarchy[i] = (i % 2 == 0);
	}

	copy_cuda(d_hierarchy, h_hierarchy, bytes);

	const char* dirroot  = "unittestdata";
	const char* filename = "unit_test_write_hierarchy_array_bool";

	write_hierarchy_array_bool(dirroot, filename, d_hierarchy, levels);

	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", dirroot, '/', filename, ".txt");

	FILE* fp = fopen(fullpath, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s, failed %s\n.", fullpath, __func__);
		return;
	}

	bool passed = true;

	int host_value = 0;
	int file_value = 0;

	for (int i = 0; i < array_length; i++)
	{
		host_value = h_hierarchy[i];
		
		fscanf(fp, "%d", &file_value);

		if (host_value != file_value)
		{
			passed = false;
			break;
		}
	}

	fclose(fp);

	delete[]    h_hierarchy;
	free_device(d_hierarchy);

	if (passed)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void run_unit_tests_output()
{
	unit_test_write_hierarchy_array_real();
	unit_test_write_hierarchy_array_bool();
}

#endif
#pragma once

#include "../output/write_hierarchy_array_real.cuh"
#include "../output/write_hierarchy_array_bool.cuh"
#include "../utilities/compare_array_with_file_real.h"

void unit_test_write_hierarchy_array_real();

void unit_test_write_hierarchy_array_bool();

void run_unit_tests_output();
#include "unit_tests_utilities.cuh"

#if _RUN_UNIT_TESTS

#define TEST_MESSAGE_PASSED_ELSE_FAILED { printf("Passed %s!\n", __func__); } else { printf("Failed %s.\n", __func__); }

void unit_test_get_max_from_array()
{
	const int array_length = 100000;
	const size_t bytes = array_length * sizeof(real);
	real* h_array = new real[array_length];
	real* d_array = (real*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_array[i] = i+1;
	}

	copy_cuda(d_array, h_array, bytes);

	const real expected = array_length;
	const real actual   = get_max_from_array(d_array, array_length);

	delete[] h_array;
	free_device(d_array);

	if ( are_reals_equal( actual, expected, C(1e-2) ) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_get_mean_from_array()
{
	const int array_length = 100000;
	const size_t bytes = array_length * sizeof(real);
	real* h_array = new real[array_length];
	real* d_array = (real*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_array[i] = i+1;
	}

	copy_cuda(d_array, h_array, bytes);

	// sum S of 1 to n is S = n * (n+1) / 2
	// therefore, the mean M = S / n = (n+1)/2
	const real expected = (array_length + 1) / C(2.0);
	const real actual   = get_mean_from_array(d_array, array_length);

	delete[] h_array;
	free_device(d_array);

	if ( are_reals_equal( actual, expected, C(1e-2) ) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_compute_error()
{
	const int array_length = 100000;
	const size_t bytes = array_length * sizeof(real);
	real* h_computed = new real[array_length];
	real* h_verified = new real[array_length];
	real* d_computed = (real*)malloc_device(bytes);
	real* d_verified = (real*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_computed[i] =  i + 1;      // array is y = x
		h_verified[i] = (i + 1) * 2; // array is y = 2x
	}

	copy_cuda(d_computed, h_computed, bytes);
	copy_cuda(d_verified, h_verified, bytes);

	// array of errors = abs(d_computed - d_verified), which looks like abs(x - 2x) = x
	// i.e. the integers from 1 to 100000
	// sum S of integers 1 to n is S = n * (n+1) / 2
	// therefore, the mean M = S / n = (n+1)/2
	const real expected_error = array_length;
	const real actual_error   = compute_error(d_computed, d_verified, array_length);

	delete[] h_computed;
	delete[] h_verified;
	free_device(d_computed);
	free_device(d_verified);

	if ( are_reals_equal( actual_error, expected_error, C(1e-2) ) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_compare_array_on_device_vs_host_real()
{
	const int array_length = 100;
	const size_t bytes = array_length * sizeof(real);
	real* h_array = new real[array_length];
	real* d_array = (real*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_array[i] = i;
	}

	copy_cuda(d_array, h_array, bytes);

	const real actual_error   = compare_array_on_device_vs_host_real(h_array, d_array, array_length);
	const real expected_error = C(1e-6);

	delete[] h_array;
	free_device(d_array);

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_compare_array_with_file_bool()
{
	const int array_length = 100;
	bool* h_array = new bool[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_array[i] = i % 2 == 0;
	}

	const char* dirroot  = "unittestdata";
	const char* filename = "unit_test_compare_array_with_file_bool";

	const int differences = compare_array_with_file_bool(dirroot, filename, h_array, array_length);

	delete[] h_array;

	if (differences == 0)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_compare_array_with_file_real()
{
	const int array_length = 100;
	real* h_array = new real[array_length];

	for (int i = 0; i < array_length; i++)
	{
		h_array[i] = i;
	}

	const char* dirroot  = "unittestdata";
	const char* filename = "unit_test_compare_array_with_file_real";

	const real actual_error   = compare_array_with_file_real(dirroot, filename, h_array, array_length);
	const real expected_error = C(1e-6);

	delete[] h_array;

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_compare_d_array_with_file_bool()
{
	const int array_length = 100;
	const size_t bytes = array_length * sizeof(bool);
	bool* h_array = new bool[array_length];
	bool* d_array = (bool*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_array[i] = i % 2 == 0;
	}
	
	const char* dirroot  = "unittestdata";
	const char* filename = "unit_test_compare_d_array_with_file_bool";

	copy_cuda(d_array, h_array, bytes);

	const int differences = compare_d_array_with_file_bool(dirroot, filename, d_array, array_length);

	delete[] h_array;
	free_device(d_array);

	if (differences == 0)
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void unit_test_compare_d_array_with_file_real()
{
	const int array_length = 100;
	const size_t bytes = array_length * sizeof(real);
	real* h_array = new real[array_length];
	real* d_array = (real*)malloc_device(bytes);

	for (int i = 0; i < array_length; i++)
	{
		h_array[i] = i;
	}
	
	const char* dirroot  = "unittestdata";
	const char* filename = "unit_test_compare_d_array_with_file_real";

	copy_cuda(d_array, h_array, bytes);

	const real actual_error   = compare_d_array_with_file_real(dirroot, filename, d_array, array_length);
	const real expected_error = C(1e-6);

	delete[] h_array;
	free_device(d_array);

	if ( are_reals_equal(actual_error, expected_error) )
		TEST_MESSAGE_PASSED_ELSE_FAILED
}

void run_unit_tests_utilities()
{
	unit_test_get_max_from_array();
	unit_test_get_mean_from_array();
	unit_test_compute_error();
	unit_test_compare_array_on_device_vs_host_real();
	unit_test_compare_array_with_file_bool();
	unit_test_compare_array_with_file_real();
	unit_test_compare_d_array_with_file_bool();
	unit_test_compare_d_array_with_file_real();
}

#endif
#pragma once

#include "../utilities/are_reals_equal.h"
#include "../utilities/get_max_from_array.cuh"
#include "../utilities/get_mean_from_array.cuh"
#include "../utilities/compute_error.cuh"
#include "../utilities/compare_array_on_device_vs_host_real.cuh"
#include "../utilities/compare_array_with_file_bool.h"
#include "../utilities/compare_array_with_file_real.h"
#include "../utilities/compare_d_array_with_file_bool.cuh"
#include "../utilities/compare_d_array_with_file_real.cuh"

void unit_test_get_max_from_array();
void unit_test_get_mean_from_array();
void unit_test_compute_error();
void unit_test_compare_array_on_device_vs_host_real();
void unit_test_compare_array_with_file_bool();
void unit_test_compare_array_with_file_real();
void unit_test_compare_d_array_with_file_bool();
void unit_test_compare_d_array_with_file_real();
void run_unit_tests_utilities();
#include "are_reals_equal.h"

bool are_reals_equal
(
	const real& a,
	const real& b,
	const real& epsilon
)
{
	return fabs(a - b) <= epsilon;
}
#pragma once

#include <cmath>

#include "../types/real.h"

bool are_reals_equal
(
	const real& a,
	const real& b,
	const real& epsilon = C(1e-6)
);
#pragma once

#ifndef THREADS_PER_BLOCK
    // MUST BE EITHER 64, 256 OR 1024
    #define THREADS_PER_BLOCK 256 

    #if   THREADS_PER_BLOCK == 64
        #define SHARED_MEMORY_BLOCK_DIM 8
        #define LVL_SINGLE_BLOCK 3

    #elif THREADS_PER_BLOCK == 256
        #define SHARED_MEMORY_BLOCK_DIM 16
        #define LVL_SINGLE_BLOCK 4

    #elif THREADS_PER_BLOCK == 1024
        #define SHARED_MEMORY_BLOCK_DIM 32
        #define LVL_SINGLE_BLOCK 5

    #endif
#endif

#ifndef SIGNIFICANT
    #define SIGNIFICANT true
#endif

#ifndef INSIGNIFICANT
    #define INSIGNIFICANT false
#endif
#pragma once

#include "cuda_runtime.h"

#include <cstdio>  // for fprintf
#include <cstdlib> // for exit(error)

// macro to check for CUDA errors
#define CHECK_CUDA_ERROR(ans) { CUDAAssert( (ans), __FILE__, __LINE__); }

inline void CUDAAssert(cudaError_t error, const char* file, int line, bool abort = true)
{
	if (error != cudaSuccess)
	{
		fprintf(stderr, "CUDA error: %s, %s, %d\n", cudaGetErrorString(error), file, line);

		if (abort) exit(error);
	}
}
target_sources(
	    gpu-mwdg2
		PRIVATE
		cuda_utils.cu
		get_max_from_array
		get_mean_from_array
		get_num_blocks.cpp
		are_reals_equal.cpp
		compare_array_on_device_vs_host_real.cu
		compare_array_with_file_bool.cpp
		compare_array_with_file_real.cpp
		compare_d_array_with_file_bool.cu
		compare_d_array_with_file_real.cu
		compute_error.cu
        compute_error_kernel.cu
	)
#include "compare_array_on_device_vs_host_real.cuh"

real compare_array_on_device_vs_host_real
(
	real*      h_array,
	real*      d_array,
	const int& array_length
)
{
	const size_t bytes = array_length * sizeof(real);
	real* h_array_copied = new real[array_length];

	copy_cuda(h_array_copied, d_array, bytes);

	real error      = C(0.0);
	real max_error  = C(0.0);
	real host_value = C(0.0);
	real file_value = C(0.0);

	for (int i = 0; i < array_length; i++)
	{
		host_value = h_array[i];

		file_value = h_array_copied[i];

		error = std::abs(host_value - file_value);

		max_error = std::max(max_error, error);
	}

	delete[] h_array_copied;

	return max_error;
}
#pragma once

#include <algorithm>

#include "are_reals_equal.h"
#include "cuda_utils.cuh"

real compare_array_on_device_vs_host_real
(
	real*      h_array,
	real*      d_array,
	const int& array_length
);
#include "compare_array_with_file_bool.h"

int compare_array_with_file_bool
(
	const char* dirroot,
	const char* filename,
	bool*       h_array,
	const int&  array_length
)
{
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", dirroot, '/', filename, ".txt");

	FILE* fp = fopen(fullpath, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s\n.", fullpath);
		return false;
	}

	int differences = 0;
	int host_value  = 0;
	int file_value  = 0;

	for (int i = 0; i < array_length; i++)
	{
		host_value = h_array[i];
		
		fscanf(fp, "%d", &file_value);

		differences += (host_value - file_value) != 0;
	}

	fclose(fp);

	return differences;
}
#pragma once

#include <cstdio>

int compare_array_with_file_bool
(
	const char* dirroot,
	const char* filename,
	bool*       h_array,
	const int&  array_length
);
#include "compare_array_with_file_real.h"

real compare_array_with_file_real
(
	const char* dirroot,
	const char* filename,
	real*       h_array,
	const int&  array_length
)
{
	char fullpath[255] = {'\0'};

	sprintf(fullpath, "%s%c%s%s", dirroot, '/', filename, ".txt");

	FILE* fp = fopen(fullpath, "r");

	if (NULL == fp)
	{
		fprintf(stderr, "Error opening file %s\n.", fullpath);
		return C(999.0);
	}

	real error      = C(0.0);
	real max_error  = C(0.0);
	real host_value = C(0.0);
	real file_value = C(0.0);

	for (int i = 0; i < array_length; i++)
	{
		host_value = h_array[i];
		
		fscanf(fp, "%f", &file_value);

		error = std::abs(host_value - file_value);

		max_error = std::max(max_error, error);
	}

	fclose(fp);

	return max_error;
}
#pragma once

#include <cstdio>
#include <algorithm>

#include "are_reals_equal.h"

real compare_array_with_file_real
(
	const char* dirroot,
	const char* filename,
	real*       h_array,
	const int&  array_length
);
#include "compare_d_array_with_file_bool.cuh"

int compare_d_array_with_file_bool
(
	const char* dirroot,
	const char* filename,
	bool*       d_array,
	const int&  array_length
)
{
	bool* h_array = new bool[array_length];
	const size_t bytes = array_length * sizeof(bool);
	
	copy_cuda(h_array, d_array, bytes);

	int differences = compare_array_with_file_bool(dirroot, filename, h_array, array_length);

	delete[] h_array;

	return differences;
}
#pragma once

#include <cstdio>

#include "cuda_utils.cuh"
#include "compare_array_with_file_bool.h"

int compare_d_array_with_file_bool
(
	const char* dirroot,
	const char* filename,
	bool*       d_array,
	const int&  array_length
);
#include "compare_d_array_with_file_real.cuh"

real compare_d_array_with_file_real
(
	const char* dirroot,
	const char* filename,
	real*       d_array,
	const int&  array_length
)
{
	real* h_array = new real[array_length];
	const size_t bytes = array_length * sizeof(real);
	
	copy_cuda(h_array, d_array, bytes);

	real error = compare_array_with_file_real(dirroot, filename, h_array, array_length);

	delete[] h_array;

	return error;
}
#pragma once

#include <cstdio>

#include "cuda_utils.cuh"
#include "compare_array_with_file_real.h"

real compare_d_array_with_file_real
(
	const char* dirroot,
	const char* filename,
	real*       d_array,
	const int&  array_length
);
#include "compute_error.cuh"

real compute_error
(
	real*       d_computed,
	real*       d_verified,
	const int&  array_length
)
{
	const size_t bytes = array_length * sizeof(real);

	real* d_errors = (real*)malloc_device(bytes);
	
	const int num_blocks = get_num_blocks(array_length, THREADS_PER_BLOCK);

	compute_error_kernel<<<num_blocks, THREADS_PER_BLOCK>>>
	(
		d_computed,
		d_verified,
		d_errors,
		array_length
	);

	real max_error = get_max_from_array(d_errors, array_length);

	free_device(d_errors);

	return max_error;
}
#pragma once

#include "../utilities/cuda_utils.cuh"
#include "../utilities/get_num_blocks.h"
#include "../utilities/compute_error_kernel.cuh"
#include "../utilities/get_max_from_array.cuh"
#include "../utilities/get_mean_from_array.cuh"

real compute_error
(
	real*       d_computed,
	real*       d_verified,
	const int&  array_length
);
#include "compute_error_kernel.cuh"

__global__
void compute_error_kernel
(
	real* d_computed,
	real* d_verified,
	real* d_errors,
	int   array_length
)
{
	const int idx = blockIdx.x * blockDim.x + threadIdx.x;

	if (idx < array_length)
	{
		d_errors[idx] = abs( d_verified[idx] - d_computed[idx] );
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../types/real.h"

#include "../utilities/BLOCK_VAR_MACROS.cuh"

__global__
void compute_error_kernel
(
	real* d_computed,
	real* d_verified,
	real* d_errors,
	int   array_length
);
#include "../utilities/cuda_utils.cuh"

__host__
cudaError_t sync()
{
	return cudaDeviceSynchronize();
}

__host__
cudaError_t peek()
{
	return cudaPeekAtLastError();
}

__host__
cudaError_t reset()
{
	return cudaDeviceReset();
}

__host__
cudaError_t copy_cuda
(
	void*  dst,
	void*  src,
	size_t bytes
)
{
	cudaError_t error = cudaMemcpy
	(
		dst,
		src,
		bytes,
		cudaMemcpyDefault
	);

	return error;
}

__host__
cudaError_t copy_cuda_async
(
	void*  dst,
	void*  src,
	size_t bytes
)
{
	cudaError_t error = cudaMemcpyAsync
	(
		dst,
		src,
		bytes,
		cudaMemcpyDefault
	);

	return error;
}

__host__
void* malloc_device
(
	size_t bytes
)
{
	void* ptr;
	
	cudaMalloc
	(
		&ptr,
		bytes
	);

	return ptr;
}

__host__
void* malloc_pinned
(
	size_t bytes
)
{
	void* ptr;

	cudaMallocHost
	(
		&ptr,
		bytes
	);

	return ptr;
}

__host__
cudaError_t free_device
(
	void* ptr
)
{
	return (nullptr != ptr) ? cudaFree(ptr) : cudaSuccess;
}

__host__
cudaError_t free_pinned
(
	void* ptr
)
{
	return (nullptr != ptr) ? cudaFreeHost(ptr) : cudaSuccess;
}
#pragma once

#include "cuda_runtime.h"

#include "../utilities/CHECK_CUDA_ERROR.cuh"

#include "cstdio"

__host__
cudaError_t sync();

__host__
cudaError_t peek();

__host__
cudaError_t reset();

__host__
cudaError_t copy_cuda
(
	void* dst,
	void* src,
	size_t bytes
);

__host__
cudaError_t copy_cuda_async
(
	void* dst,
	void* src,
	size_t bytes
);

__host__
void* malloc_device
(
	size_t bytes
);

__host__
cudaError_t free_device
(
	void* ptr
);

__host__
void* malloc_pinned
(
	size_t bytes
);

__host__
cudaError_t free_pinned
(
	void* ptr
);
#pragma once

#include "../types/HierarchyIndex.h"

// gets the starting index of a grid at refinement level n within an array 
// containing grids at refinement level n to L, mapped to 1D using Morton codes,
// explained in comment: please grep 'ARRAY OF HIERARCHY OF GRIDS'
__host__ __device__ __forceinline__
HierarchyIndex get_lvl_idx(int level)
{
    /*
     * Prior explanation is in a comment: please grep 'ARRAY OF HIERARCHY OF GRIDS'.
     * The starting index in the array of grids can be found as follows.
     * A grid at refinement level n starts when the grid at refinement level n - 1 ends.
     * Up to the grid at n there are (4^(n+1) - 1) / 3 elements in the array.
     * Hence, up to a grid at n - 1 there are (4^n - 1) / 3 elements, which is the starting index.
     */

    // 1 << n = 2^n therefore 1 << (2 * n) = 2^(2*n) = 4^n
    return ( ( 1 << (2 * level) ) - 1 ) / 3;
}
#include "get_max_from_array.cuh"

__host__
real get_max_from_array
(
	real*      d_array,
	const int& array_length
)
{
	
	real* h_max_out = new real;
	real* d_max_out = (real*)malloc_device( sizeof(real) );
	
	// custom functor for maximum of absolute value
	AbsMax abs_max;

	// --------------------//

	// Allocating memory to find maxes //

	void* d_temp_storage  = NULL;
	size_t  temp_storage  = 0;

	CHECK_CUDA_ERROR( cub::DeviceReduce::Reduce
	(
		d_temp_storage,
		temp_storage,
		d_array,
		d_max_out,
		array_length,
		abs_max,
		C(0.0)
	) );

	d_temp_storage = malloc_device(temp_storage);

	// ------------------------------- //

	CHECK_CUDA_ERROR( cub::DeviceReduce::Reduce
	(
		d_temp_storage,
		temp_storage,
		d_array,
		d_max_out,
		array_length,
		abs_max,
		C(0.0)
	) );

	copy_cuda
	(
		h_max_out,
		d_max_out,
		sizeof(real)
	);

	real max_from_array = *h_max_out;

	free_device(d_temp_storage);
	free_device(d_max_out);
	delete      h_max_out;

	return max_from_array;
}
#pragma once

#include "cub/device/device_reduce.cuh"

#include <cmath>

#include "../utilities/cuda_utils.cuh"

#include "../types/real.h"

struct AbsMax
{
	template <typename T>
	__device__ __forceinline__
	T operator()(const T& a, const T& b) const { return ( abs(a) > abs(b) ) ? abs(a) : abs(b); }
};

__host__
real get_max_from_array
(
	real*      d_array,
	const int& array_length
);
#include "get_mean_from_array.cuh"

__host__
real get_mean_from_array
(
	real*      d_array,
	const int& array_length
)
{
	
	real* h_sum_out = new real;
	real* d_sum_out = (real*)malloc_device( sizeof(real) );
	
	// Allocating memory to find maxes //

	void* d_temp_storage  = NULL;
	size_t  temp_storage  = 0;

	CHECK_CUDA_ERROR( cub::DeviceReduce::Sum
	(
		d_temp_storage,
		temp_storage,
		d_array,
		d_sum_out,
		array_length
	) );

	d_temp_storage = malloc_device(temp_storage);

	// ------------------------------- //

	CHECK_CUDA_ERROR( cub::DeviceReduce::Sum
	(
		d_temp_storage,
		temp_storage,
		d_array,
		d_sum_out,
		array_length
	) );

	copy_cuda
	(
		h_sum_out,
		d_sum_out,
		sizeof(real)
	);

	real mean_from_array = *h_sum_out / array_length;

	free_device(d_temp_storage);
	free_device(d_sum_out);
	delete      h_sum_out;

	return mean_from_array;
}
#pragma once

#include "cub/device/device_reduce.cuh"

#include <cmath>

#include "../utilities/cuda_utils.cuh"

#include "../types/real.h"

__host__
real get_mean_from_array
(
	real*      d_array,
	const int& array_length
);
#include "../utilities/get_num_blocks.h"

int get_num_blocks
(
	int num_threads, 
	int threads_per_block
)
{
	return num_threads / threads_per_block + (num_threads % threads_per_block != 0);
}
#pragma once

// fast ceiling of integer division
// taken from: https://stackoverflow.com/questions/2745074/fast-ceiling-of-an-integer-division-in-c-c/2745086
int get_num_blocks
(
	int num_threads, 
	int threads_per_block
);
target_sources(
	    gpu-mwdg2
		PRIVATE
		copy_finest_coefficients.cu
		generate_all_morton_codes.cu
		get_sorting_indices.cu
		rev_z_order_act_idcs.cu
		rev_z_order_assem_sol.cu
		rev_z_order_reals.cu
		sort_finest_scale_coeffs_z_order.cu
		sort_neighbours_z_order.cu
	)
#pragma once

#include "cuda_runtime.h"

#include "../types/Coordinate.h"
#include "../types/MortonCode.h"

// remove the even bits and squash together the odd bits of a Morton code
__host__ __device__ __forceinline__
Coordinate compact(MortonCode code)
{
	                                                            //               In binary:
	Coordinate coord = code & 0x55555555;         // -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0

	coord = (coord ^ (coord >> 1)) & 0x33333333; // --fe --dc --ba --98 --76 --54 --32 --10
	coord = (coord ^ (coord >> 2)) & 0x0f0f0f0f; // ---- fedc ---- ba98 ---- 7654 ---- 3210
	coord = (coord ^ (coord >> 4)) & 0x00ff00ff; // ---- ---- fedc ba98 ---- ---- 7654 3210
	coord = (coord ^ (coord >> 8)) & 0x0000ffff; // ---- ---- ---- ---- fedc ba98 7654 3210
	
	return coord;
}
#include "copy_finest_coefficients.cuh"

__global__
void copy_finest_coefficients
(
	AssembledSolution d_assem_sol,
	ScaleCoefficients d_scale_coeffs,
	SolverParams  solver_params,
	HierarchyIndex    finest_lvl_idx
)
{
	HierarchyIndex idx = blockDim.x * blockIdx.x + threadIdx.x;

	if ( idx >= d_assem_sol.length ) return;

	HierarchyIndex h_idx = finest_lvl_idx + idx;

	d_scale_coeffs.eta0[h_idx] = d_assem_sol.h0[idx] + d_assem_sol.z0[idx];
	d_scale_coeffs.qx0[h_idx]  = d_assem_sol.qx0[idx];
	d_scale_coeffs.qy0[h_idx]  = d_assem_sol.qy0[idx];
	d_scale_coeffs.z0[h_idx]   = d_assem_sol.z0[idx];

	if (solver_params.solver_type == MWDG2)
	{
		d_scale_coeffs.eta1x[h_idx] = d_assem_sol.h1x[idx] + d_assem_sol.z1x[idx];
		d_scale_coeffs.qx1x[h_idx]  = d_assem_sol.qx1x[idx];
		d_scale_coeffs.qy1x[h_idx]  = d_assem_sol.qy1x[idx];
		d_scale_coeffs.z1x[h_idx]   = d_assem_sol.z1x[idx];

		d_scale_coeffs.eta1y[h_idx] = d_assem_sol.h1y[idx] + d_assem_sol.z1y[idx];
		d_scale_coeffs.qx1y[h_idx]  = d_assem_sol.qx1y[idx];
		d_scale_coeffs.qy1y[h_idx]  = d_assem_sol.qy1y[idx];
		d_scale_coeffs.z1y[h_idx]   = d_assem_sol.z1y[idx];
	}
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../classes/AssembledSolution.h"
#include "../classes/ScaleCoefficients.h"
#include "../classes/SolverParams.h"

__global__
void copy_finest_coefficients
(
	AssembledSolution d_assem_sol,
	ScaleCoefficients d_scale_coeffs,
	SolverParams  solver_params,
	HierarchyIndex    finest_lvl_idx
);
#pragma once

#include "cuda_runtime.h"

#include "../types/MortonCode.h"
#include "../types/Coordinate.h"

/*
 * BITWISE OPERATORS AND HEXADECIMAL
 *
 * This function uses hexadecimal numbers, which in C++ start with '0x', and bitwise operators.
 * Hexadecimal numbers go from (in binary) 1 = 0000 to f = 1111.
 * For example, 0x0000ffff = 00000000000000001111111111111111 (16 0's, 16 1's).
 * Bitwise operators in C++ are as follows:
 *
 *          OR : |
 *         AND : &
 *         XOR : ^
 *  LEFT SHIFT : <<
 * RIGHT SHIFT : >>
 */

 // inserts a 0 between each bit
 // this blog post is very helpful: http://asgerhoedt.dk/?p=276
__host__ __device__ __forceinline__
MortonCode dilate(Coordinate coord)
{

	// first, truncate to 16 bits so that later,
	// when generating Morton codes from 2 coordinates,
	// this ensures each code is 16 + 16 = 32 bits long

	coord &= 0x0000ffff;                         // in binary: ---- ---- ---- ---- fedc ba98 7654 3210

	coord = (coord ^ (coord << 8)) & 0x00ff00ff; // in binary: ---- ---- fedc ba98 ---- ---- 7654 3210
	coord = (coord ^ (coord << 4)) & 0x0f0f0f0f; // in binary: ---- fedc ---- ba98 ---- 7654 ---- 3210
	coord = (coord ^ (coord << 2)) & 0x33333333; // in binary: --fe --dc --ba --98 --76 --54 --32 --10
	coord = (coord ^ (coord << 1)) & 0x55555555; // in binary: -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0

	return coord;
}
#include "generate_all_morton_codes.cuh"

__global__
void generate_all_morton_codes
(
	MortonCode* d_morton_codes,
	int*        d_indices, 
	int         mesh_dim
)
{
	HierarchyIndex idx = blockDim.x * blockIdx.x + threadIdx.x;

	if ( idx >= (mesh_dim * mesh_dim) ) return;

	Coordinate x = idx % mesh_dim;
	Coordinate y = idx / mesh_dim;

	d_indices[idx] = idx;

	d_morton_codes[idx] = generate_morton_code(x, y);
}
#pragma once

#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include "../types/MortonCode.h"
#include "../types/HierarchyIndex.h"

#include "../zorder/generate_morton_code.cuh"

__global__
void generate_all_morton_codes
(
	MortonCode* d_morton_codes,
	int*        d_indices,
	int         mesh_dim
);
#pragma once

#include "cuda_runtime.h"

#include "dilate.cuh"

__host__ __device__ __forceinline__
MortonCode generate_morton_code
(
	Coordinate x,
	Coordinate y
)
{
	// please grep 'BITWISE OPERATORS AND HEXADECIMAL' for explanation
	return dilate(x) | (dilate(y) << 1);
}
#pragma once

#include "../zorder/compact.cuh"

__host__ __device__ __forceinline__
Coordinate get_i_index(MortonCode code)
{
	return compact(code);
}
#pragma once

#include "../zorder/compact.cuh"

__host__ __device__ __forceinline__
Coordinate get_j_index(MortonCode code)
{
	return compact(code >> 1);
}
#include "get_sorting_indices.cuh"

__host__
void get_sorting_indices
(
	MortonCode*        d_morton_codes,
	MortonCode*        d_sorted_morton_codes,
	AssembledSolution& d_assem_sol,
	AssembledSolution& d_buf_assem_sol,
	MortonCode*        d_indices,
	MortonCode*        d_rev_z_order,
	MortonCode*        d_rev_row_major,
	SolverParams&      solver_params
)
{
	// ---------------------------------------------- //
	// Getting array with which to reverse z-ordering //
	// ---------------------------------------------- //

	void*  d_temp_storage = NULL;
	size_t temp_storage   = 0;

	// this launch only decides how much temp_storage is needed for allocation to d_temp_storage
	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_morton_codes,
		d_sorted_morton_codes, 
		d_indices, 
		d_rev_z_order,
		d_assem_sol.length
	) );

	d_temp_storage = malloc_device(temp_storage);

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_morton_codes,
		d_sorted_morton_codes, 
		d_indices,
		d_rev_z_order,
		d_assem_sol.length
	) );
	
	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_sorted_morton_codes, 
		d_indices,
		d_rev_row_major,
		d_assem_sol.length
	) );

	free_device(d_temp_storage);

	// ---------------------------------------------- //
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "cub/cub.cuh"

#include "../utilities/CHECK_CUDA_ERROR.cuh"

#include "../classes/AssembledSolution.h"
#include "../classes/SolverParams.h"
#include "../types/MortonCode.h"

__host__
void get_sorting_indices
(
	MortonCode*        d_morton_codes,
	MortonCode*        d_sorted_morton_codes,
	AssembledSolution& d_assem_sol,
	AssembledSolution& d_buf_assem_sol,
	MortonCode*        d_indices,
	MortonCode*        d_rev_z_order,
	MortonCode*        d_rev_row_major,
	SolverParams&      solver_params
);
#pragma once

#include "cuda_runtime.h"

#include "../types/real.h"

__device__ __forceinline__
real get_spatial_coord
(
	const int&  idx,
	const real& cellsize
)
{
	return idx * cellsize + cellsize / C(2.0);
}
#pragma once

#include "cuda_runtime.h"

#include "../utilities/get_lvl_idx.cuh"
#include "../zorder/get_i_index.cuh"
#include "get_spatial_coord.cuh"

__device__ __forceinline__
real get_x_coord
(
	const HierarchyIndex& h_idx, 
	const int&            level, 
	const int&            max_ref_lvl, 
	const real&           dx_finest
)
{
	real dx_loc = dx_finest * ( 1 << (max_ref_lvl - level) );
	
	MortonCode code = h_idx - get_lvl_idx(level);

	Coordinate i = get_i_index(code);

	return get_spatial_coord(i, dx_loc);
}
#pragma once

#include "cuda_runtime.h"

#include "../utilities/get_lvl_idx.cuh"
#include "../zorder/get_j_index.cuh"
#include "get_spatial_coord.cuh"

__device__ __forceinline__
real get_y_coord
(
	const HierarchyIndex& h_idx, 
	const int&            level, 
	const int&            max_ref_lvl, 
	const real&           dy_finest
)
{
	real dy_loc = dy_finest * ( 1 << (max_ref_lvl - level) );
	
	MortonCode code = h_idx - get_lvl_idx(level);

	Coordinate j = get_j_index(code);

	return get_spatial_coord(j, dy_loc);
}
#include "rev_z_order_act_idcs.cuh"

__global__
void rev_z_order_act_idcs
(
	MortonCode*       d_rev_row_major,
	AssembledSolution d_buf_assem_sol,
	AssembledSolution d_assem_sol,
	const int         num_finest_elems
)
{
	const int idx = blockDim.x * blockIdx.x + threadIdx.x;

	if (idx >= num_finest_elems) return;

	const int sorted_idx = d_rev_row_major[idx];

	d_assem_sol.act_idcs[idx] = d_buf_assem_sol.act_idcs[sorted_idx];
	d_assem_sol.levels[idx]   = d_buf_assem_sol.levels[sorted_idx];
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "cub/cub.cuh"

#include "../classes/AssembledSolution.h"
#include "../types/MortonCode.h"

__global__
void rev_z_order_act_idcs
(
	MortonCode*       d_rev_row_major,
	AssembledSolution d_buf_assem_sol,
	AssembledSolution d_assem_sol,
	const int         num_finest_elems
);
#include "../zorder/rev_z_order_assem_sol.cuh"

void rev_z_order_assem_sol
(
	MortonCode*       d_rev_z_order,
	MortonCode*       d_indices,
	AssembledSolution d_buf_assem_sol,
	AssembledSolution d_assem_sol,
	int               array_length
)
{
	void*  d_temp_storage = NULL;
	size_t temp_storage   = 0;

	// this launch only decides how much temp_storage is needed for allocation to d_temp_storage
	// use the large possible data type, here real in d_assem_sol.z, to allocate a largest d_temp_storage
	// that will be able to accommodate all further sorts
	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol.z0,
		d_assem_sol.z0,
		array_length
	) );

	d_temp_storage = malloc_device(temp_storage);

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol.h0,
		d_assem_sol.h0,
		array_length
	) );

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol.qx0,
		d_assem_sol.qx0,
		array_length
	) );

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol.qy0,
		d_assem_sol.qy0,
		array_length
	) );

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol.z0,
		d_assem_sol.z0,
		array_length
	) );

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol.levels,
		d_assem_sol.levels,
		array_length
	) );

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_buf_assem_sol.act_idcs,
		d_assem_sol.act_idcs,
		array_length
	) );

	free_device(d_temp_storage);
}
#pragma once

#include "cuda_runtime.h"
#include "cub/cub.cuh"

#include "../utilities/cuda_utils.cuh"

#include "../classes/AssembledSolution.h"
#include "../types/MortonCode.h"

void rev_z_order_assem_sol
(
	MortonCode*       d_rev_z_order,
	MortonCode*       d_indices,
	AssembledSolution d_buf_assem_sol,
	AssembledSolution d_assem_sol,
	int               array_length
);
#include "rev_z_order_reals.cuh"

__host__
void rev_z_order_reals
(
	MortonCode* d_rev_z_order,
	MortonCode* d_indices,
	real*       d_array,
	real*       d_array_sorted,
	int         array_length
)
{
	void*  d_temp_storage = NULL;
	size_t temp_storage   = 0;

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_array,
		d_array_sorted,
		array_length
	) );

	d_temp_storage = malloc_device(temp_storage);

	CHECK_CUDA_ERROR( cub::DeviceRadixSort::SortPairs
	(
		d_temp_storage,
		temp_storage,
		d_rev_z_order,
		d_indices,
		d_array,
		d_array_sorted,
		array_length
	) );

	free_device(d_temp_storage);
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "cub/device/device_radix_sort.cuh"

#include "../types/real.h"
#include "../types/MortonCode.h"

__host__
void rev_z_order_reals
(
	MortonCode* d_rev_z_order,
	MortonCode* d_indices,
	real*       d_array,
	real*       d_array_sorted,
	int         array_length
);
#include "sort_finest_scale_coeffs_z_order.cuh"

__global__
void sort_finest_scale_coeffs_z_order
(
	AssembledSolution d_buf_assem_sol,
	AssembledSolution d_assem_sol,
	MortonCode*       d_rev_z_order,
	SolverParams      solver_params
)
{
	const int idx = blockDim.x * blockIdx.x + threadIdx.x;

	if (idx >= d_assem_sol.length) return;

	const int sorted_idx = d_rev_z_order[idx];
	
	d_assem_sol.h0[idx]  = d_buf_assem_sol.h0[sorted_idx];
	d_assem_sol.qx0[idx] = d_buf_assem_sol.qx0[sorted_idx];
	d_assem_sol.qy0[idx] = d_buf_assem_sol.qy0[sorted_idx];
	d_assem_sol.z0[idx]  = d_buf_assem_sol.z0[sorted_idx];

	if (solver_params.solver_type == MWDG2)
	{
		d_assem_sol.h1x[idx]  = d_buf_assem_sol.h1x[sorted_idx];
	    d_assem_sol.qx1x[idx] = d_buf_assem_sol.qx1x[sorted_idx];
	    d_assem_sol.qy1x[idx] = d_buf_assem_sol.qy1x[sorted_idx];
	    d_assem_sol.z1x[idx]  = d_buf_assem_sol.z1x[sorted_idx];
		
		d_assem_sol.h1y[idx]  = d_buf_assem_sol.h1y[sorted_idx];
	    d_assem_sol.qx1y[idx] = d_buf_assem_sol.qx1y[sorted_idx];
	    d_assem_sol.qy1y[idx] = d_buf_assem_sol.qy1y[sorted_idx];
	    d_assem_sol.z1y[idx]  = d_buf_assem_sol.z1y[sorted_idx];
	}
}
#pragma once

#include "../utilities/cuda_utils.cuh"

#include "cub/cub.cuh"

#include "../utilities/CHECK_CUDA_ERROR.cuh"

#include "../classes/AssembledSolution.h"
#include "../classes/SolverParams.h"
#include "../types/MortonCode.h"

__global__
void sort_finest_scale_coeffs_z_order
(
	AssembledSolution d_buf_assem_sol,
	AssembledSolution d_assem_sol,
	MortonCode*       d_rev_z_order,
	SolverParams      solver_params
);
#include "sort_neighbours_z_order.cuh"

__global__
void sort_neighbours_z_order
(
	const Neighbours   d_neighbours,
	const Neighbours   d_buf_neighbours,
	MortonCode*        d_rev_z_order,
	const int          num_finest_elems,
	const SolverParams solver_params
)
{
	const int idx = blockDim.x * blockIdx.x + threadIdx.x;

	if (idx >= num_finest_elems) return;

	const int sorted_idx = d_rev_z_order[idx];

	d_buf_neighbours.north.act_idcs[idx] = d_neighbours.north.act_idcs[sorted_idx];
	d_buf_neighbours.east.act_idcs[idx]  = d_neighbours.east.act_idcs[sorted_idx];
	d_buf_neighbours.south.act_idcs[idx] = d_neighbours.south.act_idcs[sorted_idx];
	d_buf_neighbours.west.act_idcs[idx]  = d_neighbours.west.act_idcs[sorted_idx];

	if (solver_params.solver_type == MWDG2)
	{
		d_buf_neighbours.north.levels[idx] = d_neighbours.north.levels[sorted_idx];
		d_buf_neighbours.east.levels[idx]  = d_neighbours.east.levels[sorted_idx];
		d_buf_neighbours.south.levels[idx] = d_neighbours.south.levels[sorted_idx];
		d_buf_neighbours.west.levels[idx]  = d_neighbours.west.levels[sorted_idx];
	}
}
#pragma once

#include "cuda_runtime.h"

#include "cub/device/device_radix_sort.cuh"

#include "../utilities/CHECK_CUDA_ERROR.cuh"
#include "../utilities/cuda_utils.cuh"

#include "../classes/Neighbours.h"
#include "../types/MortonCode.h"
#include "../classes/SolverParams.h"

__global__
void sort_neighbours_z_order
(
	const Neighbours   d_neighbours,
	const Neighbours   d_buf_neighbours,
	MortonCode*        d_rev_z_order,
	const int          num_finest_elems,
	const SolverParams solver_params
);
